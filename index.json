[{"content":"Google Breakpad是一套完整的工具集，从crash的捕获到crash的dump，都提供了相对应的工具。\n1. 编译与安装 项目中要用到breakpad编译后的两个可执行文件src/processor/minidump_stackwalk和src/tools/linux/dump_syms/dump_syms，前者其实Android Studio已经提供了Windows版的，在Android Studio/bin/lldb/bin下，但是dump_syms只能从源码编译得到，而且最好是在Linux环境下编译及使用，所以可以使用WSL进行，WSL在Windows Store上下载即可使用，可选Ubuntu-20.04、Ubuntu-18.04等等。\n1.1 depot_tools安装 depot_tools是用于管理Google开源项目，不仅仅有breakpad，还可以获取Chromium、WebRTC等源码，这里使用depot_tools拉取breakpad的源码，如果是从Github上clone的breakpad源码可能会缺失linux_syscall_support.h头文件\ngit clone https://chromium.googlesource.com/chromium/tools/depot_tools.git 添加环境变量并source ~/.bashrc，如果用的是zsh，同理修改.zshrc\nexport PATH=/path/to/depot_tools:$PATH 1.2 breakpad编译与安装 首先需要安装python 2，否则fetch breakpad会失败；并且安装基础编译工具\nsudo apt-get update sudo apt install python 按照Github指示一步一步执行即可：\nmkdir breakpad \u0026amp;\u0026amp; cd breakpad fetch breakpad cd src ./configure \u0026amp;\u0026amp; make sudo make install 其中fetch breakpad可能需要10分钟以上，成功的结果\ntao@LTSZ-TaoZhou:~/breakpad$ fetch breakpad Running: gclient root Running: gclient config --spec \u0026#39;solutions = [ { \u0026#34;name\u0026#34;: \u0026#34;src\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://chromium.googlesource.com/breakpad/breakpad.git\u0026#34;, \u0026#34;managed\u0026#34;: False, \u0026#34;custom_deps\u0026#34;: {}, }, ] \u0026#39; Running: gclient sync ________ running \u0026#39;git -c core.deltaBaseCacheLimit=2g clone --no-checkout --progress https://chromium.googlesource.com/breakpad/breakpad.git /home/tao/breakpad/_gclient_src_a_m392sy\u0026#39; in \u0026#39;/home/tao/breakpad\u0026#39; Cloning into \u0026#39;/home/tao/breakpad/_gclient_src_a_m392sy\u0026#39;... remote: Sending approximately 40.06 MiB ... remote: Total 19092 (delta 14865), reused 19092 (delta 14865) Receiving objects: 100% (19092/19092), 40.06 MiB | 4.63 MiB/s, done. Resolving deltas: 100% (14865/14865), done. Syncing projects: 80% ( 4/ 5) src/src/testing [0:01:44] Still working on: [0:01:44] src/src/third_party/protobuf/protobuf [0:01:54] Still working on: [0:01:54] src/src/third_party/protobuf/protobuf [0:02:04] Still working on: [0:02:04] src/src/third_party/protobuf/protobuf [0:02:14] Still working on: [0:02:14] src/src/third_party/protobuf/protobuf [0:02:24] Still working on: [0:02:24] src/src/third_party/protobuf/protobuf [0:02:34] Still working on: [0:02:34] src/src/third_party/protobuf/protobuf [0:02:44] Still working on: [0:02:44] src/src/third_party/protobuf/protobuf [0:02:54] Still working on: [0:02:54] src/src/third_party/protobuf/protobuf [0:02:55] Still working on: [0:02:55] src/src/third_party/protobuf/protobuf Syncing projects: 100% (5/5), done. Running hooks: 100% (3/3), done. Running: git submodule foreach \u0026#39;git config -f $toplevel/.git/config submodule.$name.ignore all\u0026#39; Running: git config --add remote.origin.fetch \u0026#39;+refs/tags/*:refs/tags/*\u0026#39; Running: git config diff.ignoreSubmodules all ./configure \u0026amp;\u0026amp; make结果，没有显示error即可，最后sudo make install，install需要root权限\ng++ -I./src/third_party/mac_headers -DHAVE_MACH_O_NLIST_H -g -O2 -o src/tools/mac/dump_syms/dump_syms_mac src/common/src_tools_mac_dump_syms_dump_syms_mac-dwarf_cfi_to_module.o src/common/src_tools_mac_dump_syms_dump_syms_mac-dwarf_cu_to_module.o src/common/src_tools_mac_dump_syms_dump_syms_mac-dwarf_line_to_module.o src/common/src_tools_mac_dump_syms_dump_syms_mac-dwarf_range_list_handler.o src/common/src_tools_mac_dump_syms_dump_syms_mac-language.o src/common/src_tools_mac_dump_syms_dump_syms_mac-md5.o src/common/src_tools_mac_dump_syms_dump_syms_mac-module.o src/common/src_tools_mac_dump_syms_dump_syms_mac-path_helper.o src/common/src_tools_mac_dump_syms_dump_syms_mac-stabs_reader.o src/common/src_tools_mac_dump_syms_dump_syms_mac-stabs_to_module.o src/common/dwarf/src_tools_mac_dump_syms_dump_syms_mac-bytereader.o src/common/dwarf/src_tools_mac_dump_syms_dump_syms_mac-dwarf2diehandler.o src/common/dwarf/src_tools_mac_dump_syms_dump_syms_mac-dwarf2reader.o src/common/dwarf/src_tools_mac_dump_syms_dump_syms_mac-elf_reader.o src/common/mac/src_tools_mac_dump_syms_dump_syms_mac-arch_utilities.o src/common/mac/src_tools_mac_dump_syms_dump_syms_mac-dump_syms.o src/common/mac/src_tools_mac_dump_syms_dump_syms_mac-file_id.o src/common/mac/src_tools_mac_dump_syms_dump_syms_mac-macho_id.o src/common/mac/src_tools_mac_dump_syms_dump_syms_mac-macho_reader.o src/common/mac/src_tools_mac_dump_syms_dump_syms_mac-macho_utilities.o src/common/mac/src_tools_mac_dump_syms_dump_syms_mac-macho_walker.o src/tools/mac/dump_syms/src_tools_mac_dump_syms_dump_syms_mac-dump_syms_tool.o 最后测试一下\ntao@LTSZ-TaoZhou:~$ dump_syms -V 2.4 -V Usage: dump_syms [OPTION] \u0026lt;binary-with-debugging-info\u0026gt; [directories-for-debug-file] Options: -i: Output module header information only. -c Do not generate CFI section -r Do not handle inter-compilation unit references -v Print all warnings to stderr -n \u0026lt;name\u0026gt; Use specified name for name of the object -o \u0026lt;os\u0026gt; Use specified name for the operating system tao@LTSZ-TaoZhou:~$ minidump_stackwalk -V minidump_stackwalk: invalid option -- \u0026#39;V\u0026#39; Usage: minidump_stackwalk [options] \u0026lt;minidump-file\u0026gt; [symbol-path ...] Output a stack trace for the provided minidump Options: -m Output in machine-readable format -s Output stack contents 参考： Breakpad Github depot_tools_tutorial ","permalink":"https://zhoutao822.github.io/posts/breakpad/","summary":"Breakpad是一个库和工具套件可以让你发布的应用程序（把编译器提供的调试信息剥离掉的）给用户，记录了崩溃紧凑的“dump”文件，发送回您的服务器，并从这些minidump产生C和C++堆栈踪迹。","title":"Breakpad"},{"content":"Windows环境 1. 安装LaTeX发行版 在Windows下我选择的是MikTeX，Mac下选择的是MacTex，这个LaTeX发行版相当于一个开发工具包，你需要的编译器以及某些资源文件都包含在这个包里面，安装完成后可以通过命令行启用。\n在Windows下MikTeX的安装教程链接为Install MiKTeX on Windows，链接里也给出了安装包的地址Basic MiKTeX Installer，安装完成后打开 MiKTeX Console 更新package。目前这个阶段还不需要安装额外的package，这个我们可以等到编译论文的时候再下载。\n2. VSCode安装与参数设置 VSCode的安装没什么可说的，完成后需要在扩展中搜索latex，就可以找到需要的插件LaTeX Workshop，安装完成后需要配置一些参数，在设置中搜索latex，打开settings.json，加入以下参数\n\u0026#34;latex-workshop.view.pdf.viewer\u0026#34;: \u0026#34;tab\u0026#34;, \u0026#34;latex-workshop.latex.recipes\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;latexmk\u0026#34;, \u0026#34;tools\u0026#34;: [ \u0026#34;latexmk\u0026#34; ] }, { \u0026#34;name\u0026#34;: \u0026#34;pdflatex\u0026#34;, \u0026#34;tools\u0026#34;: [ \u0026#34;pdflatex\u0026#34; ] }, { \u0026#34;name\u0026#34;: \u0026#34;pdflatex -\u0026gt; bibtex -\u0026gt; pdflatex*2\u0026#34;, \u0026#34;tools\u0026#34;: [ \u0026#34;pdflatex\u0026#34;, \u0026#34;bibtex\u0026#34;, \u0026#34;pdflatex\u0026#34;, \u0026#34;pdflatex\u0026#34; ] } ], \u0026#34;latex-workshop.latex.tools\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;xelatex\u0026#34;, \u0026#34;command\u0026#34;: \u0026#34;xelatex\u0026#34;, \u0026#34;args\u0026#34;: [ \u0026#34;-synctex=1\u0026#34;, \u0026#34;-interaction=nonstopmode\u0026#34;, \u0026#34;-file-line-error\u0026#34;, \u0026#34;%DOC%\u0026#34; ] }, { \u0026#34;name\u0026#34;: \u0026#34;pdflatex\u0026#34;, \u0026#34;command\u0026#34;: \u0026#34;pdflatex\u0026#34;, \u0026#34;args\u0026#34;: [ \u0026#34;-synctex=1\u0026#34;, \u0026#34;-interaction=nonstopmode\u0026#34;, \u0026#34;-file-line-error\u0026#34;, \u0026#34;%DOC%\u0026#34; ] }, { \u0026#34;name\u0026#34;: \u0026#34;latexmk\u0026#34;, \u0026#34;command\u0026#34;: \u0026#34;latexmk\u0026#34;, \u0026#34;args\u0026#34;: [ \u0026#34;-xelatex\u0026#34; ] }, { \u0026#34;name\u0026#34;: \u0026#34;bibtex\u0026#34;, \u0026#34;command\u0026#34;: \u0026#34;bibtex\u0026#34;, \u0026#34;args\u0026#34;: [ \u0026#34;%DOCFILE%\u0026#34; ] } ], \u0026#34;latex-workshop.latex.autoBuild.run\u0026#34;: \u0026#34;never\u0026#34;, \u0026#34;latex-workshop.latex.autoClean.run\u0026#34;: \u0026#34;never\u0026#34;, \u0026#34;latex-workshop.latex.clean.fileTypes\u0026#34;: [ \u0026#34;*.aux\u0026#34;, \u0026#34;*.bbl\u0026#34;, \u0026#34;*.blg\u0026#34;, \u0026#34;*.idx\u0026#34;, \u0026#34;*.ind\u0026#34;, \u0026#34;*.lof\u0026#34;, \u0026#34;*.lot\u0026#34;, \u0026#34;*.out\u0026#34;, \u0026#34;*.toc\u0026#34;, \u0026#34;*.acn\u0026#34;, \u0026#34;*.acr\u0026#34;, \u0026#34;*.alg\u0026#34;, \u0026#34;*.glg\u0026#34;, \u0026#34;*.glo\u0026#34;, \u0026#34;*.gls\u0026#34;, \u0026#34;*.ist\u0026#34;, \u0026#34;*.fls\u0026#34;, \u0026#34;*.log\u0026#34;, \u0026#34;*.xdv\u0026#34;, \u0026#34;*.fdb_latexmk\u0026#34;, \u0026#34;*.synctex.gz\u0026#34; ] 参数说明：\nlatex-workshop.view.pdf.viewer设置为tab可以在VSCode里查看生成的pdf文件，你也可以选择其他方式； latex-workshop.latex.tools定义你可能需要用到的编译工具，比如latexmk、xelatex、pdflatex等等，这里定义的工具才可以在latex-workshop.latex.recipes里使用，这里latexmk的参数被修改为-xelatex，与Github上相同，我这里加入了很多的工具，并不一定全都要用； latex-workshop.latex.recipes定义编译方式，比如latexmk、pdflatex -\u0026gt; bibtex -\u0026gt; pdflatex*2，这里同上，也并不一定全都要用，不同的编译方式会导致最终生成的pdf文件内容存在差异，使用latexmk以外的编译工具编译中国科学技术大学学位论文 LaTeX 模板可能会导致pdf中丢失目录以及文献列表等内容，在这里定义的编译方式会在后面显示在VSCode的选项中； latex-workshop.latex.autoBuild.run设置为never是为了避免每次修改完tex文件后自动编译，也可以不设置此参数； latex-workshop.latex.autoClean.run设置为never是为了避免自动清理编译过程产生的临时文件，这里会有一些log文件，也可以不设置此参数。 latex-workshop.latex.clean.fileTypes设置需要清理临时文件类型，以各种后缀表示，有些文件可能不需要清理，这个需要自行判断。 3. 编译论文模板 在中国科学技术大学学位论文 LaTeX 模板下载release文件ustcthesis-v3.1.06.zip，这里面有模板以及样例文件。\n文件目录大概如下图，里面某些pdf和tex文件可能不同，但不重要\n用VSCode打开模板文件，并打开main.tex文件，这里可以先把main.pdf重命名一下，此时如果之前的步骤都是对的，那么VSCode的左下角会有一个勾的图标，点击后应该如下图\n这里会发现之前设置参数时加入的recipe都显示出来，中国科学技术大学学位论文 LaTeX 模板 需要用latexmk编译，所以直接双击Recipe: latexmk编译main.tex，生成main.pdf文件，在编译过程中会提示你缺少某些package，这些package里面有需要的一些样式文件，类似于CSS，弹出的窗口来自于MikTeX Console，点击确定下载即可，可能会需要点很多次，当所有需要的package下载完成后编译也可以继续下去，最后比对一下生成的main.pdf文件内容与重命名之前的main.pdf，看看有没有缺失或者显示不对的地方，如果有，再查找原因，一般来说问题出在缺少某些package。如果需要清理生成的临时文件只需要双击Clean up即可。\n这是我生成的pdf文件截图，第一张图我修改为硕士，第二张图生成当前时间。\nMac环境 1. 安装LaTeX发行版 在Mac下选择的安装MacTeX，而MacTeX有几个不同的安装包，一个是MacTeX.pkg，大概3.9G，还有一个是BasicTeX.pkg，大概76M，区别在于前者包括了GUI，大概有4个工具配合使用，后者没有GUI仅提供命令行工具，这里我选择了后者，前者应该也没有区别。\n命令行工具为tlmgr，我在运行时需要加sudo，应该是安装路径对一般用户不可写。\n然后需要使用tlmgr安装一些package，我们先设置一下镜像源加速下载\n# 这是清华镜像源，也可以使用科大镜像源http://mirrors.ustc.edu.cn/CTAN/systems/texlive/tlnet tlmgr option repository https://mirrors.tuna.tsinghua.edu.cn/CTAN/systems/texlive/tlnet 然后更新自己和所有的package\nsudo tlmgr update --self --all 最后需要下载latexmk包，Windows不需要应该是MikTeX中已经包含了这个包，而Mac下BasicTeX没有包含，所以需要自己下载。\nsudo tlmgr install latexmk 2. VSCode安装与参数设置 安装配置同Windows。\n3. 编译论文模板 在Mac上使用latexmk -xelatex main.tex会失败，而且系统不会像Windows那样提示你需要下载哪些package，每次失败都会告诉你缺少哪个文件，这个在log中是可以看到的，一般来说在CTAN官网搜索缺少的文件就可以知道需要下载哪个package。\n下载package的代码为\n# package_name为包名，比如可能有siunitx... sudo tlmgr install package_name 这些下载的package是可以在/usr/local/texlive/2019basic/texmf-dist/tex/latex下找到的，我的可以正确运行科大LaTeX模板的package截图如下，不想一个一个搜索的可以直接对照下载缺少的package。\n最后同上测试一下能否正确生成pdf文件。\n参考： 中国科学技术大学学位论文 LaTeX 模板\n论文写作的又一利器：VSCode + LaTeX Workshop + MikTex + Git\nMikTeX\nMacTeX\nVSCode\n","permalink":"https://zhoutao822.github.io/posts/latex-vscode/","summary":"USTC LaTex模板编译及使用","title":"VSCode搭建LaTeX论文写作环境"},{"content":" 1. Ubuntu服务器安装docker 强烈建议在ubuntu上使用apt安装docker，brew安装docker会出现很多问题\n需要安装两个关键包docker和docker-compose，前者是docker容器，后者是一个可以根据docker-compose.yml配置文件快速部署docker应用的软件，后续会使用到。\n使用sudo apt install docker.io以及sudo apt install docker-compose安装（如果你想尝试使用brew也可以按照以下方式使用）。\n首先查看一下docker相关包\nubuntu@VM-0-9-ubuntu ~ brew search docker ==\u0026gt; Formulae docker docker-ls docker-machine-parallels docker-clean docker-machine docker-slim docker-completion docker-machine-completion docker-squash docker-compose docker-machine-driver-hyperkit docker-swarm docker-compose-completion docker-machine-driver-vmware docker2aci docker-credential-helper docker-machine-driver-vultr dockerize docker-credential-helper-ecr docker-machine-driver-xhyve lazydocker docker-gen docker-machine-nfs ==\u0026gt; Casks homebrew/cask-versions/docker-edge homebrew/cask/docker-toolbox homebrew/cask/docker 执行brew install docker以及brew install docker-compose\n安装完成查看版本信息并开启docker服务sudo systemctl stop docker，然后可以执行docker run hello-world测试docker是否可以正常运行\nubuntu@VM-0-9-ubuntu ~ docker-compose -v docker-compose version 1.25.1, build unknown ubuntu@VM-0-9-ubuntu ~ docker -v Docker version 19.03.5, build 633a0ea ubuntu@VM-0-9-ubuntu ~ sudo systemctl stop docker ubuntu@VM-0-9-ubuntu ~ docker run hello-world Unable to find image \u0026#39;hello-world:latest\u0026#39; locally latest: Pulling from library/hello-world 1b930d010525: Pull complete Digest: sha256:d1668a9a1f5b42ed3f46b70b9cb7c88fd8bdc8a2d73509bb0041cf436018fbf5 Status: Downloaded newer image for hello-world:latest Hello from Docker! This message shows that your installation appears to be working correctly. 2. 配置docker-compose Chevereto支持通过docker部署，这样方便进行管理而且不会影响服务器环境，数据保存和导入也更加方便。使用docker-compose可以快速部署，并且配置一些数据卷挂载以及依赖容器等等。\n首先在根目录下创建一个隐藏文件夹.chevereto存放我们的配置文件以及挂载的数据卷，进入.chevereto目录，并新建一个docker-compose.yml文件，以及三个文件夹chevereto_images、conf、database，docker-compose.yml内容如下：\nversion: \u0026#39;3\u0026#39; services: db: image: mariadb container_name: chevereto-mysql # 挂载容器中的mysql数据卷到本地database文件夹 volumes: - ./database:/var/lib/mysql:rw restart: always networks: - chevereto-net # 设置容器中的mysql的root用户密码以及其他用户 environment: MYSQL_ROOT_PASSWORD: root MYSQL_DATABASE: chevereto MYSQL_USER: chevereto MYSQL_PASSWORD: chevereto chevereto: depends_on: - db image: nmtan/chevereto container_name: chevereto restart: always networks: - chevereto-net # 设置CHEVERETO_DB的一些参数 environment: CHEVERETO_DB_HOST: db CHEVERETO_DB_USERNAME: chevereto CHEVERETO_DB_PASSWORD: chevereto CHEVERETO_DB_NAME: chevereto CHEVERETO_DB_PREFIX: chv_ # 挂载容器中的images文件夹到本地的chevereto_images文件夹，以及 # 将本地的conf/upload.ini配置文件挂载到容器的/usr/local/etc/php/conf.d/中 volumes: - ./chevereto_images:/var/www/html/images:rw - ./conf/upload.ini:/usr/local/etc/php/conf.d/upload.ini:ro # 端口映射，本机:容器，需要配置安全组 ports: - 7777:80 networks: chevereto-net: volumes: database: chevereto_images: 我们创建的三个文件夹分别挂载了不同的容器文件夹，chevereto_images和database用于数据迁移，/conf/upload.ini用于配置上传文件限制。\n在conf目录中创建upload.ini，这个可以取消2MB文件上传限制，内容如下：\nPHP: max_execution_time = 60; memory_limit = 256M; upload_max_filesize = 256M; post_max_size = 256M; 然后修改权限sudo chown -R www-data:www-data database chevereto_images conf，最后启动docker-compose up -d，然后就可以通过IP+端口号访问chevereto图床了（应该只能通过http访问，https是不可以的）。首次登录如下：\n修改语言为中文\n可以看到文件上传大小被修改为上面的uploda.ini的内容了\n3. 数据迁移 上面我们的database文件夹保存的是我们的账号信息、配置信息等等，chevereto_images保存了我们上传的图片数据，如果我们需要从当前服务器迁移到另一个服务器只需要保存好.chevereto中的所有内容，然后全部放到另一个服务器的.chevereto目录中，同样设置权限，然后安装docker和docker-compose，然后执行docker-compose up -d就可以直接运行，我们的数据也会一起同步过来。\n参考： Chevereto Free Docker 使用Docker轻松搭建个人图床chevereto ","permalink":"https://zhoutao822.github.io/posts/chevereto/","summary":"chevereto是具有拖放上传、多服务器支持、图像审核、图像分类、用户帐户、私人相册等功能的卓越的图像上传工具","title":"使用Docker方式安装chevereto图床"},{"content":"1. Ubuntu服务器安装docker 参考Docker方式安装chevereto图床\n2. 配置docker-compose 首先在根目录下创建一个隐藏文件夹.seafile存放我们的配置文件以及挂载的数据卷，进入.seafile目录，并新建一个docker-compose.yml文件，docker-compose.yml内容如下，需要自行配置管理员账号和密码（尽量不要修改80:80端口映射，我修改为其他端口号会导致拒绝访问），seafile-mysql、seafile-data启动后会自动生成：\nversion: \u0026#39;2.0\u0026#39; services: db: image: mariadb:10.1 container_name: seafile-mysql environment: - MYSQL_ROOT_PASSWORD=root # Requested, set the root\u0026#39;s password of MySQL service. - MYSQL_LOG_CONSOLE=true # 挂载容器mysql数据到本地文件夹seafile-mysql volumes: - ./seafile-mysql:/var/lib/mysql # Requested, specifies the path to MySQL data persistent store. networks: - seafile-net memcached: image: memcached:1.5.6 container_name: seafile-memcached entrypoint: memcached -m 256 networks: - seafile-net seafile: image: seafileltd/seafile-mc container_name: seafile ports: - \u0026#34;80:80\u0026#34; # - \u0026#34;443:443\u0026#34; # If https is enabled, cancel the comment. # 挂载云盘数据到本地文件夹seafile-data volumes: - ./seafile-data:/shared # Requested, specifies the path to Seafile data persistent store. environment: - DB_HOST=db - DB_ROOT_PASSWD=root # Requested, the value shuold be root\u0026#39;s password of MySQL service. #- TIME_ZONE=Asia/Shanghai # Optional, default is UTC. Should be uncomment and set to your local time zone. - SEAFILE_ADMIN_EMAIL=aaa@aaa.com # Specifies Seafile admin user, default is \u0026#39;me@example.com\u0026#39;. - SEAFILE_ADMIN_PASSWORD=password # Specifies Seafile admin password, default is \u0026#39;asecret\u0026#39;. - SEAFILE_SERVER_LETSENCRYPT=false # Whether use letsencrypt to generate cert. - SEAFILE_SERVER_HOSTNAME=175.24.47.141 # Specifies your host name. depends_on: - db - memcached networks: - seafile-net networks: seafile-net: 不用修改权限，最后启动docker-compose up -d，然后就可以通过IP+端口号（如果配置了域名也可以用域名）访问seafile云盘了（应该只能通过http访问，https是不可以的，除非配置过）。首次登录如下：\n测试上传文件\n3. 数据迁移 同理，上面我们的seafile-mysql文件夹保存的是我们的账号信息等等，seafile-data保存了我们上传的文件数据、日志信息，如果我们需要从当前服务器迁移到另一个服务器只需要保存好.seafile中的所有内容，然后全部放到另一个服务器的.seafile目录中，不用设置权限，然后安装docker和docker-compose，然后执行docker-compose up -d就可以直接运行，我们的数据也会一起同步过来。\n4. 启动seafile容器出错 如果启动seafile容器后无法访问，需要重新配置时，务必先执行docker-compose kill和docker-compose rm停止并删除容器，再删除掉seafile-mysql和seafile-data两个文件夹，之后再重新启动docker-compose up -d。\n参考： 用 Docker 部署 Seafile 服务\n","permalink":"https://zhoutao822.github.io/posts/seafile/","summary":"Seafile是一款开源的企业云盘，注重可靠性和性能。支持 Windows, Mac, Linux, iOS, Android 平台。支持文件同步或者直接挂载到本地访问","title":"使用Docker方式安装Seafile私人网盘"},{"content":"1. Multipass \u0026amp;\u0026amp; K3s \u0026amp;\u0026amp; k9s 1.1 Multipass说明 Multipass是一个轻量级的可以用于开启Ubuntu虚拟机的命令行工具，你可以把它当做一个无图形界面的Virtual Box或者Parallels Desktop。在mac上可以通过brew安装，命令为\nbrew install --cask multipass 安装完成后执行multipass version，输出如下结果说明安装成功\n~ ❯ multipass version 20:45:29 multipass 1.8.1+mac multipassd 1.8.1+mac Multipass常见指令如下：\nLaunch an instance (by default you get the current Ubuntu LTS)\nmultipass launch --name foo Run commands in that instance, try running bash (logout or ctrl-d to quit)\nmultipass exec foo -- lsb_release -a Pass a cloud-init metadata file to an instance on launch. See using cloud-init with multipass for more details\nmultipass launch -n bar --cloud-init cloud-config.yaml See your instances\nmultipass list Stop and start instances\nmultipass stop foo bar multipass start foo Clean up what you don’t need\nmultipass delete bar multipass purge Find alternate images to launch with multipass\nmultipass find Get help\nmultipass help multipass help \u0026lt;command\u0026gt; 1.2 K3s k3s用于快速搭建k8s集群，注意这里k3s不是安装到mac上的而是安装到multipass创建的Ubuntu实例中，常用k3s安装脚本如下\ncurl -sfL https://get.k3s.io | sh - 一般来说国内访问可能失败，导致无法拉取需要资源，所以可以使用国内镜像源\ncurl -sfL http://rancher-mirror.cnrancher.com/k3s/k3s-install.sh | INSTALL_K3S_MIRROR=cn sh - k3s常见环境变量如下\nEnvironment Variable Description INSTALL_K3S_SKIP_DOWNLOAD 如果设置为 \u0026ldquo;true \u0026ldquo;将不会下载 K3s 的哈希值或二进制。 INSTALL_K3S_SYMLINK 默认情况下，如果路径中不存在命令，将为 kubectl、crictl 和 ctr 二进制文件创建符号链接。如果设置为\u0026rsquo;skip\u0026rsquo;将不会创建符号链接，而\u0026rsquo;force\u0026rsquo;将覆盖。 INSTALL_K3S_SKIP_ENABLE 如果设置为 \u0026ldquo;true\u0026rdquo;，将不启用或启动 K3s 服务。 INSTALL_K3S_SKIP_START 如果设置为 \u0026ldquo;true \u0026ldquo;将不会启动 K3s 服务。 INSTALL_K3S_VERSION 从 Github 下载 K3s 的版本。如果没有指定，将尝试从\u0026quot;stable\u0026quot;频道下载。 INSTALL_K3S_BIN_DIR 安装 K3s 二进制文件、链接和卸载脚本的目录，或者使用/usr/local/bin作为默认目录。 INSTALL_K3S_BIN_DIR_READ_ONLY 如果设置为 true 将不会把文件写入INSTALL_K3S_BIN_DIR，强制设置INSTALL_K3S_SKIP_DOWNLOAD=true。 INSTALL_K3S_SYSTEMD_DIR 安装 systemd 服务和环境文件的目录，或者使用/etc/systemd/system作为默认目录。 INSTALL_K3S_EXEC 带有标志的命令，用于在服务中启动 K3s。如果未指定命令，并且设置了K3S_URL，它将默认为“agent”。如果未设置K3S_URL，它将默认为“server”。要获得帮助，请参考此示例。 INSTALL_K3S_NAME 要创建的 systemd 服务名称，如果以服务器方式运行 k3s，则默认为\u0026rsquo;k3s\u0026rsquo;；如果以 agent 方式运行 k3s，则默认为\u0026rsquo;k3s-agent\u0026rsquo;。如果指定了服务名，则服务名将以\u0026rsquo;k3s-\u0026lsquo;为前缀。 INSTALL_K3S_TYPE 要创建的 systemd 服务类型，如果没有指定，将默认使用 K3s exec 命令。 INSTALL_K3S_SELINUX_WARN 如果设置为 true，则在没有找到 k3s-selinux 策略的情况下将继续。 INSTALL_K3S_SKIP_SELINUX_RPM 如果设置为 \u0026ldquo;true \u0026ldquo;将跳过 k3s RPM 的自动安装。 INSTALL_K3S_CHANNEL_URL 用于获取 K3s 下载网址的频道 URL。默认为 https://update.k3s.io/v1-release/channels 。 INSTALL_K3S_CHANNEL 用于获取 K3s 下载 URL 的通道。默认值为 \u0026ldquo;stable\u0026rdquo;。选项包括：stable, latest, testing。 K3S_CONFIG_FILE 指定配置文件的位置。默认目录为/etc/rancher/k3s/config.yaml。 K3S_TOKEN 用于将 server 或 agent 加入集群的共享 secret。 K3S_TOKEN_FILE 指定 cluster-secret,token 的文件目录。 1.3 multipass-k3s脚本 k3s cluster on multipass instances给出了脚本，可以直接利用multipass和k3s创建k8s集群，我做了一些修改，比如替换了国内用的镜像源、使用2个slave节点、修改内存之类\n#!/usr/bin/env bash # Configure your settings # Name for the cluster/configuration files NAME=\u0026#34;demo-cluster\u0026#34; # Ubuntu image to use (xenial/bionic) IMAGE=\u0026#34;focal\u0026#34; # How many additional server instances to create SERVER_COUNT_MACHINE=\u0026#34;0\u0026#34; # How many agent instances to create AGENT_COUNT_MACHINE=\u0026#34;2\u0026#34; # How many CPUs to allocate to each machine SERVER_CPU_MACHINE=\u0026#34;2\u0026#34; AGENT_CPU_MACHINE=\u0026#34;1\u0026#34; # How much disk space to allocate to each machine SERVER_DISK_MACHINE=\u0026#34;5G\u0026#34; AGENT_DISK_MACHINE=\u0026#34;5G\u0026#34; # How much memory to allocate to each machine SERVER_MEMORY_MACHINE=\u0026#34;2G\u0026#34; AGENT_MEMORY_MACHINE=\u0026#34;1G\u0026#34; # Install channel to use (embedded etcd is fully supported starting with v1.19.5+k3s1) CHANNEL=stable # Preconfigured secret to join the cluster (or autogenerated if empty) SERVER_TOKEN=\u0026#34;\u0026#34; # Preconfigured secret to join the cluster (or autogenerated if empty) AGENT_TOKEN=\u0026#34;\u0026#34; ## Nothing to change after this line if [ -x \u0026#34;$(command -v multipass.exe)\u0026#34; \u0026gt; /dev/null 2\u0026gt;\u0026amp;1 ]; then # Windows MULTIPASSCMD=\u0026#34;multipass.exe\u0026#34; elif [ -x \u0026#34;$(command -v multipass)\u0026#34; \u0026gt; /dev/null 2\u0026gt;\u0026amp;1 ]; then # Linux/MacOS MULTIPASSCMD=\u0026#34;multipass\u0026#34; else echo \u0026#34;The multipass binary (multipass or multipass.exe) is not available or not in your \\$PATH\u0026#34; exit 1 fi if [ -z $SERVER_TOKEN ]; then SERVER_TOKEN=$(cat /dev/urandom | base64 | tr -dc \u0026#39;a-zA-Z0-9\u0026#39; | fold -w 20 | head -n 1 | tr \u0026#39;[:upper:]\u0026#39; \u0026#39;[:lower:]\u0026#39;) echo \u0026#34;No server token given, generated server token: ${SERVER_TOKEN}\u0026#34; fi if [ -z $AGENT_TOKEN ]; then AGENT_TOKEN=$(cat /dev/urandom | base64 | tr -dc \u0026#39;a-zA-Z0-9\u0026#39; | fold -w 20 | head -n 1 | tr \u0026#39;[:upper:]\u0026#39; \u0026#39;[:lower:]\u0026#39;) echo \u0026#34;No agent token given, generated agent token: ${AGENT_TOKEN}\u0026#34; fi # Check if name is given or create random string if [ -z $NAME ]; then NAME=$(cat /dev/urandom | base64 | tr -dc \u0026#39;a-zA-Z0-9\u0026#39; | fold -w 6 | head -n 1 | tr \u0026#39;[:upper:]\u0026#39; \u0026#39;[:lower:]\u0026#39;) echo \u0026#34;No name given, generated name: ${NAME}\u0026#34; fi echo \u0026#34;Creating cluster ${NAME} with $(( $SERVER_COUNT_MACHINE + 1 )) server(s) and ${AGENT_COUNT_MACHINE} agent(s)\u0026#34; # Prepare cloud-init # Cloud init template read -r -d \u0026#39;\u0026#39; SERVER_INIT_CLOUDINIT_TEMPLATE \u0026lt;\u0026lt; EOM #cloud-config runcmd: - \u0026#39;\\curl -sfL http://rancher-mirror.cnrancher.com/k3s/k3s-install.sh | INSTALL_K3S_MIRROR=cn INSTALL_K3S_CHANNEL=$CHANNEL K3S_TOKEN=$SERVER_TOKEN K3S_AGENT_TOKEN=$AGENT_TOKEN INSTALL_K3S_EXEC=\u0026#34;server --cluster-init\u0026#34; K3S_KUBECONFIG_MODE=644 sh -\u0026#39; EOM echo \u0026#34;$SERVER_INIT_CLOUDINIT_TEMPLATE\u0026#34; \u0026gt; \u0026#34;${NAME}-init-cloud-init.yaml\u0026#34; echo \u0026#34;Cloud-init is created at ${NAME}-init-cloud-init.yaml\u0026#34; echo \u0026#34;Creating initial server instance: k3s-server-${NAME}\u0026#34; echo \u0026#34;Running $MULTIPASSCMD launch --cpus $SERVER_CPU_MACHINE --disk $SERVER_DISK_MACHINE --mem $SERVER_MEMORY_MACHINE $IMAGE --name k3s-server-$NAME --cloud-init ${NAME}-init-cloud-init.yaml\u0026#34; $MULTIPASSCMD launch --cpus $SERVER_CPU_MACHINE --disk $SERVER_DISK_MACHINE --mem $SERVER_MEMORY_MACHINE $IMAGE --name k3s-server-$NAME --cloud-init \u0026#34;${NAME}-init-cloud-init.yaml\u0026#34; if [ $? -ne 0 ]; then echo \u0026#34;There was an error launching the instance\u0026#34; exit 1 fi echo \u0026#34;Checking for Node being Ready on k3s-server-${NAME}\u0026#34; $MULTIPASSCMD exec k3s-server-$NAME -- /bin/bash -c \u0026#39;while [[ $(sudo k3s kubectl get nodes --no-headers 2\u0026gt;/dev/null | grep -c -v \u0026#34;NotReady\u0026#34;) -eq 0 ]]; do sleep 2; done\u0026#39; echo \u0026#34;Node is Ready on k3s-server-${NAME}\u0026#34; # Retrieve info to join agent to cluster SERVER_IP=$($MULTIPASSCMD info k3s-server-$NAME | grep IPv4 | awk \u0026#39;{ print $2 }\u0026#39;) URL=\u0026#34;https://$(echo $SERVER_IP | sed -e \u0026#39;s/[[:space:]]//g\u0026#39;):6443\u0026#34; # Create additional servers if [ \u0026#34;${SERVER_COUNT_MACHINE}\u0026#34; -gt 0 ]; then read -r -d \u0026#39;\u0026#39; SERVER_CLOUDINIT_TEMPLATE \u0026lt;\u0026lt; EOM #cloud-config runcmd: - \u0026#39;\\curl -sfL http://rancher-mirror.cnrancher.com/k3s/k3s-install.sh | INSTALL_K3S_MIRROR=cn INSTALL_K3S_CHANNEL=$CHANNEL K3S_TOKEN=$SERVER_TOKEN K3S_AGENT_TOKEN=$AGENT_TOKEN INSTALL_K3S_EXEC=\u0026#34;server --server $URL\u0026#34; K3S_KUBECONFIG_MODE=644 sh -\u0026#39; EOM echo \u0026#34;$SERVER_CLOUDINIT_TEMPLATE\u0026#34; \u0026gt; \u0026#34;${NAME}-cloud-init.yaml\u0026#34; echo \u0026#34;Creating ${SERVER_COUNT_MACHINE} additional server instances\u0026#34; for i in $(eval echo \u0026#34;{1..$SERVER_COUNT_MACHINE}\u0026#34;); do echo \u0026#34;Running $MULTIPASSCMD launch --cpus $SERVER_CPU_MACHINE --disk $SERVER_DISK_MACHINE --mem $SERVER_MEMORY_MACHINE $IMAGE --name k3s-server-$NAME-$i --cloud-init ${NAME}-cloud-init.yaml\u0026#34; $MULTIPASSCMD launch --cpus $SERVER_CPU_MACHINE --disk $SERVER_DISK_MACHINE --mem $SERVER_MEMORY_MACHINE $IMAGE --name k3s-server-$NAME-$i --cloud-init \u0026#34;${NAME}-cloud-init.yaml\u0026#34; if [ $? -ne 0 ]; then echo \u0026#34;There was an error launching the instance\u0026#34; exit 1 fi echo \u0026#34;Checking for Node being Ready on k3s-server-${NAME}\u0026#34; $MULTIPASSCMD exec k3s-server-$NAME-$i -- /bin/bash -c \u0026#39;while [[ $(sudo k3s kubectl get nodes --no-headers 2\u0026gt;/dev/null | grep -c -v \u0026#34;NotReady\u0026#34;) -eq 0 ]]; do sleep 2; done\u0026#39; echo \u0026#34;Node is Ready on k3s-server-${NAME}-${i}\u0026#34; done fi if [ \u0026#34;${AGENT_COUNT_MACHINE}\u0026#34; -gt 0 ]; then # Prepare agent cloud-init # Cloud init template read -r -d \u0026#39;\u0026#39; AGENT_CLOUDINIT_TEMPLATE \u0026lt;\u0026lt; EOM #cloud-config runcmd: - \u0026#39;\\curl -sfL http://rancher-mirror.cnrancher.com/k3s/k3s-install.sh | INSTALL_K3S_MIRROR=cn INSTALL_K3S_CHANNEL=$CHANNEL K3S_TOKEN=$AGENT_TOKEN K3S_URL=$URL sh -\u0026#39; EOM echo \u0026#34;$AGENT_CLOUDINIT_TEMPLATE\u0026#34; \u0026gt; \u0026#34;${NAME}-agent-cloud-init.yaml\u0026#34; echo \u0026#34;Cloud-init is created at ${NAME}-agent-cloud-init.yaml\u0026#34; for i in $(eval echo \u0026#34;{1..$AGENT_COUNT_MACHINE}\u0026#34;); do echo \u0026#34;Running $MULTIPASSCMD launch --cpus $AGENT_CPU_MACHINE --disk $AGENT_DISK_MACHINE --mem $AGENT_MEMORY_MACHINE $IMAGE --name k3s-agent-$NAME-$i --cloud-init ${NAME}-agent-cloud-init.yaml\u0026#34; $MULTIPASSCMD launch --cpus $AGENT_CPU_MACHINE --disk $AGENT_DISK_MACHINE --mem $AGENT_MEMORY_MACHINE $IMAGE --name k3s-agent-$NAME-$i --cloud-init \u0026#34;${NAME}-agent-cloud-init.yaml\u0026#34; if [ $? -ne 0 ]; then echo \u0026#34;There was an error launching the instance\u0026#34; exit 1 fi echo \u0026#34;Checking for Node k3s-agent-$NAME-$i being registered\u0026#34; $MULTIPASSCMD exec k3s-server-$NAME -- bash -c \u0026#34;until sudo k3s kubectl get nodes --no-headers | grep -c k3s-agent-$NAME-$i \u0026gt;/dev/null; do sleep 2; done\u0026#34; echo \u0026#34;Checking for Node k3s-agent-$NAME-$i being Ready\u0026#34; $MULTIPASSCMD exec k3s-server-$NAME -- bash -c \u0026#34;until sudo k3s kubectl get nodes --no-headers | grep k3s-agent-$NAME-$i | grep -c -v NotReady \u0026gt;/dev/null; do sleep 2; done\u0026#34; echo \u0026#34;Node k3s-agent-$NAME-$i is Ready on k3s-server-${NAME}\u0026#34; done fi $MULTIPASSCMD copy-files k3s-server-$NAME:/etc/rancher/k3s/k3s.yaml $NAME-kubeconfig-orig.yaml sed \u0026#34;/^[[:space:]]*server:/ s_:.*_: \\\u0026#34;https://$(echo $SERVER_IP | sed -e \u0026#39;s/[[:space:]]//g\u0026#39;):6443\\\u0026#34;_\u0026#34; $NAME-kubeconfig-orig.yaml \u0026gt; $NAME-kubeconfig.yaml echo \u0026#34;k3s setup finished\u0026#34; $MULTIPASSCMD exec k3s-server-$NAME -- sudo k3s kubectl get nodes echo \u0026#34;You can now use the following command to connect to your cluster\u0026#34; echo \u0026#34;$MULTIPASSCMD exec k3s-server-${NAME} -- sudo k3s kubectl get nodes\u0026#34; echo \u0026#34;Or use kubectl directly\u0026#34; echo \u0026#34;kubectl --kubeconfig ${NAME}-kubeconfig.yaml get nodes\u0026#34; 1.4 k9s K9s 提供了一个与 K8s 集群交互的终端 UI，用于简化导航、观察以及管理应用程序。K9s 会持续监控 K8s 的变化，并提供后续命令与所观察到的资源进行交互。可以利用如下GUI管理k8s\n1.5 一些问题 brew无法安装cask，超时之类，可以使用中科大的brew源； 在启用某些VPN软件时，multipass无法拉取镜像，导致无法创建Ubuntu实例或者无法安装k3s，只能关闭VPN软件； k3s启动失败，一般需要使用国内镜像源。 2. 安装与测试 步骤如下：\nBrew安装multipass、k9s和kubectl-cli； 创建k3s-launch.sh，并复制粘贴上面的脚本内容，需要自行修改以适配自己的环境； 运行bash k3s-launch.sh，等待集群部署，脚本执行成功后可以看到multipass多了3个实例，不带数字的是master节点，其他是slave节点，而且目录下多了几个文件； ~/Projects/k3s ❯ ll 21:13:40 total 56 -rw-r--r-- 1 tao staff 216B Jan 2 14:05 demo-cluster-agent-cloud-init.yaml -rw-r--r-- 1 tao staff 283B Jan 2 14:04 demo-cluster-init-cloud-init.yaml -rw-r--r-- 1 tao staff 2.9K Jan 2 14:07 demo-cluster-kubeconfig-orig.yaml -rw-r--r-- 1 tao staff 2.9K Jan 2 14:07 demo-cluster-kubeconfig.yaml -rw-r--r--@ 1 tao staff 7.0K Jan 2 14:04 k3s-launch.sh 创建一个deploy-nginx.yaml，内容如下： apiVersion: apps/v1 kind: Deployment metadata: name: nginx namespace: dev spec: replicas: 3 selector: matchLabels: run: nginx template: metadata: labels: run: nginx spec: containers: - image: nginx:1.17.1 name: nginx ports: - containerPort: 80 protocol: TCP 使用kubectl控制集群，运行如下命令 # get nodes查看节点是否存活 kubectl --kubeconfig demo-cluster-kubeconfig.yaml get nodes NAME STATUS ROLES AGE VERSION k3s-agent-demo-cluster-1 Ready \u0026lt;none\u0026gt; 7h10m v1.22.5+k3s1 k3s-agent-demo-cluster-2 Ready \u0026lt;none\u0026gt; 7h9m v1.22.5+k3s1 k3s-server-demo-cluster Ready control-plane,etcd,master 7h11m v1.22.5+k3s1 # create namespace dev创建dev命名空间 kubectl --kubeconfig demo-cluster-kubeconfig.yaml create namespace dev namespace/dev created # 创建测试pod kubectl --kubeconfig demo-cluster-kubeconfig.yaml create -f deploy-nginx.yaml deployment.apps/nginx created # 查看pod状态 kubectl --kubeconfig demo-cluster-kubeconfig.yaml get pods -n dev NAME READY STATUS RESTARTS AGE nginx-66ffc897cf-55b6d 1/1 Running 0 53s nginx-66ffc897cf-d5r29 1/1 Running 0 53s nginx-66ffc897cf-vfpkg 1/1 Running 0 53s # 创建暴露给外部的Service kubectl --kubeconfig demo-cluster-kubeconfig.yaml expose deploy nginx --name=svc-nginx --type=NodePort --port=80 --target-port=80 -n dev service/svc-nginx exposed # 查看Service状态和端口号映射 kubectl --kubeconfig demo-cluster-kubeconfig.yaml get svc svc-nginx -n dev -o wide NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE SELECTOR svc-nginx NodePort 10.43.227.135 \u0026lt;none\u0026gt; 80:30355/TCP 25s run=nginx # 查看master节点ip multipass list Name State IPv4 Image k3s-agent-demo-cluster-1 Running 192.168.64.16 Ubuntu 20.04 LTS 10.42.1.0 10.42.1.1 k3s-agent-demo-cluster-2 Running 192.168.64.17 Ubuntu 20.04 LTS 10.42.2.0 10.42.2.1 k3s-server-demo-cluster Running 192.168.64.15 Ubuntu 20.04 LTS 10.42.0.0 10.42.0.1 # 访问 192.168.64.15:30355，能够输出nginx信息 curl 192.168.64.15:30355 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Welcome to nginx!\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; body { width: 35em; margin: 0 auto; font-family: Tahoma, Verdana, Arial, sans-serif; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Welcome to nginx!\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;If you see this page, the nginx web server is successfully installed and working. Further configuration is required.\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;For online documentation and support please refer to \u0026lt;a href=\u0026#34;http://nginx.org/\u0026#34;\u0026gt;nginx.org\u0026lt;/a\u0026gt;.\u0026lt;br/\u0026gt; Commercial support is available at \u0026lt;a href=\u0026#34;http://nginx.com/\u0026#34;\u0026gt;nginx.com\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;\u0026lt;em\u0026gt;Thank you for using nginx.\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 利用k9s查看k8s集群状态，详细玩法可以去看k9s官网 k9s --kubeconfig demo-cluster-kubeconfig.yaml -n dev pod状态\nservice状态\ndeploy状态\n参考 k3s cluster on multipass instances K3s: Lightweight Kubernetes Ubuntu VMs on demand for any workstation K3s 安装选项介绍 k9s Kubernetes CLI To Manage Your Clusters In Style! ","permalink":"https://zhoutao822.github.io/posts/k8s-with-mac/","summary":"Run k8s on Mac with k3s and multipass","title":"K8s with Mac"},{"content":"以Ubuntu20.04为例，使用android/ndk-samples项目进行测试\n1. java 首先需要配置Java环境，如果是使用docker可以选一个自带java环境的docker镜像就行，java版本一般选java8。如果使用最新的java17，后面编译会不通过。\nUbuntu下安装openjdk命令如下，通过apt安装的jdk会被放在/usr/lib/jvm目录下，名称为java-1.8.0-openjdk-amd64：\nsudo apt install openjdk-8-jdk 如果之前安装过其他版本的jdk，那么java不会自动切换到新安装的这个版本，需要执行sudo update-alternatives --config java\nsudo update-alternatives --config java There are 4 choices for the alternative java (providing /usr/bin/java). Selection Path Priority Status ------------------------------------------------------------ * 0 /usr/lib/jvm/zulu-17-amd64/bin/java 2173000 auto mode 1 /usr/lib/jvm/java-8-openjdk-amd64/jre/bin/java 1081 manual mode 2 /usr/lib/jvm/zulu-17-amd64/bin/java 2173000 manual mode Press \u0026lt;enter\u0026gt; to keep the current choice[*], or type selection number: 这里可以看到系统之安装了多个版本的jdk，默认会使用优先级最大的那个版本，除非我们输入编号手动指定，一般来说新安装的jdk并不会出现在这个列表里，需要手动加入，执行以下命令\nsudo update-alternatives --install /usr/bin/java java /usr/lib/jvm/java-1.8.0-openjdk-amd64/bin/java 300 sudo update-alternatives --install /usr/bin/javac javac /usr/lib/jvm/java-1.8.0-openjdk-amd64/bin/javac 300 # 同理javac执行sudo update-alternatives --config javac sudo update-alternatives --config java There are 3 choices for the alternative java (providing /usr/bin/java). Selection Path Priority Status ------------------------------------------------------------ * 0 /usr/lib/jvm/zulu-17-amd64/bin/java 2173000 auto mode 1 /usr/lib/jvm/java-1.8.0-openjdk-amd64/bin/java 300 manual mode 2 /usr/lib/jvm/java-8-openjdk-amd64/jre/bin/java 1081 manual mode 3 /usr/lib/jvm/zulu-17-amd64/bin/java 2173000 manual mode Press \u0026lt;enter\u0026gt; to keep the current choice[*], or type selection number: 切换完成后运行java -version来确认是否成功。\n2. sdkmanager 2.1 安装与配置 Android Studio官网给出了sdkmanager命令行工具的下载地址，截至2022.01.04，可以通过https://dl.google.com/android/repository/commandlinetools-linux-7583922_latest.zip链接下载。执行以下命令\nwget https://dl.google.com/android/repository/commandlinetools-linux-7583922_latest.zip -O cmd.zip unzip cmd.zip -d android_sdk cd android_sdk mv cmdline-tools latest; mkdir cmdline-tools; mv latest cmdline-tools 最终文件路径如下\n~/android_sdk/cmdline-tools/latest \u0026gt; ls bin lib NOTICE.txt source.properties 这里有一个很神奇的地方就是需要把解压后的cmdline-tools下的所有文件移动到cmdline-tools/latest目录下，不然后续无法使用sdkmanager。然后输出一下sdk的路径\n~/android_sdk ❯ pwd /root/android_sdk 最后需要设置环境变量以及ANDROID_SDK_ROOT\nexport PATH=$PATH:/root/android_sdk/cmdline-tools/latest/bin export ANDROID_SDK_ROOT=/root/android_sdk Android Gradle 插件 4.2.0 及更高版本可在您首次构建项目时自动安装所需的 NDK 和 CMake，前提是已预先接受 NDK 和 CMake 的许可。执行下面这个命令配置licenses，后续sdkmanager才能自动下载需要的工具\nyes | sdkmanager --licenses 使用android/ndk-samples项目进行测试，clone后进入到hello-jni目录中，直接执行以下命令，会自动安装对应的gradle、ndk、cmake、platforms、build-tools之类的编译工具\n./gradlew build 2.2 其他问题 在使用android/ndk-samples项目进行测试时发现，某些项目指定了cmake的版本为3.18.1这是截至目前为止sdkmanager支持的最新版本的cmake。但是这里不能通过sudo apt install cmake或者cmake官网安装，因为这些版本的cmake中缺少了ninja工具，也是会导致测试项目无法编译通过，所以需要执行以下命令安装sdkmanager提供的cmake，并且还需要将其添加到环境变量中\nsdkmanager \u0026#34;cmake;3.18.1\u0026#34; 最终环境变量如下\nexport PATH=$PATH:/root/android_sdk/cmdline-tools/latest/bin export PATH=$PATH:/root/android_sdk/cmake/3.18.1/bin export ANDROID_SDK_ROOT=/root/android_sdk 3. dockerfile 在没有设置代理的情况下这个dockerfile的环境可以编译通过android/ndk-samples项目所有工程，如果需要设置代理，需要考虑sdkmanager的代理以及gradle中的仓库代理，这里不做过多展开，仅给出部分sdkmanager参数\n选项 说明 --sdk_root=path 使用指定的 SDK 路径而不是包含此工具的 SDK --channel=channel_id 纳入从 channel_0 到 channel_id（含）的所有渠道中的软件包。可用的渠道包括：0（稳定版）、1（Beta 版）、2（开发版）和 3（Canary 版）。 --include_obsolete 在列出或更新软件包时纳入已过时的软件包。 仅适用于 --list 和 --update。 --no_https 强制所有连接使用 HTTP 而不是 HTTPS。 --verbose 详细输出模式。该模式会输出错误、警告和参考性消息。 --proxy={http / socks} 通过给定类型的代理建立连接：用 http 指定一个高层级协议（如 HTTP 或 FTP）的代理，或用 socks 指定一个 SOCKS（V4 或 V5）代理。 --proxy_host={IP_address / DNS_address} 要使用的代理的 IP 或 DNS 地址。 --proxy_port=port_number 要连接到的代理端口号。 ARG DEBIAN_FRONTEND=noninteractive避免apt update/install时弹出选择框\nFROM ubuntu ARG DOWNLOAD_URL=https://dl.google.com/android/repository/commandlinetools-linux-7583922_latest.zip ARG SDK_PATH=/root/android_sdk ARG CMAKE_VERSION=3.18.1 ARG DEBIAN_FRONTEND=noninteractive ENV PATH=$PATH:$SDK_PATH/cmdline-tools/latest/bin ENV PATH=$PATH:$SDK_PATH/cmake/$CMAKE_VERSION/bin ENV ANDROID_SDK_ROOT=$SDK_PATH RUN apt update -y \\ \u0026amp;\u0026amp; apt install -y openjdk-8-jdk unzip wget git \\ \u0026amp;\u0026amp; wget $DOWNLOAD_URL -O cmd.zip \\ \u0026amp;\u0026amp; unzip cmd.zip -d $SDK_PATH \\ \u0026amp;\u0026amp; rm cmd.zip \\ \u0026amp;\u0026amp; cd $SDK_PATH \\ \u0026amp;\u0026amp; mv cmdline-tools latest; mkdir cmdline-tools; mv latest cmdline-tools \\ \u0026amp;\u0026amp; yes | sdkmanager --licenses \\ \u0026amp;\u0026amp; sdkmanager \u0026#34;cmake;$CMAKE_VERSION\u0026#34; 参考 sdkmanager Command line tools only android/ndk-samples ubuntu下优雅的切换JDK版本 ","permalink":"https://zhoutao822.github.io/posts/android-build-commandline/","summary":"Jenkins上没有Android Studio，只能通过命令行工具编译Android项目","title":"Build Android App with Commandline"},{"content":"1. Favicon Generator 首先为网站添加一个Icon，这里直接使用这个网站Favicon Generator. For real.，上传任意一张喜欢的图片即可生成各种平台需要的favicon。点击下载，将所有图片资源保存在static目录下\n2. PaperMod Theme Config 2.1 Favicon 在上一步保存了整个网站的Icon资源，接下来可以在config.yaml文件中配置favicon\nparams: assets: # disableHLJS: true # to disable highlight.js # disableFingerprinting: true favicon: /favicon.ico favicon16x16: /favicon-16x16.png favicon32x32: /favicon-32x32.png apple_touch_icon: /apple-touch-icon.png safari_pinned_tab: /favicon.ico label: text: \u0026#34;Home\u0026#34; icon: /apple-touch-icon.png iconHeight: 35 2.2 Taxonomies Taxonomies用于给所有博客按标签归档，默认支持三种categories、tags、series，需要在config.yaml中声明：\ntaxonomies: category: categories tag: tags series: series 只需要在markdown中声明即可自动归档\n--- title: \u0026#34;Hugo On Mac\u0026#34; date: 2021-12-12T11:18:58+08:00 tags: [\u0026#34;hugo\u0026#34;, \u0026#34;github pages\u0026#34;, \u0026#34;typora\u0026#34;, \u0026#34;picgo\u0026#34;, \u0026#34;mathjax\u0026#34;, \u0026#34;utteranc\u0026#34;] categories: [\u0026#34;tools\u0026#34;] series: [\u0026#34;hugo on mac\u0026#34;] summary: \u0026#34;Hugo + Github Pages + Typora搭建Markdown博客\u0026#34; draft: false --- 开启后可以在将菜单选项展示到页面顶部，weight决定菜单顺序：\nmenu: main: - name: Archive url: archives/ weight: 5 - name: Tags url: tags/ weight: 10 - name: Categories url: categories/ weight: 15 - name: Series url: series/ weight: 20 - name: Search url: search/ weight: 25 2.3 Search \u0026amp;\u0026amp; Archive Search也是PaperMod主题支持的，首先添加文件content/search.md\n--- title: \u0026#34;Search\u0026#34; # in any language you want layout: \u0026#34;search\u0026#34; # is necessary url: \u0026#34;/search/\u0026#34; # description: \u0026#34;Description for Search\u0026#34; summary: \u0026#34;search\u0026#34; --- 然后修改config.yaml\noutputs: home: - HTML - RSS - JSON # is necessary 还有一些搜索相关参数保持默认即可\nparams: fuseOpts: isCaseSensitive: false shouldSort: true location: 0 distance: 1000 threshold: 0.4 minMatchCharLength: 0 keys: [\u0026#34;title\u0026#34;, \u0026#34;permalink\u0026#34;, \u0026#34;summary\u0026#34;, \u0026#34;content\u0026#34;] Archive的支持只需要添加文件content/archives.md\n--- title: \u0026#34;Archive\u0026#34; layout: \u0026#34;archives\u0026#34; url: \u0026#34;/archives/\u0026#34; summary: archives --- 最终效果如下：\n2.4 Archetypes Hugo支持默认模板，当执行hugo new blog.md时使用模板生成blog.md，可以在创建markdown时自动添加部分属性，修改archetypes/default.md\n--- title: \u0026#34;{{ replace .Name \u0026#34;-\u0026#34; \u0026#34; \u0026#34; | title }}\u0026#34; date: {{ .Date }} tags: [\u0026#34;\u0026#34;] categories: [\u0026#34;\u0026#34;] series: [\u0026#34;\u0026#34;] summary: \u0026#34;Summary todo\u0026#34; draft: false editPost: URL: \u0026#34;https://github.com/Zhoutao822/zhoutao822.github.io/tree/main/content/\u0026#34; Text: \u0026#34;Suggest Changes\u0026#34; appendFilePath: true --- 2.5 其他设置 baseURL: \u0026#39;https://zhoutao822.github.io/\u0026#39; languageCode: en-us title: Tao\u0026#39;s Notes theme: PaperMod paginate: 5 enableRobotsTXT: true buildDrafts: false buildFuture: false buildExpired: false googleAnalytics: UA-123-45 minify: disableXML: true minifyOutput: true params: env: production # to enable google analytics, opengraph, twitter-cards and schema. title: Tao\u0026#39;s Notes description: \u0026#34;Tao\u0026#39;s learning notes\u0026#34; keywords: [Blog, Portfolio, PaperMod] author: Me images: [\u0026#34;\u0026lt;link or path of image for opengraph, twitter-cards\u0026gt;\u0026#34;] DateFormat: \u0026#34;January 2, 2006\u0026#34; defaultTheme: dark # dark, light, auto disableThemeToggle: true ShowReadingTime: true ShowShareButtons: false ShowPostNavLinks: true ShowBreadCrumbs: true ShowCodeCopyButtons: true disableSpecial1stPost: false disableScrollToTop: false hidemeta: false hideSummary: false showtoc: true tocopen: false comments: true utteranc: enable: true repo: \u0026#34;zhoutao822/zhoutao822.github.io\u0026#34; issueTerm: \u0026#34;title\u0026#34; theme: \u0026#34;github-dark\u0026#34; assets: # disableHLJS: true # to disable highlight.js # disableFingerprinting: true favicon: /favicon.ico favicon16x16: /favicon-16x16.png favicon32x32: /favicon-32x32.png apple_touch_icon: /apple-touch-icon.png safari_pinned_tab: /favicon.ico label: text: \u0026#34;Home\u0026#34; icon: /apple-touch-icon.png iconHeight: 35 # profile-mode profileMode: enabled: false # needs to be explicitly set title: ExampleSite subtitle: \u0026#34;This is subtitle\u0026#34; imageUrl: \u0026#34;\u0026lt;img location\u0026gt;\u0026#34; imageWidth: 120 imageHeight: 120 imageTitle: my image buttons: - name: Posts url: posts - name: Tags url: tags # home-info mode homeInfoParams: Title: \u0026#34;Hi there \\U0001F44B\u0026#34; Content: Welcome to my blog socialIcons: - name: github url: \u0026#34;https://github.com/Zhoutao822/\u0026#34; analytics: google: SiteVerificationTag: \u0026#34;Tao\u0026#34; bing: SiteVerificationTag: \u0026#34;Tao\u0026#34; yandex: SiteVerificationTag: \u0026#34;Tao\u0026#34; cover: hidden: true # hide everywhere but not in structured data hiddenInList: true # hide on list pages and home hiddenInSingle: true # hide on single page editPost: URL: \u0026#34;https://github.com/Zhoutao822/zhoutao822.github.io/tree/main/content\u0026#34; Text: \u0026#34;Suggest Changes\u0026#34; # edit text appendFilePath: true # to append file path to Edit link fuseOpts: isCaseSensitive: false shouldSort: true location: 0 distance: 1000 threshold: 0.4 minMatchCharLength: 0 keys: [\u0026#34;title\u0026#34;, \u0026#34;permalink\u0026#34;, \u0026#34;summary\u0026#34;, \u0026#34;content\u0026#34;] outputs: home: - HTML - RSS - JSON taxonomies: category: categories tag: tags series: series menu: main: - name: Archive url: archives/ weight: 5 - name: Tags url: tags/ weight: 10 - name: Categories url: categories/ weight: 15 - name: Series url: series/ weight: 20 - name: Search url: search/ weight: 25 3. Mathjax Defects 3.1 mathjax.html 首先需要修改layouts/partials/mathjax.html\n{{ if .Params.mathjax }} \u0026lt;script\u0026gt; MathJax = { tex: { inlineMath: [[\u0026#34;$\u0026#34;, \u0026#34;$\u0026#34;]], processEscapes: true, processEnvironments: true }, displayMath: [ [\u0026#34;$$\u0026#34;, \u0026#34;$$\u0026#34;], [\u0026#34;\\[\u0026#34;, \u0026#34;\\]\u0026#34;], ], svg: { fontCache: \u0026#34;global\u0026#34;, }, }; \u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;https://polyfill.io/v3/polyfill.min.js?features=es6\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script id=\u0026#34;MathJax-script\u0026#34; async src=\u0026#34;https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; {{ end }} 需要添加processEscapes: true，否则行内数学公式无法正常显示。\n3.2 issues 属性$a_k = \\underset{a \\in A}{\\arg \\max Gain(D, a)}$。 $$ Gain\\_ratio(D, a) = \\frac{Gain(D,a)}{IV(a)} \\\\ IV(a) = -\\sum^V_{v=1}\\frac{|D^v|}{|D|} \\log_2\\frac{|D^v|}{|D|} $$ $$ Gini(D) = \\sum^{|\\mathbb{Y}|}_{k=1}\\sum_{k\u0026#39; \\neq k}p_kp_{k\u0026#39;} \\\\ = 1- \\sum^{|\\mathbb{Y}|}_{k=1}p_k^2 $$ 就算修改了mathjax.html或者使用katex，这里无法避免转义字符的问题，期望的显示效果如上，但是实际效果如下\n第一点就是数学公式中添加\\\\应该实现换行，这里换行失效，第二点就是\\_转义字符期望显示_，但是变成下角标（Gain\\_ratio），第三点就是某些公式可以在Typora中正常渲染，但是在Hugo中无法解析，推测也是跟Hugo渲染相关的问题，这个问题在Hexo中也有（结合MathType和MathJax在Hexo博客中插入数学公式），但是Hexo可以修改其源码来解决这个问题，Hugo不适合修改源码解决。所以最终结论是，在数学公式中不要使用下划线，因为会解析错误，不要使用\\\\实现公式内换行，复杂公式需要检查，当然也可以选择不要在Hugo中使用复杂公式。\n4. PicGo图床 SM.MS图床有资源限制，建议使用gitee或者github作为图床，gitee存在单张图片不能超过2MB的限制，这里就需要使用PicGo的Compress插件picgo-plugin-compress并且使用lubangitee算法，在mac上安装这个插件可能会安装不上，建议翻墙或者通过命令行安装\n# 首先要安装这些库，否则在mac上使用lubangitee压缩算法时会失败 brew install node automake autoconf libtool pkgconfig libpng nasm 然后进入到picgo目录中通过npm安装picgo-plugin-compress插件\ncd ~/Library/Application\\ Support/picgo rm -rf node_modules npm install picgo-plugin-compress --save --registry=https://registry.npm.taobao.org --ignore-scripts npm install --registry=https://registry.npm.taobao.org 如果在使用lubangitee出现以下错误时，说明上面几个库有可能漏掉了，解决方案来自mozjpeg pre-build test failed\n2022-01-06 20:18:41 [PicGo ERROR] ------Error Stack Begin------ Error: spawn /Users/tao/Library/Application Support/picgo/node_modules/mozjpeg/vendor/cjpeg ENOENT at Process.ChildProcess._handle.onexit (internal/child_process.js:264:19) at onErrorNT (internal/child_process.js:456:16) at processTicksAndRejections (internal/process/task_queues.js:84:9) -------Error Stack End------- 参考 Favicon Generator. For real. GitHub + jsDelivr + PicGo + Imagine 打造稳定快速、高效免费图床 结合MathType和MathJax在Hexo博客中插入数学公式 picgo-plugin-compress ","permalink":"https://zhoutao822.github.io/posts/hugo-theme-papermod/","summary":"PaperMod configurations, favicon generator and mathjax issues","title":"Hugo Theme PaperMod"},{"content":"1. Github Pages设置与配置 首先需要创建一个名称为{OwnerName}.github.io的Public仓库，如果仓库名称为其他，那么最终你的Github Pages的域名就不是https://{OwnerName}.github.io了，而是https://{OwnerName}.github.io/{RepoName}，而且如果这里不是Public而是Private的话，需要付费才能将Private仓库作为Github Pages使用。\n然后创建一个新的分支gh-pages，这个用于后续通过Github Action部署Hugo的静态页面，作为Github Pages的主页；也就是说我们的main分支保存整个Hugo博客工程，而gh-pages分支保存自动生成的静态页面。在仓库Setting下设置Github Pages的Source为gh-pages分支，勾选上Enforce HTTPS，最终访问的域名就是https了。\n最后clone一下这个仓库的main分支到本地即可。\n2. Hugo安装与使用 2.1 Hugo Install 直接通过brew install hugo即可，Homebrew如何安装可以参考官网Homebrew。安装完成后执行hugo version，打印结果如下表明安装成功：\n❯ hugo version hugo v0.90.1+extended darwin/arm64 BuildDate=unknown 2.2 Hugo Init 在clone仓库之后，通过命令行进入到这个仓库的目录下执行hugo new site . --force，初始化Hugo工程，日志如下：\n❯ hugo new site . --force Congratulations! Your new Hugo site is created in /Users/tao/Documents/hugo-blog. Just a few more steps and you\u0026#39;re ready to go: 1. Download a theme into the same-named folder. Choose a theme from https://themes.gohugo.io/ or create your own with the \u0026#34;hugo new theme \u0026lt;THEMENAME\u0026gt;\u0026#34; command. 2. Perhaps you want to add some content. You can add single files with \u0026#34;hugo new \u0026lt;SECTIONNAME\u0026gt;/\u0026lt;FILENAME\u0026gt;.\u0026lt;FORMAT\u0026gt;\u0026#34;. 3. Start the built-in live server via \u0026#34;hugo server\u0026#34;. Visit https://gohugo.io/ for quickstart guide and full documentation. 使用--force是为了能在非空目录中创建Hugo工程。\n2.3 Hugo Theme 在Hugo Theme上挑选一个自己喜欢的主题，然后通过git命令添加主题，以PaperMod为例\ngit submodule add https://github.com/adityatelange/hugo-PaperMod.git themes/PaperMod --depth=1 后续需要更新主题则执行\ngit submodule update --remote --merge 如果主题安装成功，则项目目录下会多一个.gitmodules文件，内容为\n❯ cat .gitmodules [submodule \u0026#34;themes/PaperMod\u0026#34;] path = themes/PaperMod url = https://github.com/adityatelange/hugo-PaperMod.git 2.4 Hugo Config 然后修改config文件，默认情况下Hugo创建的是config.toml，这里可以删除这个文件，以config.yaml作为替代，依赖个人习惯决定即可；toml和yaml文件可以通过网站Convert TOML to YAML相互转换。\n修改baseURL为Github Pages的域名，并添加theme字段\n❯ cat config.yaml baseURL: \u0026#39;https://zhoutao822.github.io/\u0026#39; languageCode: en-us title: My New Hugo Site theme: PaperMod 2.4 Hugo Local Test 如果上述步骤都完成了，可以通过hugo new创建一个示例Blog\n❯ hugo new posts/my-first-post.md Content \u0026#34;/Users/tao/Documents/hugo-blog/content/posts/my-first-post.md\u0026#34; created 默认情况下Hugo会生成一些模板数据在Markdown中，比如title之类，这里如果需要把draft改为false。\n--- title: \u0026#34;My First Post\u0026#34; date: 2021-12-12T11:18:58+08:00 draft: true --- ## Hello Hugo! This is the first hugo blog. 最后执行hugo server，在本地部署，访问http://localhost:1313/可以查看效果\n❯ hugo server Start building sites … hugo v0.90.1+extended darwin/arm64 BuildDate=unknown | EN -------------------+----- Pages | 10 Paginator pages | 0 Non-page files | 0 Static files | 0 Processed images | 0 Aliases | 2 Sitemaps | 1 Cleaned | 0 Built in 16 ms Watching for changes in /Users/tao/Documents/hugo-blog/{archetypes,content,data,layouts,static,themes} Watching for config changes in /Users/tao/Documents/hugo-blog/config.yaml Environment: \u0026#34;development\u0026#34; Serving pages from memory Running in Fast Render Mode. For full rebuilds on change: hugo server --disableFastRender Web Server is available at http://localhost:1313/ (bind address 127.0.0.1) Press Ctrl+C to stop PaperMod主题很丰富，需要通过config文件进行配置。\n2.5 Github Action配置 Github Action可以实现Push完成后自动编译并部署，所以需要创建文件.github/workflows/gh-pages.yml，最后将本地工程Push到gihub上即可。\nname: github pages on: push: branches: - main # Set a branch to deploy pull_request: jobs: deploy: runs-on: ubuntu-20.04 steps: - uses: actions/checkout@v2 with: submodules: true # Fetch Hugo themes (true OR recursive) fetch-depth: 0 # Fetch all history for .GitInfo and .Lastmod - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: \u0026#39;latest\u0026#39; # extended: true - name: Build run: hugo --minify - name: Deploy uses: peaceiris/actions-gh-pages@v3 if: github.ref == \u0026#39;refs/heads/main\u0026#39; with: github_token: ${{ secrets.GITHUB_TOKEN }} publish_dir: ./public push成功后可以查看Github Action进度。\n3. Typora与PicGo 3.1 PicGo安装与配置 通过brew install picgo --cask安装PicGo，用于图片上传，这里我使用的是SM.MS图床，注册账号并生成token即可使用，可以把上传时重命名勾选上。\n3.2 Typora安装与配置 通过brew install typora --cask安装Typora，目前1.0版本后是需要付费使用，0.11版本及之前是免费的；安装完Typora之后需要设置插入图片时的操作，比如在插入本地图片时将图片自动通过PicGo上传到SM.MS图床上，那么Markdown文件中就只需要通过Url显示图片了。\n4. 其它配置 4.1 PaperMod主题配置 参考PaperMod Wiki\nbaseURL: \u0026#39;https://zhoutao822.github.io/\u0026#39; languageCode: en-us title: Tao\u0026#39;s Notes theme: PaperMod paginate: 5 enableRobotsTXT: true buildDrafts: false buildFuture: false buildExpired: false googleAnalytics: UA-123-45 minify: disableXML: true minifyOutput: true params: env: production # to enable google analytics, opengraph, twitter-cards and schema. title: Tao\u0026#39;s Notes description: \u0026#34;Tao\u0026#39;s learning notes\u0026#34; keywords: [Blog, Portfolio, PaperMod] author: Me # author: [\u0026#34;Me\u0026#34;, \u0026#34;You\u0026#34;] # multiple authors images: [\u0026#34;\u0026lt;link or path of image for opengraph, twitter-cards\u0026gt;\u0026#34;] DateFormat: \u0026#34;January 2, 2006\u0026#34; defaultTheme: auto # dark, light disableThemeToggle: false ShowReadingTime: true ShowShareButtons: true ShowPostNavLinks: true ShowBreadCrumbs: true ShowCodeCopyButtons: false disableSpecial1stPost: false disableScrollToTop: false comments: false hidemeta: false hideSummary: false showtoc: false tocopen: false assets: # disableHLJS: true # to disable highlight.js # disableFingerprinting: true favicon: \u0026#34;\u0026lt;link / abs url\u0026gt;\u0026#34; favicon16x16: \u0026#34;\u0026lt;link / abs url\u0026gt;\u0026#34; favicon32x32: \u0026#34;\u0026lt;link / abs url\u0026gt;\u0026#34; apple_touch_icon: \u0026#34;\u0026lt;link / abs url\u0026gt;\u0026#34; safari_pinned_tab: \u0026#34;\u0026lt;link / abs url\u0026gt;\u0026#34; label: text: \u0026#34;Home\u0026#34; icon: /apple-touch-icon.png iconHeight: 35 # profile-mode profileMode: enabled: false # needs to be explicitly set title: ExampleSite subtitle: \u0026#34;This is subtitle\u0026#34; imageUrl: \u0026#34;\u0026lt;img location\u0026gt;\u0026#34; imageWidth: 120 imageHeight: 120 imageTitle: my image buttons: - name: Posts url: posts - name: Tags url: tags # home-info mode homeInfoParams: Title: \u0026#34;Hi there \\U0001F44B\u0026#34; Content: Welcome to my blog socialIcons: - name: twitter url: \u0026#34;https://twitter.com/\u0026#34; - name: stackoverflow url: \u0026#34;https://stackoverflow.com\u0026#34; - name: github url: \u0026#34;https://github.com/\u0026#34; analytics: google: SiteVerificationTag: \u0026#34;XYZabc\u0026#34; bing: SiteVerificationTag: \u0026#34;XYZabc\u0026#34; yandex: SiteVerificationTag: \u0026#34;XYZabc\u0026#34; cover: hidden: true # hide everywhere but not in structured data hiddenInList: true # hide on list pages and home hiddenInSingle: true # hide on single page editPost: URL: \u0026#34;https://github.com/zhoutao822.github.io/content\u0026#34; Text: \u0026#34;Suggest Changes\u0026#34; # edit text appendFilePath: true # to append file path to Edit link # for search # https://fusejs.io/api/options.html fuseOpts: isCaseSensitive: false shouldSort: true location: 0 distance: 1000 threshold: 0.4 minMatchCharLength: 0 keys: [\u0026#34;title\u0026#34;, \u0026#34;permalink\u0026#34;, \u0026#34;summary\u0026#34;, \u0026#34;content\u0026#34;] menu: main: - identifier: categories name: categories url: /categories/ weight: 10 - identifier: tags name: tags url: /tags/ weight: 20 - identifier: example name: example.org url: https://example.org weight: 30 # Read: https://github.com/adityatelange/hugo-PaperMod/wiki/FAQs#using-hugos-syntax-highlighter-chroma # pygmentsUseClasses: true # markup: # highlight: # # anchorLineNos: true # codeFences: true # guessSyntax: true # lineNos: true # style: monokai 4.2 MathJax支持 如果直接在Markdown中插入数学公式，在Typora中是可以正常显示，但是部署到Github Pages后是无法解析的，比如\n--- title: \u0026#34;My First Post\u0026#34; date: 2021-12-12T11:18:58+08:00 draft: false --- ## Hello Hugo! MathJax $$ \\cos \u0026lt;\\boldsymbol{x, y}\u0026gt; = \\frac{\\sum x_iy_i}{|\\boldsymbol{x}||\\boldsymbol{y}|} $$ 因此需要借助JS库来实现Markdown中Mathjax的渲染，参考在Hugo中使用MathJax。首先创建一个文件layouts/partials/mathjax.html\n{{ if .Params.math }} \u0026lt;script\u0026gt; MathJax = { tex: { inlineMath: [[\u0026#34;$\u0026#34;, \u0026#34;$\u0026#34;]], }, displayMath: [ [\u0026#34;$$\u0026#34;, \u0026#34;$$\u0026#34;], [\u0026#34;\\[\u0026#34;, \u0026#34;\\]\u0026#34;], ], svg: { fontCache: \u0026#34;global\u0026#34;, }, }; \u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;https://polyfill.io/v3/polyfill.min.js?features=es6\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script id=\u0026#34;MathJax-script\u0026#34; async src=\u0026#34;https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; {{ end }} 然后创建layouts/partials/extend_head.html，内容如下，引入mathjax.html；extend_head.html会被hugo自动加载到项目静态资源head.html中。\n{{- partial \u0026#34;mathjax.html\u0026#34; . }} 由于mathjax.html中使用了.Params.math，所以可以通过在Markdown文件头添加math: true字段实现按需渲染\n--- title: \u0026#34;My First Post\u0026#34; date: 2021-12-12T11:18:58+08:00 draft: false math: true --- 最后效果为\n4.3 utteranc评论系统 博客系统必不可少的就是评论系统，utteranc是一个基于Github的评论系统，它是一个Github App，它会将评论转为issue记录在仓库中，没有额外配置。首先安装\n然后创建一个文件layouts/partials/comments.html\n{{ if .Site.Params.utteranc.enable }} \u0026lt;script src=\u0026#34;https://utteranc.es/client.js\u0026#34; repo=\u0026#34;{{ .Site.Params.utteranc.repo }}\u0026#34; issue-term=\u0026#34;{{ .Site.Params.utteranc.issueTerm }}\u0026#34; theme=\u0026#34;{{ .Site.Params.utteranc.theme }}\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34; async\u0026gt; \u0026lt;/script\u0026gt; {{ end }} 最后修改config.yaml开启comments并且配置utteranc\nparams: comments: true utteranc: enable: true repo: \u0026#34;zhoutao822/zhoutao822.github.io\u0026#34; issueTerm: \u0026#34;title\u0026#34; theme: \u0026#34;github-dark\u0026#34; 可以到仓库的issue中查看到，此条评论被成功记录。\n参考 Hugo: Deploy Static Site using GitHub Actions Host on GitHub Quick Start utteranc hugo-PaperMod 在Hugo中使用MathJax 给hugo博客添加评论功能 ","permalink":"https://zhoutao822.github.io/posts/hugo-on-mac/","summary":"Hugo + Github Pages + Typora搭建Markdown博客","title":"Hugo On Mac"},{"content":"共享元素可以在Activity之间或者Fragment之间实现非常舒适的动画效果，如下图所示，特别是在跳转的界面之间拥有相同的界面元素，比如同一张图片但是大小不同，同一个View但是位置不同。需要注意的是最低api需要为21，即Android LOLLIPOP。\n1. Fragment之间共享元素 首先实现在Fragment之间的共享元素动画，因为Fragment可能比Activity更加常用，这两者实现的代码略有区别，而且在我的测试过程中还发现了部分奇怪的问题。\n1.1 简单使用 首先创建两个Fragment，定义各自布局，关键是两个布局中需要共享的元素需要指定一个属性android:transitionName，可以是任何自定义的字符串，其中Fragment1中的共享元素的transitionName可以与Fragment2中的共享元素不同，但是必须要设置（通过xml或者setTransitionName方法），否则会报错。\n// Fragment1.java public class Fragment1 extends Fragment { private static final String ARG_PARAM1 = \u0026#34;param1\u0026#34;; private static final String ARG_PARAM2 = \u0026#34;param2\u0026#34;; private static final String TAG = Fragment1.class.getSimpleName(); private TextView textView; // Fragment默认生成的实例化方法，参数这里没有用到，无所谓 public static Fragment1 newInstance(String param1, String param2) { Fragment1 fragment = new Fragment1(); Bundle args = new Bundle(); args.putString(ARG_PARAM1, param1); args.putString(ARG_PARAM2, param2); fragment.setArguments(args); return fragment; } @Override public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) { super.onViewCreated(view, savedInstanceState); // 我们仅在Fragment中显示一个TextView textView = view.findViewById(R.id.textView1); textView.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { // 点击跳转到Fragment2，同理参数不重要 Fragment2 destination = Fragment2.newInstance(\u0026#34;1\u0026#34;, \u0026#34;2\u0026#34;); if (Build.VERSION.SDK_INT \u0026gt;= Build.VERSION_CODES.LOLLIPOP) { // 定义共享元素的动画效果 // setSharedElementEnterTransition以及setSharedElementReturnTransition分别设置 // 共享元素的动画效果，在目的地Fragment调用Enter方法，当前Fragment调用Return方法，否则 // 无效，系统提供了一些动画效果，比如move、fade等等，可以直接使用，也可以通过继承 // TransitionSet实现自定义动画效果 destination.setSharedElementEnterTransition(TransitionInflater.from(getContext()).inflateTransition(android.R.transition.move)); setSharedElementReturnTransition(TransitionInflater.from(getContext()).inflateTransition(android.R.transition.move)); // setEnterTransition和setExitTransition设置除了共享元素之外其他View的动画效果 // 一般来说仅需要设置目的地Fragment的Enter效果和当前Fragment的Exit效果，同样系统 // 也提供比如Fade之类的效果 destination.setEnterTransition(new Fade()); setExitTransition(new Fade()); } if (getFragmentManager() != null) { getFragmentManager() .beginTransaction() // 在切换Fragment时调用addSharedElement方法，标记我们的共享元素，参数为共享元素 // 对象以及Fragment2中的共享元素的transitionName，可以写死，需要注意的是，这里传入 // 的transitionName需要与Fragment2中的共享元素相同。以我们的代码为例，只有在两个布 // 局中共享元素transitionName相同时才可以使用ViewCompat.getTransitionName方法获取 .addSharedElement(textView, Objects.requireNonNull(ViewCompat.getTransitionName(textView))) .addToBackStack(TAG) .replace(R.id.container, destination) .commit(); } } }); } @Nullable @Override public View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) { return inflater.inflate(R.layout.layout1, container, false); } } // Fragment2.java Fragment2没有加入任何效果，仅显示我们需要的布局 public class Fragment2 extends Fragment { private static final String ARG_PARAM1 = \u0026#34;param1\u0026#34;; private static final String ARG_PARAM2 = \u0026#34;param2\u0026#34;; public static Fragment2 newInstance(String param1, String param2) { Fragment2 fragment = new Fragment2(); Bundle args = new Bundle(); args.putString(ARG_PARAM1, param1); args.putString(ARG_PARAM2, param2); fragment.setArguments(args); return fragment; } @Nullable @Override public View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) { return inflater.inflate(R.layout.layout2, container, false); } } 对应的两个布局文件，两者的区别仅仅是layout1中TextView有上边距，android:transitionName=\u0026quot;textView\u0026quot;相同（可以不同，因为Fragment1中的transitionName并不重要）\n\u0026lt;!-- layout1.xml --\u0026gt; \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:orientation=\u0026#34;horizontal\u0026#34;\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/textView1\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_marginTop=\u0026#34;200dp\u0026#34; android:text=\u0026#34;qqqqqqqqqqqq\u0026#34; android:textSize=\u0026#34;24sp\u0026#34; android:transitionName=\u0026#34;textView\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; \u0026lt;!-- layout2.xml --\u0026gt; \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:orientation=\u0026#34;horizontal\u0026#34;\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/textView2\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;qqqqqqqqqqqq\u0026#34; android:textSize=\u0026#34;24sp\u0026#34; android:transitionName=\u0026#34;textView\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; 效果如下\n当然我们实际应用中不会使用如此简单的布局，此时我仅仅修改layout2，增加一个ImageView，那么就会出现一个奇怪的Bug现象\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:orientation=\u0026#34;horizontal\u0026#34;\u0026gt; \u0026lt;LinearLayout android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:orientation=\u0026#34;horizontal\u0026#34;\u0026gt; \u0026lt;ImageView android:layout_width=\u0026#34;40dp\u0026#34; android:layout_height=\u0026#34;40dp\u0026#34; android:background=\u0026#34;@color/colorPrimary\u0026#34; android:src=\u0026#34;@drawable/ic_launcher_foreground\u0026#34; /\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/textView2\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;qqqqqqqqqqqq\u0026#34; android:textSize=\u0026#34;24sp\u0026#34; android:transitionName=\u0026#34;textView\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; \u0026lt;/LinearLayout\u0026gt; 如下图所示，从Fragment1跳转到Fragment2时，TextView并没有按照轨迹移动，而实突然出现在顶部，但是返回时TextView按照轨迹移动，而我仅仅只是增加了一点布局。\n更加奇怪的是如果上述布局layout2中，设置第二层LinearLayout的android:layout_marginTop=\u0026quot;1dp\u0026quot;，那么又可以正常按照轨迹移动了，这里就不截图了。也就是说如果在实际应用过程中出现这样的显示效果问题，可以通过设置layout_marginTop来避免，但是可能会有1dp的显示问题。\n1.2 RecyclerView以及图片缩放效果 具体可以参考FragmentTransitionSample，其中还包括自定义TransitionSet的实现。需要注意的是，在RecyclerView中添加transitionName的方式\n// 这里对应了上面说到的问题，Fragment1中的transitionName不重要，仅仅需要让它们的transitionName唯一即可， // 否则会出现显示其他图片的异常 ViewCompat.setTransitionName(viewHolder.image, position + \u0026#34;_image\u0026#34;); getActivity().getSupportFragmentManager() .beginTransaction() // 只要最终addSharedElement方法添加的transitionName与Fragment2相同即可 .addSharedElement(holder.image, \u0026#34;kittenImage\u0026#34;) .replace(R.id.container, kittenDetails) .addToBackStack(null) .commit(); 2. Activity之间共享元素 从Fragment提供的方法可知，Fragment之间共享元素仅能实现一个View的动画，如果在一个界面中需要对多个View实现动画就只能在Activity中实现了。\n2.1 简单使用 首先看看之前在Fragment中存在的问题是否会同样出现在Activity中。与Fragment不同的是，在Activity中启用共享元素需要提前配置一下Theme\n\u0026lt;style name=\u0026#34;AppTheme\u0026#34; parent=\u0026#34;Theme.AppCompat.Light.NoActionBar\u0026#34;\u0026gt; \u0026lt;!-- Customize your theme here. --\u0026gt; \u0026lt;item name=\u0026#34;colorPrimary\u0026#34;\u0026gt;@color/colorPrimary\u0026lt;/item\u0026gt; \u0026lt;item name=\u0026#34;colorPrimaryDark\u0026#34;\u0026gt;@color/colorPrimaryDark\u0026lt;/item\u0026gt; \u0026lt;item name=\u0026#34;colorAccent\u0026#34;\u0026gt;@color/colorAccent\u0026lt;/item\u0026gt; \u0026lt;!-- windowContentTransitions也可以通过getWindow().requestFeature(Window.FEATURE_CONTENT_TRANSITIONS)动态控制 --\u0026gt; \u0026lt;item name=\u0026#34;android:windowContentTransitions\u0026#34;\u0026gt;true\u0026lt;/item\u0026gt; \u0026lt;!-- 也可以通过getWindow().setExitTransition(new Fade())动态控制 --\u0026gt; \u0026lt;!-- specify enter and exit transitions --\u0026gt; \u0026lt;item name=\u0026#34;android:windowEnterTransition\u0026#34;\u0026gt;@android:transition/fade\u0026lt;/item\u0026gt; \u0026lt;item name=\u0026#34;android:windowExitTransition\u0026#34;\u0026gt;@android:transition/fade\u0026lt;/item\u0026gt; \u0026lt;!-- 也可以通过getWindow().setSharedElementEnterTransition()动态控制 --\u0026gt; \u0026lt;!-- specify shared element transitions --\u0026gt; \u0026lt;item name=\u0026#34;android:windowSharedElementEnterTransition\u0026#34;\u0026gt; @android:transition/move \u0026lt;/item\u0026gt; \u0026lt;item name=\u0026#34;android:windowSharedElementExitTransition\u0026#34;\u0026gt; @android:transition/move \u0026lt;/item\u0026gt; \u0026lt;/style\u0026gt; 在Theme中控制和通过代码动态控制的区别是Theme是全局的设置，后续如果在代码中没有显示控制则会使用Theme的效果，动态控制的话可以对不同Activity设置不同的动画效果。\n// FirstActivity.java public class FirstActivity extends AppCompatActivity { private TextView textView; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_first); textView = findViewById(R.id.text_1); textView.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { Intent intent = new Intent(FirstActivity.this, SecondActivity.class); // 由于Activity是通过startActivity启动，所以使用makeSceneTransitionAnimation // 同理，这里的transitionName为\u0026#34;text\u0026#34;，与SecondActivity相同，而且这里并没有设置 // FirstActivity的transitionName ActivityOptionsCompat options = ActivityOptionsCompat. makeSceneTransitionAnimation(FirstActivity.this, textView, \u0026#34;text\u0026#34;); startActivity(intent, options.toBundle()); } }); } } // SecondActivity.java public class SecondActivity extends AppCompatActivity { private TextView textView; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_second); textView = findViewById(R.id.text_2); // 动态设置transitionName ViewCompat.setTransitionName(textView, \u0026#34;text\u0026#34;); } } 而且Fragmen中存在的动画效果异常的问题没有出现在Activity中\n\u0026lt;!-- activity_first.xml --\u0026gt; \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:orientation=\u0026#34;horizontal\u0026#34;\u0026gt; \u0026lt;!-- \u0026lt;LinearLayout--\u0026gt; \u0026lt;!-- android:layout_width=\u0026#34;match_parent\u0026#34;--\u0026gt; \u0026lt;!-- android:layout_height=\u0026#34;wrap_content\u0026#34;\u0026gt;--\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/text_1\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_marginTop=\u0026#34;200dp\u0026#34; android:text=\u0026#34;aaaaaaaaaaaaaa\u0026#34; android:textSize=\u0026#34;24sp\u0026#34; /\u0026gt; \u0026lt;!-- \u0026lt;/LinearLayout\u0026gt;--\u0026gt; \u0026lt;/LinearLayout\u0026gt; \u0026lt;!-- activity_second.xml --\u0026gt; \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:orientation=\u0026#34;horizontal\u0026#34;\u0026gt; \u0026lt;LinearLayout android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:orientation=\u0026#34;horizontal\u0026#34;\u0026gt; \u0026lt;ImageView android:layout_width=\u0026#34;40dp\u0026#34; android:layout_height=\u0026#34;40dp\u0026#34; android:background=\u0026#34;@color/colorPrimary\u0026#34; android:src=\u0026#34;@drawable/ic_launcher_foreground\u0026#34; /\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/text_2\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;aaaaaaaaaaaaaa\u0026#34; android:textSize=\u0026#34;24sp\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; \u0026lt;/LinearLayout\u0026gt; 具体效果如下，但是仔细观察可以发现存在问题，状态栏在动画过程中会闪烁\n解决方法是指定状态栏或者其他控件不参加动画，原理是因为在动画过程中实际是通过一层windows ViewOverlay播放动画，这一层在包括了界面所有的View（状态栏也在其中），当我们指定动画时可以将状态栏的id排除出去就可以实现状态栏不参与动画，也就不会有闪烁的现象。\nTheme控制 // styles.xml \u0026lt;!-- specify enter and exit transitions --\u0026gt; \u0026lt;!-- 自定义fade.xml --\u0026gt; \u0026lt;item name=\u0026#34;android:windowEnterTransition\u0026#34;\u0026gt;@transition/fade\u0026lt;/item\u0026gt; \u0026lt;item name=\u0026#34;android:windowExitTransition\u0026#34;\u0026gt;@transition/fade\u0026lt;/item\u0026gt; // fade.xml \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;transitionSet xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34;\u0026gt; \u0026lt;fade xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34;\u0026gt; \u0026lt;targets\u0026gt; \u0026lt;!-- 可以设置statusBarBackground的id，也可以是我们自定义的控件的id，比如Toolbar --\u0026gt; \u0026lt;target android:excludeId=\u0026#34;@android:id/statusBarBackground\u0026#34; /\u0026gt; \u0026lt;target android:excludeId=\u0026#34;@android:id/navigationBarBackground\u0026#34; /\u0026gt; \u0026lt;!-- \u0026lt;target android:excludeId=\u0026#34;@id/appBar\u0026#34; /\u0026gt;--\u0026gt; \u0026lt;/targets\u0026gt; \u0026lt;/fade\u0026gt; \u0026lt;/transitionSet\u0026gt; 动态代码控制 // 当前Activity设置Exit效果，目的地Activity设置Enter效果 // FirstActivity.java Fade fade = new Fade(); fade.excludeTarget(android.R.id.statusBarBackground, true); fade.excludeTarget(android.R.id.navigationBarBackground, true); getWindow().setExitTransition(fade); // SecondActivity.java Fade fade = new Fade(); fade.excludeTarget(android.R.id.statusBarBackground, true); fade.excludeTarget(android.R.id.navigationBarBackground, true); getWindow().setEnterTransition(fade); Activity设置独立Theme // styles.xml \u0026lt;style name=\u0026#34;DefaultActivity\u0026#34; parent=\u0026#34;AppTheme\u0026#34;\u0026gt; \u0026lt;item name=\u0026#34;android:windowEnterTransition\u0026#34;\u0026gt;@transition/fade\u0026lt;/item\u0026gt; \u0026lt;item name=\u0026#34;android:windowExitTransition\u0026#34;\u0026gt;@transition/fade\u0026lt;/item\u0026gt; \u0026lt;/style\u0026gt; // AndroidManifest.xml \u0026lt;activity android:name=\u0026#34;.SecondActivity\u0026#34; android:theme=\u0026#34;@style/DefaultActivity\u0026#34; /\u0026gt; \u0026lt;activity android:name=\u0026#34;.FirstActivity\u0026#34; android:theme=\u0026#34;@style/DefaultActivity\u0026#34; /\u0026gt; 2.2 RecyclerView复杂效果 上面写的代码都是用的本地图片，如果从网络中加载图片并在不同Activity中跳转，那么必然需要考虑在两个Activity中加载图片时的缓存时间，常用的图片加载框架有Picasso和Glide，可以参考上面给出的链接。\n首先获取图片数据\nclass Constants { static List\u0026lt;String\u0026gt; getImageUrls() { List\u0026lt;String\u0026gt; data = new ArrayList\u0026lt;\u0026gt;(); data.add(\u0026#34;https://i.loli.net/2020/01/02/ClMXcUkJNETpYHb.jpg\u0026#34;); data.add(\u0026#34;https://i.loli.net/2020/01/02/ulnhD8S79w4IfaY.jpg\u0026#34;); data.add(\u0026#34;https://i.loli.net/2020/01/02/i9IFevNYqKVRcXP.jpg\u0026#34;); data.add(\u0026#34;https://i.loli.net/2020/01/02/7QDskmZunBg4GEj.jpg\u0026#34;); data.add(\u0026#34;https://i.loli.net/2020/01/02/eHzuXSqIoUbh8Mc.jpg\u0026#34;); data.add(\u0026#34;https://i.loli.net/2020/01/02/biSqYO73CLvjh8p.jpg\u0026#34;); data.add(\u0026#34;https://i.loli.net/2020/01/02/a4NjuqfMmckoVT2.jpg\u0026#34;); data.add(\u0026#34;https://i.loli.net/2020/01/02/jSoFtq7VRBM6TUZ.jpg\u0026#34;); data.add(\u0026#34;https://i.loli.net/2020/01/02/nw3vUZBlyIph1oH.jpg\u0026#34;); data.add(\u0026#34;https://i.loli.net/2020/01/02/y3wGlkoXq4EWSDt.jpg\u0026#34;); return data; } } 然后定义RecyclerView相关代码\npublic class MyAdapter extends RecyclerView.Adapter\u0026lt;MyAdapter.MyViewHolder\u0026gt; { private List\u0026lt;String\u0026gt; data; private Context context; public MyAdapter(List\u0026lt;String\u0026gt; data, Context context, OnItemClickListener onItemClickListener) { this.data = data; this.context = context; this.onItemClickListener = onItemClickListener; } @NonNull @Override public MyViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) { View view = LayoutInflater.from(context).inflate(R.layout.layout_item, parent, false); return new MyViewHolder(view); } @Override public void onBindViewHolder(@NonNull final MyViewHolder holder, final int position) { // 这里没有设置imageView和textView的transitionName也可以正常运行 String url = data.get(position); holder.textView.setText(url); loadImage(url, holder); holder.imageView.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { onItemClickListener.onItemClick(holder, position); } }); } // 分别通过Glide和Picasso加载图片 private void loadImage(String url, MyViewHolder holder) { Glide.with(context) .load(url) .centerCrop() .into(holder.imageView); // Picasso.get() // .load(url) // .fit() // .centerCrop() // .into(holder.imageView); } @Override public int getItemCount() { return data.size(); } class MyViewHolder extends RecyclerView.ViewHolder { public ImageView imageView; public TextView textView; public MyViewHolder(@NonNull View itemView) { super(itemView); imageView = itemView.findViewById(R.id.item_image); textView = itemView.findViewById(R.id.item_text); } } private OnItemClickListener onItemClickListener; public interface OnItemClickListener { void onItemClick(MyViewHolder viewHolder, int position); } } \u0026lt;!-- layout_item.xml --\u0026gt; \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; xmlns:tools=\u0026#34;http://schemas.android.com/tools\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;150dp\u0026#34; android:layout_marginBottom=\u0026#34;10dp\u0026#34; android:orientation=\u0026#34;vertical\u0026#34;\u0026gt; \u0026lt;ImageView android:id=\u0026#34;@+id/item_image\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;0dp\u0026#34; android:layout_weight=\u0026#34;1\u0026#34; android:layout_gravity=\u0026#34;center\u0026#34; tools:src=\u0026#34;@drawable/ic_launcher_foreground\u0026#34; /\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/item_text\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_gravity=\u0026#34;center\u0026#34; android:lines=\u0026#34;1\u0026#34; android:textSize=\u0026#34;16sp\u0026#34; tools:text=\u0026#34;aaaaaa\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; 然后是Activity的代码\n// ThirdActivity.java public class ThirdActivity extends AppCompatActivity implements MyAdapter.OnItemClickListener { private RecyclerView recyclerView; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_third); MyAdapter adapter = new MyAdapter(Constants.getImageUrls(), this, this); recyclerView = findViewById(R.id.list); recyclerView.setLayoutManager(new GridLayoutManager(this, 2)); recyclerView.setAdapter(adapter); } @Override public void onItemClick(MyAdapter.MyViewHolder viewHolder, int position) { Intent intent = new Intent(ThirdActivity.this, ForthActivity.class); intent.putExtra(\u0026#34;position\u0026#34;, position); // 与单个共享元素不同的是，多个共享元素动画需要使用Pair传参，而且需要强制转换类型为View Pair\u0026lt;View, String\u0026gt; imagePair = Pair.create((View)viewHolder.imageView, \u0026#34;image\u0026#34;); Pair\u0026lt;View, String\u0026gt; textPair = Pair.create((View)viewHolder.textView, \u0026#34;text\u0026#34;); ActivityOptionsCompat options = ActivityOptionsCompat. makeSceneTransitionAnimation(this, imagePair, textPair); startActivity(intent, options.toBundle()); } } // ForthActivity.java public class ForthActivity extends AppCompatActivity { private TextView textView; private ImageView imageView; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_forth); int position = getIntent().getIntExtra(\u0026#34;position\u0026#34;, 0); textView = findViewById(R.id.text_detail); imageView = findViewById(R.id.image_detail); textView.setText(Constants.getImageUrls().get(position)); loadImage(Constants.getImageUrls().get(position), imageView); } // 分别通过Glide和Picasso加载图片，注意这里与MyAdapter使用不同的框架也是没有问题的 private void loadImage(String url, ImageView view) { // 关键代码supportPostponeEnterTransition()方法，可以使得Activity // 延迟显示，直到执行了supportStartPostponedEnterTransition()方法。 // 也就是说，为了使图片能够先从网络上缓存下来再显示，可以在图片缓存成功的 // 回调方法中调用supportStartPostponedEnterTransition() supportPostponeEnterTransition(); Glide.with(this) .load(url) .centerCrop() .dontAnimate() // 实测这一行没有什么用 .listener(new RequestListener\u0026lt;Drawable\u0026gt;() { @Override public boolean onLoadFailed(@Nullable GlideException e, Object model, Target\u0026lt;Drawable\u0026gt; target, boolean isFirstResource) { supportStartPostponedEnterTransition(); return false; } @Override public boolean onResourceReady(Drawable resource, Object model, Target\u0026lt;Drawable\u0026gt; target, DataSource dataSource, boolean isFirstResource) { supportStartPostponedEnterTransition(); return false; } }) .into(view); // Picasso.get() // .load(url) // .noFade() // 实测这一行没有什么用 // .into(view, new Callback() { // @Override // public void onSuccess() { // supportStartPostponedEnterTransition(); // } // // @Override // public void onError(Exception e) { // supportStartPostponedEnterTransition(); // } // }); } } 最终效果\n这个显示效果有几个问题，一是TextView字体大小突变，二是图片返回时会有微小的大小反弹现象，三是图片如果卡在状态栏上会出现短时间覆盖状态栏的现象，最后是点击时不会立即跳转，会出现明显的卡顿。如果需要解决上述几个问题，可以参考Github animation-samples中的Unslpash示例。\n可以发现这个示例没有出现上面我所发生的显示效果问题，如果仔细查看代码可以发现为了优化这个效果加入了一些的自定义动画以及自定义View。\n3. 复杂效果的优化 具体可以参考Github animation-samples中的Unslpash示例。\nUnslpash示例具体实现了一下几个细节效果：\n在图片详情页使用了ViewPager，可以左右滑动切换图片； 当我们左右滑动切换图片再返回时，RecyclerView会滑动到对应的图片，而且有返回动画效果； 点击查看图片详情时动画没有卡顿的感觉，而且字体大小有良好的变换动画效果，不是突变； ViewPager左右滑动也没有产生加载的卡顿现象。 3.1 效果实现分析 首先是数据来源，Unslpash示例数据来自于https://unsplash.it，通过Retrofit获取，示例仅获取12张图片，构造的Photo数据结构就不用分析了，很简单。\n然后是两个Activity的动画效果，是通过Theme设置的，分别对MainActivity和DetailActivity使用不同的Theme，即最主要的动画效果是通过xml定义的，java代码只控制逻辑\n\u0026lt;!-- MainActivity --\u0026gt; \u0026lt;style name=\u0026#34;App.Home\u0026#34;\u0026gt; \u0026lt;item name=\u0026#34;android:windowExitTransition\u0026#34;\u0026gt;@transition/grid_exit\u0026lt;/item\u0026gt; \u0026lt;item name=\u0026#34;android:windowReenterTransition\u0026#34;\u0026gt;@transition/grid_reenter\u0026lt;/item\u0026gt; \u0026lt;/style\u0026gt; \u0026lt;!-- DetailActivity --\u0026gt; \u0026lt;style name=\u0026#34;App.Details\u0026#34;\u0026gt; \u0026lt;item name=\u0026#34;android:windowSharedElementEnterTransition\u0026#34;\u0026gt; @transition/shared_main_detail \u0026lt;/item\u0026gt; \u0026lt;/style\u0026gt; MainActivity的非共享元素移出界面时的效果是grid_exit，即爆炸效果；返回MainActivity时是grid_reenter，即从上向下滑动效果；DetailActivity的共享元素进入界面的效果是shared_main_detail，分别定义了photo和text的动画效果，photo使用了传统的几个动画就不说了，text使用的是自定义的动画，这个TextResize类还是有点复杂，所以会用就行了，而且不会出现在java代码中。\n\u0026lt;!-- grid_exit.xml --\u0026gt; \u0026lt;explode /\u0026gt; \u0026lt;!-- grid_reenter.xml --\u0026gt; \u0026lt;slide xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:slideEdge=\u0026#34;top\u0026#34; android:duration=\u0026#34;300\u0026#34; android:interpolator=\u0026#34;@android:interpolator/linear_out_slow_in\u0026#34;\u0026gt; \u0026lt;/slide\u0026gt; \u0026lt;!-- shared_main_detail.xml --\u0026gt; \u0026lt;transitionSet xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34;\u0026gt; \u0026lt;transitionSet\u0026gt; \u0026lt;targets\u0026gt; \u0026lt;target android:targetId=\u0026#34;@id/photo\u0026#34; /\u0026gt; \u0026lt;/targets\u0026gt; \u0026lt;changeBounds\u0026gt; \u0026lt;arcMotion android:maximumAngle=\u0026#34;50\u0026#34;/\u0026gt; \u0026lt;/changeBounds\u0026gt; \u0026lt;changeTransform /\u0026gt; \u0026lt;changeClipBounds /\u0026gt; \u0026lt;changeImageTransform /\u0026gt; \u0026lt;/transitionSet\u0026gt; \u0026lt;transitionSet\u0026gt; \u0026lt;targets\u0026gt; \u0026lt;target android:targetId=\u0026#34;@id/author\u0026#34; /\u0026gt; \u0026lt;/targets\u0026gt; \u0026lt;transition class=\u0026#34;com.example.android.unsplash.transition.TextResize\u0026#34; /\u0026gt; \u0026lt;changeBounds /\u0026gt; \u0026lt;/transitionSet\u0026gt; \u0026lt;!-- recolor不知道有什么用，删了也没有区别 --\u0026gt; \u0026lt;recolor\u0026gt; \u0026lt;targets\u0026gt; \u0026lt;target android:targetId=\u0026#34;@android:id/statusBarBackground\u0026#34; /\u0026gt; \u0026lt;target android:targetId=\u0026#34;@android:id/navigationBarBackground\u0026#34; /\u0026gt; \u0026lt;/targets\u0026gt; \u0026lt;/recolor\u0026gt; \u0026lt;/transitionSet\u0026gt; 从MainActivity点击跳转到DetailActivity时需要通过Intent传入几个数据，比如当前界面中text的属性值，点击的图片索引以及从网络请求得到的图片url等等\n@NonNull private static Intent getDetailActivityStartIntent(Activity host, ArrayList\u0026lt;Photo\u0026gt; photos, int position, PhotoItemBinding binding) { final Intent intent = new Intent(host, DetailActivity.class); intent.setAction(Intent.ACTION_VIEW); intent.putParcelableArrayListExtra(IntentUtil.PHOTO, photos); intent.putExtra(IntentUtil.SELECTED_ITEM_POSITION, position); intent.putExtra(IntentUtil.FONT_SIZE, binding.author.getTextSize()); intent.putExtra(IntentUtil.PADDING, new Rect(binding.author.getPaddingLeft(), binding.author.getPaddingTop(), binding.author.getPaddingRight(), binding.author.getPaddingBottom())); intent.putExtra(IntentUtil.TEXT_COLOR, binding.author.getCurrentTextColor()); return intent; } 在DetailActivity中通过getIntent方法获取传入的数据，构造DetailSharedElementEnterCallback，通过setEnterSharedElementCallback设置回调；setEnterSharedElementCallback可以监听共享元素进入此Activity时的状态，由sharedElementCallback自定义\n@Override protected void onCreate(Bundle savedInstanceState) { // ... Intent intent = getIntent(); sharedElementCallback = new DetailSharedElementEnterCallback(intent); setEnterSharedElementCallback(sharedElementCallback); initialItem = intent.getIntExtra(IntentUtil.SELECTED_ITEM_POSITION, 0); setUpViewPager(intent.\u0026lt;Photo\u0026gt;getParcelableArrayListExtra(IntentUtil.PHOTO)); // ... } DetailSharedElementEnterCallback的主要功能是在Activity切换时调整TextView的属性以及对共享元素进行绑定。从这个Callback可以看出来实际动画效果是发生在DetailActivity中，首先当处于onCreate方法中，在调用super.onCreate(savedInstanceState);之前设置DetailSharedElementEnterCallback，此时动画还未开始。\n按照顺序执行onMapSharedElements-\u0026gt;onSharedElementStart-\u0026gt;onSharedElementEnd方法，在onMapSharedElements方法中需要将对应的共享元素View与其transitionName关联起来，这里的作用其实等价于在MainActivity中生成的Pair对象，试想一下如果我们在点击时绑定的是position为1的ImageView，而如果我们在ViewPager中滑动后position变为4，那么我们就需要更新Pair对象，否则返回时动画效果就不是返回position为4的ImageView。所以只能在Callback中处理，由于使用了Databinding而且两个Activity中的ImageView的transitionName相同，所以简单的添加即可，将其他不需要变换动画的元素移出Map也可以在这里操作。\n然后在onSharedElementStart方法中会先将DetailActivity中的TextView的属性修改为MainActivity中对应TextView的属性，最后在onSharedElementEnd方法中将TextView设置为DetailActivity中原本的属性即可，也就是说从onSharedElementStart-\u0026gt;onSharedElementEnd就是动画的过程了，实际动画控制是由上面transitionSet定义的，这里仅提供最初和最终状态。\npublic class DetailSharedElementEnterCallback extends SharedElementCallback { // ... @Override public void onSharedElementStart(List\u0026lt;String\u0026gt; sharedElementNames, List\u0026lt;View\u0026gt; sharedElements, List\u0026lt;View\u0026gt; sharedElementSnapshots) { TextView author = getAuthor(); targetTextSize = author.getTextSize(); targetTextColors = author.getTextColors(); targetPadding = new Rect(author.getPaddingLeft(), author.getPaddingTop(), author.getPaddingRight(), author.getPaddingBottom()); if (IntentUtil.hasAll(intent, IntentUtil.TEXT_COLOR, IntentUtil.FONT_SIZE, IntentUtil.PADDING)) { author.setTextColor(intent.getIntExtra(IntentUtil.TEXT_COLOR, Color.BLACK)); float textSize = intent.getFloatExtra(IntentUtil.FONT_SIZE, targetTextSize); author.setTextSize(TypedValue.COMPLEX_UNIT_PX, textSize); Rect padding = intent.getParcelableExtra(IntentUtil.PADDING); author.setPadding(padding.left, padding.top, padding.right, padding.bottom); } } @Override public void onSharedElementEnd(List\u0026lt;String\u0026gt; sharedElementNames, List\u0026lt;View\u0026gt; sharedElements, List\u0026lt;View\u0026gt; sharedElementSnapshots) { TextView author = getAuthor(); author.setTextSize(TypedValue.COMPLEX_UNIT_PX, targetTextSize); if (targetTextColors != null) { author.setTextColor(targetTextColors); } if (targetPadding != null) { author.setPadding(targetPadding.left, targetPadding.top, targetPadding.right, targetPadding.bottom); } if (currentDetailBinding != null) { forceSharedElementLayout(currentDetailBinding.description); } } @Override public void onMapSharedElements(List\u0026lt;String\u0026gt; names, Map\u0026lt;String, View\u0026gt; sharedElements) { removeObsoleteElements(names, sharedElements, mapObsoleteElements(names)); mapSharedElement(names, sharedElements, getAuthor()); mapSharedElement(names, sharedElements, getPhoto()); } public void setBinding(@NonNull DetailViewBinding binding) { currentDetailBinding = binding; currentPhotoBinding = null; } public void setBinding(@NonNull PhotoItemBinding binding) { currentPhotoBinding = binding; currentDetailBinding = null; } private TextView getAuthor() { if (currentPhotoBinding != null) { return currentPhotoBinding.author; } else if (currentDetailBinding != null) { return currentDetailBinding.author; } else { throw new NullPointerException(\u0026#34;Must set a binding before transitioning.\u0026#34;); } } private ImageView getPhoto() { if (currentPhotoBinding != null) { return currentPhotoBinding.photo; } else if (currentDetailBinding != null) { return currentDetailBinding.photo; } else { throw new NullPointerException(\u0026#34;Must set a binding before transitioning.\u0026#34;); } } /** * Maps all views that don\u0026#39;t start with \u0026#34;android\u0026#34; namespace. * * @param names All shared element names. * @return The obsolete shared element names. */ @NonNull private List\u0026lt;String\u0026gt; mapObsoleteElements(List\u0026lt;String\u0026gt; names) { List\u0026lt;String\u0026gt; elementsToRemove = new ArrayList\u0026lt;\u0026gt;(names.size()); for (String name : names) { if (name.startsWith(\u0026#34;android\u0026#34;)) continue; elementsToRemove.add(name); } return elementsToRemove; } /** * Removes obsolete elements from names and shared elements. * * @param names Shared element names. * @param sharedElements Shared elements. * @param elementsToRemove The elements that should be removed. */ private void removeObsoleteElements(List\u0026lt;String\u0026gt; names, Map\u0026lt;String, View\u0026gt; sharedElements, List\u0026lt;String\u0026gt; elementsToRemove) { if (elementsToRemove.size() \u0026gt; 0) { names.removeAll(elementsToRemove); for (String elementToRemove : elementsToRemove) { sharedElements.remove(elementToRemove); } } } /** * Puts a shared element to transitions and names. * * @param names The names for this transition. * @param sharedElements The elements for this transition. * @param view The view to add. */ private void mapSharedElement(List\u0026lt;String\u0026gt; names, Map\u0026lt;String, View\u0026gt; sharedElements, View view) { String transitionName = view.getTransitionName(); names.add(transitionName); sharedElements.put(transitionName, view); } private void forceSharedElementLayout(View view) { int widthSpec = View.MeasureSpec.makeMeasureSpec(view.getWidth(), View.MeasureSpec.EXACTLY); int heightSpec = View.MeasureSpec.makeMeasureSpec(view.getHeight(), View.MeasureSpec.EXACTLY); view.measure(widthSpec, heightSpec); view.layout(view.getLeft(), view.getTop(), view.getRight(), view.getBottom()); } } 以上就是从MainActivity点击跳转到DetailActivity的全部流程，当然Unsplash示例还有ViewPager以及返回动画效果。\n当我们左右滑动时会调用DetailViewPagerAdapter的setPrimaryItem，在这个方法中我们设置的上面Callback的View binding，将其置为当前的ImageView，此时如果点击返回键，那么Callback的执行顺序是onMapSharedElements-\u0026gt;onMapSharedElements-\u0026gt;onSharedElementEnd-\u0026gt;onSharedElementStart-\u0026gt;onSharedElementStart-\u0026gt;onSharedElementEnd，且都是在DetailActivity的onPause之前执行的，这里分为两个阶段，因为此时在两个Activity中都有Callback，第一个onMapSharedElements是DetailActivity的，这里重新绑定position为4的ImageView；第二个onMapSharedElements是MainActivity的的，在onActivityReenter方法（Activity返回）中被调用，此时MainActivity已经知道了当前position为4，因此滑动RecyclerView到position为4的位置，并且将其对应的binding传入MainActivity的Callback中；然后是onSharedElementEnd-\u0026gt;onSharedElementStart，这个状态是DetailActivity的动作，很显然这个效果就是上面动画的逆过程；再是onSharedElementStart-\u0026gt;onSharedElementEnd，这个是MainActivity的动画过程，前面已经在onActivityReenter方法中获取了position和binding等数据，此时传入Callback中的Intent没有存储TextView的属性，因此这个过程在MainActivity中没有对共享元素产生任何动画效果。\n3.2 在Fragment中实现类似效果 在Fragment中实现类似ImageView共享元素+ViewPager的效果会遇到几个问题，一是Fragment仅支持一个元素的动画，所以不能再使用TextView和ImageView一起变化；二是Fragment没有类似Activity的onActivityReenter方法，因此Fragment无法知道是从哪个position返回的，也就是说返回动画可能会出错，当然通过传参的方式（可能有传空数据的异常）或者ViewModel的方式是可以共享数据，如果没有使用ViewModel，那么可以考虑禁用返回动画来避免错误，当然动画效果就不是很好。具体代码可参考Github animation-samples中的GridToPager示例。\n如果使用ViewModel来实现相同的效果可以参考ShareElementWithViewModel。大部分代码都是参考Github animation-samples中的示例，仅修改了数据处理部分以使用ViewModel。下面大致说明一下修改的思路。\n首先是依赖库，包括ViewModel和Navigation，以及使用了Databinding，用Glide加载图片\nandroid { // ... dataBinding { enabled = true } //... } dependencies { implementation fileTree(dir: \u0026#39;libs\u0026#39;, include: [\u0026#39;*.jar\u0026#39;]) implementation \u0026#39;androidx.appcompat:appcompat:1.1.0\u0026#39; implementation \u0026#39;androidx.constraintlayout:constraintlayout:1.1.3\u0026#39; def lifecycle_version = \u0026#34;2.1.0\u0026#34; implementation \u0026#34;androidx.lifecycle:lifecycle-extensions:$lifecycle_version\u0026#34; implementation \u0026#34;androidx.recyclerview:recyclerview:1.1.0\u0026#34; def nav_version = \u0026#34;2.1.0\u0026#34; // Java language implementation implementation \u0026#34;androidx.navigation:navigation-fragment:$nav_version\u0026#34; implementation \u0026#34;androidx.navigation:navigation-ui:$nav_version\u0026#34; implementation \u0026#39;com.github.bumptech.glide:glide:4.10.0\u0026#39; implementation \u0026#39;androidx.legacy:legacy-support-v4:1.0.0\u0026#39; annotationProcessor \u0026#39;com.github.bumptech.glide:compiler:4.10.0\u0026#39; implementation \u0026#39;com.google.android.material:material:1.0.0\u0026#39; implementation \u0026#39;com.squareup.retrofit2:retrofit:2.7.1\u0026#39; implementation \u0026#39;com.squareup.retrofit2:converter-gson:2.7.1\u0026#39; testImplementation \u0026#39;junit:junit:4.12\u0026#39; androidTestImplementation \u0026#39;androidx.test.ext:junit:1.1.1\u0026#39; androidTestImplementation \u0026#39;androidx.test.espresso:espresso-core:3.2.0\u0026#39; } 使用Navigation控制Fragment跳转，而且仅使用GridListFragment跳转到DetailPagerFragment，同时MainActivity不再进行任何操作。\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;navigation xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; xmlns:app=\u0026#34;http://schemas.android.com/apk/res-auto\u0026#34; xmlns:tools=\u0026#34;http://schemas.android.com/tools\u0026#34; android:id=\u0026#34;@+id/nav_graph\u0026#34; app:startDestination=\u0026#34;@id/listFragment\u0026#34;\u0026gt; \u0026lt;fragment android:id=\u0026#34;@+id/listFragment\u0026#34; android:name=\u0026#34;us.zoom.shareelementwithviewmodel.ui.grid.GridListFragment\u0026#34; android:label=\u0026#34;fragment_list\u0026#34; tools:layout=\u0026#34;@layout/fragment_list\u0026#34;\u0026gt; \u0026lt;action android:id=\u0026#34;@+id/action_listFragment_to_detailPagerFragment\u0026#34; app:destination=\u0026#34;@id/detailPagerFragment\u0026#34; /\u0026gt; \u0026lt;/fragment\u0026gt; \u0026lt;fragment android:id=\u0026#34;@+id/detailPagerFragment\u0026#34; android:name=\u0026#34;us.zoom.shareelementwithviewmodel.ui.pager.DetailPagerFragment\u0026#34; android:label=\u0026#34;fragment_detail_pager\u0026#34; tools:layout=\u0026#34;@layout/fragment_detail_pager\u0026#34; /\u0026gt; \u0026lt;/navigation\u0026gt; 实现ImageListViewModel，用于保存数据\npublic class ImageListViewModel extends ViewModel { // 保存从api获取到的数据 private MutableLiveData\u0026lt;List\u0026lt;Photo\u0026gt;\u0026gt; photos = new MutableLiveData\u0026lt;\u0026gt;(); public LiveData\u0026lt;List\u0026lt;Photo\u0026gt;\u0026gt; getPhotos() { return photos; } // 保存请求过程的状态 private MutableLiveData\u0026lt;Boolean\u0026gt; isLoading = new MutableLiveData\u0026lt;\u0026gt;(); public LiveData\u0026lt;Boolean\u0026gt; getIsLoading() { return isLoading; } // 保存ViewPager中当前位置 private MutableLiveData\u0026lt;Integer\u0026gt; currentPosition = new MutableLiveData\u0026lt;\u0026gt;(); public LiveData\u0026lt;Integer\u0026gt; getCurrentPosition() { return currentPosition; } public void setCurrentPosition(int position) { currentPosition.setValue(position); } { loadPhotos(); setCurrentPosition(0); } private void loadPhotos() { isLoading.setValue(true); UnsplashService unsplashApi = new Retrofit.Builder() .baseUrl(UnsplashService.BASEURL) .addConverterFactory(GsonConverterFactory.create()) .build() .create(UnsplashService.class); unsplashApi.getPhoto().enqueue(new Callback\u0026lt;List\u0026lt;Photo\u0026gt;\u0026gt;() { @Override public void onResponse(Call\u0026lt;List\u0026lt;Photo\u0026gt;\u0026gt; call, Response\u0026lt;List\u0026lt;Photo\u0026gt;\u0026gt; response) { List\u0026lt;Photo\u0026gt; list = response.body(); if (list != null \u0026amp;\u0026amp; !list.isEmpty()) { photos.setValue(new ArrayList\u0026lt;\u0026gt;(list.subList(list.size() - PHOTO_COUNT, list.size()))); } isLoading.setValue(false); } @Override public void onFailure(Call\u0026lt;List\u0026lt;Photo\u0026gt;\u0026gt; call, Throwable t) { Log.i(\u0026#34;ShareElement\u0026#34;, \u0026#34;UnsplashService onFailure: \u0026#34; + t.getMessage()); isLoading.setValue(false); } }); // Unsplash示例使用的api有时候会用不了，可以用本地的url替代，对应需要修改Photo的getPhotoUrl方法 // List\u0026lt;Photo\u0026gt; data = new ArrayList\u0026lt;\u0026gt;(); // for (String url : Constants.getImageUrls()) { // Photo photo = new Photo(\u0026#34;\u0026#34;, 0, 0, \u0026#34;\u0026#34;, url.hashCode(), \u0026#34;\u0026#34;, \u0026#34;\u0026#34;, url); // data.add(photo); // } // photos.setValue(data); // isLoading.setValue(false); } } Databinding适配，修改BindingAdapters，实现Glide加载并增加回调，回调会影响后续Fragment跳转的动画\npublic class BindingAdapters { // 绑定RecyclerView的list数据 @BindingAdapter(\u0026#34;listData\u0026#34;) public static void bindRecyclerView(RecyclerView recyclerView, List\u0026lt;Photo\u0026gt; data) { GridPhotoAdapter adapter = (GridPhotoAdapter) recyclerView.getAdapter(); assert adapter != null; adapter.submitList(data); } // 绑定Progressbar的状态 @BindingAdapter(\u0026#34;loadingStatus\u0026#34;) public static void bindStatus(ProgressBar progressBar, Boolean isLoading) { if (isLoading) { progressBar.setVisibility(View.VISIBLE); } else { progressBar.setVisibility(View.GONE); } } // Glide加载以及增加回调 @BindingAdapter(value = {\u0026#34;imageUrl\u0026#34;, \u0026#34;glideListener\u0026#34;}) public static void bindImage(ImageView imageView, Photo photo, OnGlideRequestListener listener) { int requestedPhotoWidth = imageView.getContext().getResources().getDisplayMetrics().widthPixels; Glide.with(imageView.getContext()) .load(photo.getPhotoUrl(requestedPhotoWidth)) .placeholder(R.drawable.ic_launcher_foreground) .override(ImageSize.NORMAL[0], ImageSize.NORMAL[1]) .addListener(new RequestListener\u0026lt;Drawable\u0026gt;() { @Override public boolean onLoadFailed(@Nullable GlideException e, Object model, Target\u0026lt;Drawable\u0026gt; target, boolean isFirstResource) { listener.onLoadFailed(e, model, target, isFirstResource); return false; } @Override public boolean onResourceReady(Drawable resource, Object model, Target\u0026lt;Drawable\u0026gt; target, DataSource dataSource, boolean isFirstResource) { listener.onResourceReady(resource, model, target, dataSource, isFirstResource); return false; } }) .into(imageView); } } 因为使用ViewModel在GridListFragment和DetailPagerFragment共享数据，所以ViewModel与MainActivity绑定\nviewModel = ViewModelProviders.of(requireActivity()).get(ImageListViewModel.class); GridListFragment使用了RecyclerView和Databinding，所以GridPhotoAdapter继承自ListAdapter，并实现DiffUtil.ItemCallback，以及点击事件的监听，又因为共享元素动画效果受Glide加载状态影响，所以需要把加载状态再通过OnLoadCompletedListener传到Fragment中，PhotoViewHolder采用Databinding实现。\n在GridListFragment使用postponeEnterTransition()控制加载动画，但是我遇到了一些非常奇怪的问题，所以只能在onStart()中调用\n@Override public void onStart() { super.onStart(); // 其他生命周期会触发不显示RecyclerView postponeEnterTransition(); } 因为通过GridPhotoAdapter传出了Glide的状态，所以可以在这里控制startPostponedEnterTransition，否则需要将Fragment实例传给Adapter\nprivate void onImageLoadCompleted(int position) { // Call startPostponedEnterTransition only when the \u0026#39;selected\u0026#39; image loading is completed. if (currentPosition != position) { return; } startPostponedEnterTransition(); } 点击跳转Fragment也可以通过Navigation实现了，同时更新ViewModel的数据，共享元素的绑定也是通过FragmentNavigator.Extras实现，不过看了这个的代码后发现似乎使用Navigation可以实现在Fragment中同时有多个共享元素动画。\nprivate void onListItemClick(View view, int position) { // Update the position. viewModel.setCurrentPosition(position); // Exclude the clicked card from the exit transition (e.g. the card will disappear immediately // instead of fading out with the rest to prevent an overlapping animation of fade and move). assert getExitTransition() != null; ((TransitionSet) getExitTransition()).excludeTarget(view, true); ImageView transitioningView = view.findViewById(R.id.photo); FragmentNavigator.Extras extras = new FragmentNavigator.Extras.Builder() .addSharedElement(transitioningView, transitioningView.getTransitionName()) .build(); Navigation.findNavController(view).navigate(R.id.action_listFragment_to_detailPagerFragment, null, null, extras); } 然后是DetailPagerFragment和DetailFragment，因为在实现过程中DetailFragment其实不是非常依赖ViewModel的数据，它只是作为显示结果被使用的，无论是当前位置还是全部图片数据都不需要获取或修改，所以DetailFragment仅需要进行Databinding即可，其他左右滑动数据修改都是在DetailPagerFragment中处理\npublic class DetailFragment extends Fragment implements OnGlideRequestListener { private static final String TAG = DetailFragment.class.getSimpleName(); private Photo photo; // 仅需要Photo数据 DetailFragment(Photo photo) { this.photo = photo; } @Override public View onCreateView(@NonNull LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) { // Inflate the layout for this fragment FragmentDetailBinding binding = FragmentDetailBinding.inflate(inflater); binding.setLifecycleOwner(this); binding.setListener(this); binding.setData(photo); return binding.getRoot(); } // 同样需要处理动画 @Override public void onLoadFailed(@Nullable GlideException e, Object model, Target\u0026lt;Drawable\u0026gt; target, boolean isFirstResource) { requireParentFragment().startPostponedEnterTransition(); } @Override public void onResourceReady(Drawable resource, Object model, Target\u0026lt;Drawable\u0026gt; target, DataSource dataSource, boolean isFirstResource) { requireParentFragment().startPostponedEnterTransition(); } } DetailViewPagerAdapter的实现就比较简单了，继承自FragmentStatePagerAdapter\npublic class DetailViewPagerAdapter extends FragmentStatePagerAdapter { private int size; private List\u0026lt;Photo\u0026gt; photos; DetailViewPagerAdapter(@NonNull FragmentManager fm, int size, List\u0026lt;Photo\u0026gt; photos) { super(fm, BEHAVIOR_RESUME_ONLY_CURRENT_FRAGMENT); this.size = size; this.photos = photos; } @Override public int getCount() { return size; } @NonNull @Override public Fragment getItem(int position) { return new DetailFragment(photos.get(position)); } } 最后是DetailPagerFragment，ViewModel中Photo数据的观察，以及Toolbar返回功能的修改\n// 返回现过必须通过onBackPressed实现，否则共享元素动画会消失 private View.OnClickListener navigateListener = view -\u0026gt; requireActivity().onBackPressed(); viewModel.getPhotos().observe(this, photos -\u0026gt; viewPager.setAdapter(new DetailViewPagerAdapter( getChildFragmentManager(), photos.size(), photos))); // Set the current position and add a listener that will update the selection coordinator when // paging the images. viewModel.getCurrentPosition().observe(this, position -\u0026gt; { viewPager.setCurrentItem(position); currentPosition = position; }); Toolbar toolbar = view.findViewById(R.id.toolbar); toolbar.setNavigationOnClickListener(navigateListener); 4. 使用技巧总结 Fragment中使用时，当前Fragment的共享元素的transitionName必须存在但是与目的地Fragment不同也能用，且RecyclerView中的每一个共享元素都必须设置为不同的transitionName（Activity中当前Activity的transitionName可以不设置，包括使用了RecyclerView，目的地Activity必须设置），但是实际使用时请务必将对应共享元素的transitionName设置为相同（RecyclerView除外）； Fragment中使用时，当目的地Fragment中共享元素被嵌套了多层，则可能出现滑动动画缺失现象，可以通过marginTop:1dp解决；Activity中不会有这种现象； 切换动画产生时会导致状态栏、ActionBar以及Toolbar的闪烁，可以通过在动画中将这些View的id排除即可避免； 如果使用了Glide或者Picasso等图片加载框架从网络请求加载图片，可以在Activity中设置supportPostponeEnterTransition()以及supportStartPostponedEnterTransition()方法来确保图片能够先缓存再显示（或者是postponeEnterTransition()和startPostponedEnterTransition()），但是会导致另一个问题，点击跳转非常卡顿； ViewPager配合使用实现左右滑动查看图片时，返回动画会出错，显示错误的图片，此时可以通过对ViewPager中的Fragment设置setSharedElementReturnTransition(null)来禁用返回动画（参考）； 如果需要完成良好的动画效果体验，请参考Github上的示例，在SharedElementCallback中处理共享元素匹配，并在合适的实际调用postponeEnterTransition()和startPostponedEnterTransition()。 参考： Android Developers文档指南 Github animation-samples Shared Element Transitions - Part 1: Activities Shared Element Transitions - Part 2: Fragments Shared Element Transitions - Part 3: Picasso \u0026amp; Glide android_guides Fragment transitions with shared elements ","permalink":"https://zhoutao822.github.io/posts/shareelement/","summary":"共享元素可以在Activity之间或者Fragment之间实现非常舒适的动画效果，如下图所示，特别是在跳转的界面之间拥有相同的界面元素，比如同一张图片但是大小不同，同一个View但是位置不同。需要注意的是最低api需要为21，即Android LOLLIPOP。","title":"Android-共享元素动画效果"},{"content":"Android Q之后对系统存储方式进行了调整，简而言之就是禁止开发人员随意通过路径访问操作外部存储文件，内部存储没有影响。这样做的目的很明显，即往后原生Android的文件管理器将不会出现各种App生成的乱七八糟的文件，不同类型的文件都在其各自相应的位置。\n示意图如下，主要行为变更在媒体文件（音频、视频、图片）以及下载文件中\n1. SAF框架 SAF（Storage Access Framework，存储访问框架），是Android 4.4之后提供的文件选择器，通过Intent方式启动，UI界面由系统提供，一般来说其他厂商魔改的系统都没有对这方面进行重写，所以示意图基本相同，如下\n1.1 外部存储 如果应用有发送文件、选择文件等功能，特别是需要读取系统文件目录的方法都需要修改，在target Q的情况下，试图通过路径访问外部公共文件的方式都会失效，如下所示，因此需要使用SAF框架选取文件，得到的结果是文件的Uri，然后再使用Uri读取或者处理该文件，外部存储路径如果打印出来类似/storage/emulated/0/Android/data/us.zoom.androidqdemo/files/aabb.rar、/storage/emulated/0/Pictures/Screenshots/Screenshot_20191014-141713.png，前者是当前应用的外部路径（可以直接访问），后者是公共图片文件下外部路径；内部路径类似/data/user/0/us.zoom.androidqdemo/data/aabb.png，内部路径无法直接在系统中查看。\n// 在手机外部存储根目录下创建text.txt文件，在Android P上可以成功创建此文件并写入数据，file.exists()返回True； // 在Android Q上无法创建此文件，返回False String filename = \u0026#34;text.txt\u0026#34;; File file = new File(Environment.getExternalStorageDirectory(), filename); // File file = new File(getFilesDir(), filename); //如果是内部存储，则两者都是正常访问 // File file = new File(getExternalFilesDir(\u0026#34;\u0026#34;), filename); // 外部存储的当前应用路径可以正常访问 try { FileOutputStream outputStream = new FileOutputStream(file); outputStream.write(\u0026#34;123456\u0026#34;.getBytes()); outputStream.close(); } catch (Exception e) { e.printStackTrace(); } Toast.makeText(this, file.exists() ? \u0026#34;True\u0026#34; : \u0026#34;False\u0026#34;, Toast.LENGTH_SHORT).show(); // 同理对读文件，Android P上可以读取text.txt内容，并且file.exists()返回True；Android Q上FileInputStream报错： // 无法访问，拒绝权限，但是file.exists()返回true String filename = \u0026#34;text.txt\u0026#34;; File file = new File(Environment.getExternalStorageDirectory(), filename); // File file = new File(getFilesDir(), filename); //如果是内部存储，则两者都是正常访问 // File file = new File(getExternalFilesDir(\u0026#34;\u0026#34;), filename); // 外部存储的当前应用路径可以正常访问 try { FileInputStream inputStream = new FileInputStream(file); InputStreamReader reader = new InputStreamReader(inputStream); BufferedReader br = new BufferedReader(reader); String line = \u0026#34;\u0026#34;; line = br.readLine(); while (line != null) { Log.i(\u0026#34;TestRead\u0026#34;, line); line = br.readLine(); // 一次读入一行数据 } } catch (Exception e) { e.printStackTrace(); } Toast.makeText(this, file.exists() ? \u0026#34;True\u0026#34; : \u0026#34;False\u0026#34;, Toast.LENGTH_SHORT).show(); 1.2 SAF使用 SAF原理可以在Google官网使用存储访问框架打开文件中查看，发送文件不能通过公共路径，那么就需要使用SAF。SAF读取到的文件有四类：图片、音频、视频、下载、内部存储空间（外部存储）以及各种网盘，可以通过setType设置显示的文件类别，其中图片（一般包含根目录以及照片DCIM文件夹、公有图片Pictures文件夹、Download下图片文件）、音频（一般包含根目录以及公有音频Music文件夹、Download下音频文件）、视频（一般包含根目录以及视频DCIM文件夹、公有视频Movies文件夹、Download下视频文件）中都是通过MediaStore保存的文件，下载中都是通过DownloadManager下载的文件，否则不显示在这几个目录中；内部存储空间即外部存储，从这里可以访问各个应用的外部存储；各种网盘也可以访问，从网盘获取文件会先调用网盘的下载功能，然后再获取下载好的文件，下载过程不可见。\n// 4.3及以下用 ACTION_PICK 或 ACTION_GET_CONTENT，Android 4.4以上可以多一个选择ACTION_OPEN_DOCUMENT，ACTION_PICK弹出单项选择窗口 // ACTION_GET_CONTENT与ACTION_OPEN_DOCUMENT类似，且使用ACTION_GET_CONTENT时，应用会导入数据（如图片文件）的副本，即如果 // 只是需要读取数据而不修改原始数据，那就用ACTION_GET_CONTENT，如果需要修改，使用ACTION_OPEN_DOCUMENT Intent intent = new Intent(Intent.ACTION_OPEN_DOCUMENT); // 过滤器只显示可以打开的结果 intent.addCategory(Intent.CATEGORY_OPENABLE); // 使用图像MIME数据类型过滤以仅显示图像 // intent.setType(\u0026#34;image/*\u0026#34;); // 要搜索通过已安装的存储提供商提供的所有文档 intent.setType(\u0026#34;*/*\u0026#34;); // 如果需要多选，对应的onActivityResult获取Uri通过data.getClipData() // intent.putExtra(Intent.EXTRA_ALLOW_MULTIPLE, true) startActivityForResult(intent, READ_REQUEST_CODE); 在onActivityResult中获取到文件的Uri，如果是发送文件功能的话，还需要文件名和文件类型，然后加上FileInputStream发送出去，所以需要通过Uri获取文件相关信息\n@Override public void onActivityResult(int requestCode, int resultCode, Intent resultData) { if (requestCode == READ_REQUEST_CODE \u0026amp;\u0026amp; resultCode == Activity.RESULT_OK) { Uri uri = null; if (resultData != null) { uri = resultData.getData(); } } } 比如：\n图片目录下的图片Uri类似于content://com.android.providers.media.documents/document/image%3A616260， 音频目录下content://com.android.providers.media.documents/document/audio%3A417558， 视频目录下content://com.android.providers.media.documents/document/video%3A616341， 下载目录下content://com.android.providers.downloads.documents/document/2884。 根据Uri可以使用ContentResolver查询相关文件的信息，比如ID、MIME_TYPE等等，查询代码可以看下面的FileUtils，在使用getDataColumn之前需要对Uri进行判断，获取文件种类以及id，比如image%3A616260，这就是一个Image文件，并且id为616260，%3A为冒号:，然后根据文件类型，使用相应的Uri查询，比如Image对应contentUri = MediaStore.Images.Media.EXTERNAL_CONTENT_URI;，打印出来的结果是content://media/external/images/media，然后selection为_id=?，selectionArgs为id值。\npublic static String getDataColumn(Context context, Uri uri, String selection, String[] selectionArgs) { Cursor cursor = null; // ContentProvider查询方式，通过uri加上指定的column，类似于查询数据库，uri中包括了provider的全称以及id， // 等价于数据库表与id，column等价于列，这样就可以直接取到对应的值；这里查询的是DISPLAY_NAME，一般来说文件名 // 应该就包含了文件类型，但是在实际使用中，有的文件的DISPLAY_NAME与文件名并不相同，所以需要知道文件类型， // 可以使用MIME_TYPE，还有其他种类的信息例如修改时间等等，并不常用（DATA列已被弃用，但可以查询到文件路径） final String column = MediaStore.Images.ImageColumns.DISPLAY_NAME; final String[] projection = { column }; try { // 查询方法调用query cursor = context.getContentResolver().query( uri, projection, selection, selectionArgs,null); if (cursor != null \u0026amp;\u0026amp; cursor.moveToFirst()) { final int column_index = cursor.getColumnIndexOrThrow(column); return cursor.getString(column_index); } } catch (Exception e) { e.printStackTrace(); } finally { if (cursor != null) cursor.close(); } return null; } 在测试过程中发现，对于SAF中图片、音频、视频三个目录下的文件都可以获取其正确的信息，但是对于下载目录下的文件存在问题。网上的对于com.android.providers.downloads的查询Uri是如下三种，但是全部无法查询到任何结果，public_downloads报异常Unknown URI（Android 6可以查询到），my_downloads查询结果为空，all_downloads报异常\njava.lang.SecurityException: Permission Denial: reading com.android.providers.downloads.provider.DownloadProvider uri content://downloads/all_downloads/2884 from pid=25434, uid=10786 requires android.permission.ACCESS_ALL_DOWNLOADS, or grantUriPermission() final String id = DocumentsContract.getDocumentId(uri); if (id != null \u0026amp;\u0026amp; id.startsWith(\u0026#34;raw:\u0026#34;)) { return id.substring(4); } String[] contentUriPrefixesToTry = new String[]{ \u0026#34;content://downloads/public_downloads\u0026#34;, \u0026#34;content://downloads/my_downloads\u0026#34;, \u0026#34;content://downloads/all_downloads\u0026#34; }; // 在API 29上多了一个新的Uri MediaStore.Downloads.EXTERNAL_CONTENT_URI，打印结果是 // content://media/external/downloads，类似于上面的MediaStore.Images.Media.EXTERNAL_CONTENT_URI， // 但是还是查询不到任何结果；如果直接拿content://com.android.providers.downloads.documents/document/2884 // 来查询可以查到MIME_TYPE和DISPLAY_NAME，或者通过context.getContentResolver().getType(uri)获取MIME_TYPE for (String contentUriPrefix : contentUriPrefixesToTry) { Uri contentUri = ContentUris.withAppendedId(Uri.parse(contentUriPrefix), Long.valueOf(id)); try { String path = getDataColumn(context, contentUri, null, null); if (path != null) { return path; } } catch (Exception e) { e.printStackTrace(); } } 对于下载目录下的文件获取其文件名以及文件类型的方式就只能通过原始Uri查询了，但是DISPLAY_NAME并不一定与真实文件名相同，然后通过Uri取文件数据，如下所示\n// 读取文件中的字符串 private String readTextFromUri(Uri uri) throws IOException { StringBuilder stringBuilder = new StringBuilder(); try (InputStream inputStream = getContentResolver().openInputStream(uri); BufferedReader reader = new BufferedReader( new InputStreamReader(Objects.requireNonNull(inputStream)))) { String line; while ((line = reader.readLine()) != null) { stringBuilder.append(line); } } return stringBuilder.toString(); } 或者取数据的FileInputStream，再利用FileInputStream进行其他操作，比如复制文件或者发送\nContentResolver contentResolver = this.getContentResolver(); ParcelFileDescriptor parcelFileDescriptor = null; try { parcelFileDescriptor = contentResolver.openFileDescriptor(uri, \u0026#34;r\u0026#34;); } catch (FileNotFoundException e) { e.printStackTrace(); } if (parcelFileDescriptor == null) { return; } FileChannel inputChannel = null; FileChannel outputChannel = null; long start = System.currentTimeMillis(); // 为了验证是否获取到数据，可以将数据保存到其他位置，比如这里的aabb.rar String dest = \u0026#34;/storage/emulated/0/Android/data/us.zoom.androidqdemo/files/aabb.rar\u0026#34;; try { FileInputStream inputStream = new FileInputStream( parcelFileDescriptor.getFileDescriptor()); inputChannel = inputStream.getChannel(); outputChannel = new FileOutputStream(dest).getChannel(); long srcSize = inputChannel.size(); long size = outputChannel.transferFrom(inputChannel, 0, srcSize); if (size == srcSize) { return; } } catch (Exception e) { e.printStackTrace(); } finally { long end = System.currentTimeMillis(); Toast.makeText(this, \u0026#34;Time: \u0026#34; + (end - start), Toast.LENGTH_LONG).show(); try { if (inputChannel != null) { inputChannel.close(); } } catch (IOException e) { e.printStackTrace(); } try { if (outputChannel != null) { outputChannel.close(); } } catch (IOException e) { e.printStackTrace(); } } 1.3 MediaStore使用 MediaStore是用于获取或者添加媒体文件（图片、音频、视频）信息的工具，需要配合ContentResolver使用，MediaStore定义列的名称，通过ContentResolver的query和insert方法去查询和添加文件。\n/** * 获取系统外部存储内所有的图片 * @param context * @return list */ private List\u0026lt;ImageInfo\u0026gt; getImageList(Context context) { List\u0026lt;ImageInfo\u0026gt; list = new ArrayList(); ContentResolver contentResolver = context.getContentResolver(); // 查询图片需要的Uri Uri uri = MediaStore.Images.Media.EXTERNAL_CONTENT_URI; String[] projection = null; String selection = null; String[] selectionArgs = null; String sortOrder = null; Cursor cursor = contentResolver.query(uri, projection, selection, selectionArgs, sortOrder); if (cursor != null) { while (cursor.moveToNext()) { ImageInfo imageInfo = new ImageInfo(); imageInfo.id = cursor.getInt(cursor.getColumnIndexOrThrow(MediaStore.Images.Media._ID)); // 组装图片uri imageInfo.uri = ContentUris.withAppendedId(uri, imageInfo.id); imageInfo.filePath = cursor.getString(cursor.getColumnIndex(MediaStore.Images.Media.DATA)); imageInfo.mimeType = cursor.getString(cursor.getColumnIndexOrThrow(MediaStore.Images.Media.MIME_TYPE)); imageInfo.title = cursor.getString(cursor.getColumnIndexOrThrow(MediaStore.Images.Media.TITLE)); imageInfo.addTime = cursor.getLong(cursor.getColumnIndex(MediaStore.Images.Media.DATE_ADDED)); list.add(imageInfo); } cursor.close(); } return list; } 得到uri后可以通过上面提到的方式取数据也可以直接通过ImageView.setImageURI(imageInfo.uri)展示出来。如果有加载缩略图的要求，也可以通过Uri获取缩略图的Bitmap，调用loadThumbnail方法，并且可以指定缩略图大小（视频文件也可以加载缩略图），通过query方式查询缩略图的方式在Android Q上基本失效。\ncontext.getContentResolver().loadThumbnail(imageInfo.uri, new Size(50, 50), null) 除了查询之外，比较重要的是插入媒体文件的功能，比如在外部存储的应用私有目录下的图片不会显示在SAF框架中，如果需要将其显示在图片目录中，需要将文件另存到公有目录下，一般是Pictures文件夹中。同理对音频、视频文件也是如此，通过insert方法传入的Uri决定文件保存位置。在Android Q上通过Uri将文件保存到Download目录下似乎不太可行，只能依靠DownloadManager直接下载保存到Download下。\nprivate boolean SavePictureFile(Context context, File file) { if (file == null) { return false; } // 首先需要获取到源文件的File对象，然后根据File对象的相关信息构造Uri，比如MIME_TYPE和DISPLAY_NAME等等 Uri uri = insertFileIntoMediaStore(context, file, true); // 然后通过FileInputStream的方式将文件拷贝到目的文件中 return copyFile(context, file, uri); } private Uri insertFileIntoMediaStore(Context context, File file, boolean isPicture) { ContentValues contentValues = new ContentValues(); contentValues.put(MediaStore.Video.Media.DISPLAY_NAME, file.getName()); contentValues.put(MediaStore.Video.Media.MIME_TYPE, isPicture ? \u0026#34;image/jpeg\u0026#34; : \u0026#34;video/mp4\u0026#34;); if (Build.VERSION.SDK_INT \u0026gt;= 29) { contentValues.put(MediaStore.Video.Media.DATE_TAKEN, file.lastModified()); // Android Q如果不设置RELATIVE_PATH，则默认保存在Pictures文件夹下，可以通过RELATIVE_PATH添加 // Pictures/MyPictures子文件夹，文件将会保存在MyPictures中 // contentValues.put(MediaStore.Video.Media.RELATIVE_PATH, Environment.DIRECTORY_PICTURES + File.separator + \u0026#34;MyPictures\u0026#34;); } Uri uri = null; try { // 通过insert方法得到公有目录下目的文件的Uri uri = context.getContentResolver().insert( (isPicture ? MediaStore.Images.Media.EXTERNAL_CONTENT_URI : MediaStore.Video.Media.EXTERNAL_CONTENT_URI) , contentValues ); } catch (Exception e) { e.printStackTrace(); } return uri; } // 文件复制的方式同上 private boolean copyFile(Context context, File srcFile, Uri destFile) { ContentResolver contentResolver = context.getContentResolver(); ParcelFileDescriptor parcelFileDescriptor = null; try { parcelFileDescriptor = contentResolver.openFileDescriptor(destFile, \u0026#34;w\u0026#34;); } catch (FileNotFoundException e) { e.printStackTrace(); } if (parcelFileDescriptor == null) { return false; } FileChannel inputChannel = null; FileChannel outputChannel = null; try { FileInputStream inputStream = new FileInputStream( srcFile); inputChannel = inputStream.getChannel(); outputChannel = new FileOutputStream(parcelFileDescriptor.getFileDescriptor()).getChannel(); long srcSize = inputChannel.size(); long size = outputChannel.transferFrom(inputChannel, 0, srcSize); if (size == srcSize) { return true; } } catch (Exception e) { e.printStackTrace(); } finally { try { if (inputChannel != null) { inputChannel.close(); } } catch (IOException e) { e.printStackTrace(); } try { if (outputChannel != null) { outputChannel.close(); } } catch (IOException e) { e.printStackTrace(); } } return false; } 2. Android系统路径API补充说明 2.1 内部存储与外部存储 首先是内部存储与外部存储，内部存储类似/data/user/0/us.zoom.androidqdemo/，其中us.zoom.androidqdemo是包名，可以通过以下几个方法获取到当前应用的内部路径，内部存储一个最主要的特点就是与应用绑定，如果应用卸载了那么内部存储中应用私有目录的所有文件都会被删除，另一个特点就是内部存储无法直接通过手机中的文件管理或者其他名字的系统应用查看（而外部存储可见），内部存储的空间一般较小，需要谨慎使用，外部存储空间很大。\nEnvironment.getDataDirectory().getAbsolutePath() // /data getFilesDir().getAbsolutePath() // /data/user/0/us.zoom.androidqdemo/files getCacheDir().getAbsolutePath() // /data/user/0/us.zoom.androidqdemo/cache getDir(\u0026#34;myFile\u0026#34;, MODE_PRIVATE).getAbsolutePath() // /data/user/0/us.zoom.androidqdemo/app_myFile 外部存储类似/storage/emulated/0/Android/data/us.zoom.androidqdemo/files/（外部存储的应用私有目录）、/storage/emulated/0/Pictures/Screenshots/（外部存储的公有目录）这样的路径，我们通过文件管理这个系统应用进入的根目录就是/storage/emulated/0，在Android Q之前我们会发现这个目录下有非常多的乱七八糟的文件夹，除了Alarms, Android, DCIM, Download, Movies, Music, Notifications, Pictures, Podcasts, Ringtones之外，其他文件或者文件夹都是由你安装的其他APP自行生成的，所以Android Q之前的文件系统极其混乱，因此在Android Q之后不允许对外部存储中公有目录随意访问（可能提示权限拒绝），而内部存储以及外部存储的应用私有目录可以直接通过路径访问，因此在Android Q上我们就会发现外部存储的根目录仅有上面我提到的几个文件夹。\nEnvironment.getExternalStorageDirectory().getAbsolutePath() // /storage/emulated/0 Environment.getExternalStoragePublicDirectory(\u0026#34;\u0026#34;).getAbsolutePath() // /storage/emulated/0 getExternalFilesDir(\u0026#34;\u0026#34;).getAbsolutePath() // /storage/emulated/0/Android/data/us.zoom.androidqdemo/files getExternalCacheDir().getAbsolutePath() // /storage/emulated/0/Android/data/us.zoom.androidqdemo/cache // 如果手机支持SD卡扩展，那么可以通过getExternalFilesDirs(\u0026#34;\u0026#34;)获取所有的外部存储（手机内置外部存储+SD卡） 现在的Android手机一般情况下存储空间都非常大了基本在32GB起步，64GB比较常见，一般用到的都是外部存储，但是还是需要判断外部存储空间是否可用，比如通过Environment.getExternalStorageState()判断是否正常挂载，如果不可用那么就需要使用到内部存储。\n2.2 缓存与其他文件 在内部存储和外部存储的应用私有目录下会发现两个文件夹files和cache，很显然，files用于存储普通数据，cache用于存储缓存数据，如何使用这两个目录存储应用的文件就依赖开发人员的选择了，比如如果是应用本身下载的文件但是不想对外公开，那么可以放在files中，如果是应用读写文件过程中产生的临时文件可以放在cache中，实际开发时需自行设计。\n清除缓存：我们知道应用程序在运行过程中需要经过很多过程，比如读入程序，计算，输入输出等等，这些过程中肯定会产生很多的数据，它们在内存中，以供程序运行时调用。所以清除缓存清除的是APP运行过程中所产生的临时数据。\n清除数据：清除数据才是真正的删除了我们保存在文件中的数据（永久性数据，如果不人为删除的话会一直保存在文件中）例如当我们在设置里面清除了某个应用的数据，那么/data/user/0/packname/和/storage/emulated/0/Android/data/packname/下的文件里面的数据会全部删除，包括cache，files，lib，shared_prefs等等。\n3. FileUtils相关代码 package us.zoom.androidqdemo; /* * Copyright (C) 2018 OpenIntents.org * * Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ import android.content.ContentUris; import android.content.Context; import android.content.Intent; import android.database.Cursor; import android.database.DatabaseUtils; import android.net.Uri; import android.os.Build; import android.os.Environment; import android.provider.DocumentsContract; import android.provider.MediaStore; import android.provider.OpenableColumns; import android.util.Log; import android.webkit.MimeTypeMap; import androidx.annotation.NonNull; import androidx.annotation.Nullable; import androidx.core.content.FileProvider; import java.io.BufferedOutputStream; import java.io.File; import java.io.FileFilter; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.IOException; import java.io.InputStream; import java.text.DecimalFormat; import java.util.Comparator; public class FileUtils { public static final String DOCUMENTS_DIR = \u0026#34;documents\u0026#34;; // configured android:authorities in AndroidManifest (https://developer.android.com/reference/android/support/v4/content/FileProvider) public static final String AUTHORITY = \u0026#34;YOUR_AUTHORITY.provider\u0026#34;; public static final String HIDDEN_PREFIX = \u0026#34;.\u0026#34;; /** * TAG for log messages. */ static final String TAG = \u0026#34;FileUtils\u0026#34;; private static final boolean DEBUG = false; // Set to true to enable logging /** * File and folder comparator. TODO Expose sorting option method */ public static Comparator\u0026lt;File\u0026gt; sComparator = (f1, f2) -\u0026gt; { // Sort alphabetically by lower case, which is much cleaner return f1.getName().toLowerCase().compareTo( f2.getName().toLowerCase()); }; /** * File (not directories) filter. */ public static FileFilter sFileFilter = file -\u0026gt; { final String fileName = file.getName(); // Return files only (not directories) and skip hidden files return file.isFile() \u0026amp;\u0026amp; !fileName.startsWith(HIDDEN_PREFIX); }; /** * Folder (directories) filter. */ public static FileFilter sDirFilter = file -\u0026gt; { final String fileName = file.getName(); // Return directories only and skip hidden directories return file.isDirectory() \u0026amp;\u0026amp; !fileName.startsWith(HIDDEN_PREFIX); }; private FileUtils() { } //private constructor to enforce Singleton pattern /** * Gets the extension of a file name, like \u0026#34;.png\u0026#34; or \u0026#34;.jpg\u0026#34;. * * @param uri * @return Extension including the dot(\u0026#34;.\u0026#34;); \u0026#34;\u0026#34; if there is no extension; * null if uri was null. */ public static String getExtension(String uri) { if (uri == null) { return null; } int dot = uri.lastIndexOf(\u0026#34;.\u0026#34;); if (dot \u0026gt;= 0) { return uri.substring(dot); } else { // No extension. return \u0026#34;\u0026#34;; } } /** * @return Whether the URI is a local one. */ public static boolean isLocal(String url) { return url != null \u0026amp;\u0026amp; !url.startsWith(\u0026#34;http://\u0026#34;) \u0026amp;\u0026amp; !url.startsWith(\u0026#34;https://\u0026#34;); } /** * @return True if Uri is a MediaStore Uri. * @author paulburke */ public static boolean isMediaUri(Uri uri) { return \u0026#34;media\u0026#34;.equalsIgnoreCase(uri.getAuthority()); } /** * Convert File into Uri. * * @param file * @return uri */ public static Uri getUri(File file) { return (file != null) ? Uri.fromFile(file) : null; } /** * Returns the path only (without file name). * * @param file * @return */ public static File getPathWithoutFilename(File file) { if (file != null) { if (file.isDirectory()) { // no file to be split off. Return everything return file; } else { String filename = file.getName(); String filepath = file.getAbsolutePath(); // Construct path without file name. String pathwithoutname = filepath.substring(0, filepath.length() - filename.length()); if (pathwithoutname.endsWith(\u0026#34;/\u0026#34;)) { pathwithoutname = pathwithoutname.substring(0, pathwithoutname.length() - 1); } return new File(pathwithoutname); } } return null; } /** * @return The MIME type for the given file. */ public static String getMimeType(File file) { String extension = getExtension(file.getName()); if (extension.length() \u0026gt; 0) return MimeTypeMap.getSingleton().getMimeTypeFromExtension(extension.substring(1)); return \u0026#34;application/octet-stream\u0026#34;; } /** * @return The MIME type for the give Uri. */ public static String getMimeType(Context context, Uri uri) { File file = new File(getPath(context, uri)); return getMimeType(file); } /** * @return The MIME type for the give String Uri. */ public static String getMimeType(Context context, String url) { String type = context.getContentResolver().getType(Uri.parse(url)); if (type == null) { type = \u0026#34;application/octet-stream\u0026#34;; } return type; } /** * @param uri The Uri to check. * @return Whether the Uri authority is local. */ public static boolean isLocalStorageDocument(Uri uri) { return AUTHORITY.equals(uri.getAuthority()); } /** * @param uri The Uri to check. * @return Whether the Uri authority is ExternalStorageProvider. */ public static boolean isExternalStorageDocument(Uri uri) { return \u0026#34;com.android.externalstorage.documents\u0026#34;.equals(uri.getAuthority()); } /** * @param uri The Uri to check. * @return Whether the Uri authority is DownloadsProvider. */ public static boolean isDownloadsDocument(Uri uri) { return \u0026#34;com.android.providers.downloads.documents\u0026#34;.equals(uri.getAuthority()); } /** * @param uri The Uri to check. * @return Whether the Uri authority is MediaProvider. */ public static boolean isMediaDocument(Uri uri) { return \u0026#34;com.android.providers.media.documents\u0026#34;.equals(uri.getAuthority()); } /** * @param uri The Uri to check. * @return Whether the Uri authority is Google Photos. */ public static boolean isGooglePhotosUri(Uri uri) { return \u0026#34;com.google.android.apps.photos.content\u0026#34;.equals(uri.getAuthority()); } /** * Get the value of the data column for this Uri. This is useful for * MediaStore Uris, and other file-based ContentProviders. * * @param context The context. * @param uri The Uri to query. * @param selection (Optional) Filter used in the query. * @param selectionArgs (Optional) Selection arguments used in the query. * @return The value of the _data column, which is typically a file path. */ public static String getDataColumn(Context context, Uri uri, String selection, String[] selectionArgs) { Cursor cursor = null; final String column = MediaStore.Files.FileColumns.DATA; final String[] projection = { column }; try { cursor = context.getContentResolver().query(uri, projection, selection, selectionArgs, null); if (cursor != null \u0026amp;\u0026amp; cursor.moveToFirst()) { if (DEBUG) DatabaseUtils.dumpCursor(cursor); final int column_index = cursor.getColumnIndexOrThrow(column); return cursor.getString(column_index); } } catch (Exception e) { e.printStackTrace(); } finally { if (cursor != null) cursor.close(); } return null; } /** * Get a file path from a Uri. This will get the the path for Storage Access * Framework Documents, as well as the _data field for the MediaStore and * other file-based ContentProviders.\u0026lt;br\u0026gt; * \u0026lt;br\u0026gt; * Callers should check whether the path is local before assuming it * represents a local file. * * @param context The context. * @param uri The Uri to query. * @see #isLocal(String) * @see #getFile(Context, Uri) */ public static String getPath(final Context context, final Uri uri) { String absolutePath = getLocalPath(context, uri); return absolutePath != null ? absolutePath : uri.toString(); } private static String getLocalPath(final Context context, final Uri uri) { if (DEBUG) Log.d(TAG + \u0026#34; File -\u0026#34;, \u0026#34;Authority: \u0026#34; + uri.getAuthority() + \u0026#34;, Fragment: \u0026#34; + uri.getFragment() + \u0026#34;, Port: \u0026#34; + uri.getPort() + \u0026#34;, Query: \u0026#34; + uri.getQuery() + \u0026#34;, Scheme: \u0026#34; + uri.getScheme() + \u0026#34;, Host: \u0026#34; + uri.getHost() + \u0026#34;, Segments: \u0026#34; + uri.getPathSegments().toString() ); final boolean isKitKat = Build.VERSION.SDK_INT \u0026gt;= Build.VERSION_CODES.KITKAT; // DocumentProvider if (isKitKat \u0026amp;\u0026amp; DocumentsContract.isDocumentUri(context, uri)) { // LocalStorageProvider if (isLocalStorageDocument(uri)) { // The path is the id return DocumentsContract.getDocumentId(uri); } // ExternalStorageProvider else if (isExternalStorageDocument(uri)) { final String docId = DocumentsContract.getDocumentId(uri); final String[] split = docId.split(\u0026#34;:\u0026#34;); final String type = split[0]; if (\u0026#34;primary\u0026#34;.equalsIgnoreCase(type)) { return Environment.getExternalStorageDirectory() + \u0026#34;/\u0026#34; + split[1]; } else if (\u0026#34;home\u0026#34;.equalsIgnoreCase(type)) { return Environment.getExternalStorageDirectory() + \u0026#34;/documents/\u0026#34; + split[1]; } } // DownloadsProvider else if (isDownloadsDocument(uri)) { final String id = DocumentsContract.getDocumentId(uri); if (id != null \u0026amp;\u0026amp; id.startsWith(\u0026#34;raw:\u0026#34;)) { return id.substring(4); } // Android Q 似乎无效 String[] contentUriPrefixesToTry = new String[]{ \u0026#34;content://downloads/public_downloads\u0026#34;, \u0026#34;content://downloads/my_downloads\u0026#34;, \u0026#34;content://downloads/all_downloads\u0026#34; }; for (String contentUriPrefix : contentUriPrefixesToTry) { Uri contentUri = ContentUris.withAppendedId(Uri.parse(contentUriPrefix), Long.valueOf(id)); try { String path = getDataColumn(context, contentUri, null, null); if (path != null) { return path; } } catch (Exception e) { e.printStackTrace(); } } // path could not be retrieved using ContentResolver, therefore copy file to accessible cache using streams String fileName = getFileName(context, uri); File cacheDir = getDocumentCacheDir(context); File file = generateFileName(fileName, cacheDir); String destinationPath = null; if (file != null) { destinationPath = file.getAbsolutePath(); saveFileFromUri(context, uri, destinationPath); } return destinationPath; } // MediaProvider else if (isMediaDocument(uri)) { final String docId = DocumentsContract.getDocumentId(uri); final String[] split = docId.split(\u0026#34;:\u0026#34;); final String type = split[0]; Uri contentUri = null; if (\u0026#34;image\u0026#34;.equals(type)) { contentUri = MediaStore.Images.Media.EXTERNAL_CONTENT_URI; } else if (\u0026#34;video\u0026#34;.equals(type)) { contentUri = MediaStore.Video.Media.EXTERNAL_CONTENT_URI; } else if (\u0026#34;audio\u0026#34;.equals(type)) { contentUri = MediaStore.Audio.Media.EXTERNAL_CONTENT_URI; } final String selection = \u0026#34;_id=?\u0026#34;; final String[] selectionArgs = new String[]{ split[1] }; return getDataColumn(context, contentUri, selection, selectionArgs); } } // MediaStore (and general) else if (\u0026#34;content\u0026#34;.equalsIgnoreCase(uri.getScheme())) { // Return the remote address if (isGooglePhotosUri(uri)) { return uri.getLastPathSegment(); } return getDataColumn(context, uri, null, null); } // File else if (\u0026#34;file\u0026#34;.equalsIgnoreCase(uri.getScheme())) { return uri.getPath(); } return null; } /** * Convert Uri into File, if possible. * * @return file A local file that the Uri was pointing to, or null if the * Uri is unsupported or pointed to a remote resource. * @author paulburke * @see #getPath(Context, Uri) */ public static File getFile(Context context, Uri uri) { if (uri != null) { String path = getPath(context, uri); if (path != null \u0026amp;\u0026amp; isLocal(path)) { return new File(path); } } return null; } /** * Get the file size in a human-readable string. * * @param size * @return * @author paulburke */ public static String getReadableFileSize(int size) { final int BYTES_IN_KILOBYTES = 1024; final DecimalFormat dec = new DecimalFormat(\u0026#34;###.#\u0026#34;); final String KILOBYTES = \u0026#34; KB\u0026#34;; final String MEGABYTES = \u0026#34; MB\u0026#34;; final String GIGABYTES = \u0026#34; GB\u0026#34;; float fileSize = 0; String suffix = KILOBYTES; if (size \u0026gt; BYTES_IN_KILOBYTES) { fileSize = size / BYTES_IN_KILOBYTES; if (fileSize \u0026gt; BYTES_IN_KILOBYTES) { fileSize = fileSize / BYTES_IN_KILOBYTES; if (fileSize \u0026gt; BYTES_IN_KILOBYTES) { fileSize = fileSize / BYTES_IN_KILOBYTES; suffix = GIGABYTES; } else { suffix = MEGABYTES; } } } return String.valueOf(dec.format(fileSize) + suffix); } /** * Get the Intent for selecting content to be used in an Intent Chooser. * * @return The intent for opening a file with Intent.createChooser() */ public static Intent createGetContentIntent() { // Implicitly allow the user to select a particular kind of data final Intent intent = new Intent(Intent.ACTION_GET_CONTENT); // The MIME data type filter intent.setType(\u0026#34;*/*\u0026#34;); // Only return URIs that can be opened with ContentResolver intent.addCategory(Intent.CATEGORY_OPENABLE); return intent; } /** * Creates View intent for given file * * @param file * @return The intent for viewing file */ public static Intent getViewIntent(Context context, File file) { //Uri uri = Uri.fromFile(file); Uri uri = FileProvider.getUriForFile(context, AUTHORITY, file); Intent intent = new Intent(Intent.ACTION_VIEW); String url = file.toString(); if (url.contains(\u0026#34;.doc\u0026#34;) || url.contains(\u0026#34;.docx\u0026#34;)) { // Word document intent.setDataAndType(uri, \u0026#34;application/msword\u0026#34;); } else if (url.contains(\u0026#34;.pdf\u0026#34;)) { // PDF file intent.setDataAndType(uri, \u0026#34;application/pdf\u0026#34;); } else if (url.contains(\u0026#34;.ppt\u0026#34;) || url.contains(\u0026#34;.pptx\u0026#34;)) { // Powerpoint file intent.setDataAndType(uri, \u0026#34;application/vnd.ms-powerpoint\u0026#34;); } else if (url.contains(\u0026#34;.xls\u0026#34;) || url.contains(\u0026#34;.xlsx\u0026#34;)) { // Excel file intent.setDataAndType(uri, \u0026#34;application/vnd.ms-excel\u0026#34;); } else if (url.contains(\u0026#34;.zip\u0026#34;) || url.contains(\u0026#34;.rar\u0026#34;)) { // WAV audio file intent.setDataAndType(uri, \u0026#34;application/x-wav\u0026#34;); } else if (url.contains(\u0026#34;.rtf\u0026#34;)) { // RTF file intent.setDataAndType(uri, \u0026#34;application/rtf\u0026#34;); } else if (url.contains(\u0026#34;.wav\u0026#34;) || url.contains(\u0026#34;.mp3\u0026#34;)) { // WAV audio file intent.setDataAndType(uri, \u0026#34;audio/x-wav\u0026#34;); } else if (url.contains(\u0026#34;.gif\u0026#34;)) { // GIF file intent.setDataAndType(uri, \u0026#34;image/gif\u0026#34;); } else if (url.contains(\u0026#34;.jpg\u0026#34;) || url.contains(\u0026#34;.jpeg\u0026#34;) || url.contains(\u0026#34;.png\u0026#34;)) { // JPG file intent.setDataAndType(uri, \u0026#34;image/jpeg\u0026#34;); } else if (url.contains(\u0026#34;.txt\u0026#34;)) { // Text file intent.setDataAndType(uri, \u0026#34;text/plain\u0026#34;); } else if (url.contains(\u0026#34;.3gp\u0026#34;) || url.contains(\u0026#34;.mpg\u0026#34;) || url.contains(\u0026#34;.mpeg\u0026#34;) || url.contains(\u0026#34;.mpe\u0026#34;) || url.contains(\u0026#34;.mp4\u0026#34;) || url.contains(\u0026#34;.avi\u0026#34;)) { // Video files intent.setDataAndType(uri, \u0026#34;video/*\u0026#34;); } else { intent.setDataAndType(uri, \u0026#34;*/*\u0026#34;); } intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION); intent.addFlags(Intent.FLAG_GRANT_WRITE_URI_PERMISSION); return intent; } public static File getDownloadsDir() { return Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS); } public static File getDocumentCacheDir(@NonNull Context context) { File dir = new File(context.getCacheDir(), DOCUMENTS_DIR); if (!dir.exists()) { dir.mkdirs(); } logDir(context.getCacheDir()); logDir(dir); return dir; } private static void logDir(File dir) { if(!DEBUG) return; Log.d(TAG, \u0026#34;Dir=\u0026#34; + dir); File[] files = dir.listFiles(); for (File file : files) { Log.d(TAG, \u0026#34;File=\u0026#34; + file.getPath()); } } @Nullable public static File generateFileName(@Nullable String name, File directory) { if (name == null) { return null; } File file = new File(directory, name); if (file.exists()) { String fileName = name; String extension = \u0026#34;\u0026#34;; int dotIndex = name.lastIndexOf(\u0026#39;.\u0026#39;); if (dotIndex \u0026gt; 0) { fileName = name.substring(0, dotIndex); extension = name.substring(dotIndex); } int index = 0; while (file.exists()) { index++; name = fileName + \u0026#39;(\u0026#39; + index + \u0026#39;)\u0026#39; + extension; file = new File(directory, name); } } try { if (!file.createNewFile()) { return null; } } catch (IOException e) { Log.w(TAG, e); return null; } logDir(directory); return file; } // /** // * Writes response body to disk // * // * @param body ResponseBody // * @param path file path // * @return File // */ // public static File writeResponseBodyToDisk(ResponseBody body, String path) { // try { // File target = new File(path); // // InputStream inputStream = null; // OutputStream outputStream = null; // // try { // byte[] fileReader = new byte[4096]; // // inputStream = body.byteStream(); // outputStream = new FileOutputStream(target); // // while (true) { // int read = inputStream.read(fileReader); // // if (read == -1) { // break; // } // // outputStream.write(fileReader, 0, read); // } // // outputStream.flush(); // // return target; // } catch (IOException e) { // return null; // } finally { // if (inputStream != null) { // inputStream.close(); // } // // if (outputStream != null) { // outputStream.close(); // } // } // } catch (IOException e) { // return null; // } // } private static void saveFileFromUri(Context context, Uri uri, String destinationPath) { InputStream is = null; BufferedOutputStream bos = null; try { is = context.getContentResolver().openInputStream(uri); bos = new BufferedOutputStream(new FileOutputStream(destinationPath, false)); byte[] buf = new byte[1024]; is.read(buf); do { bos.write(buf); } while (is.read(buf) != -1); } catch (IOException e) { e.printStackTrace(); } finally { try { if (is != null) is.close(); if (bos != null) bos.close(); } catch (IOException e) { e.printStackTrace(); } } } public static byte[] readBytesFromFile(String filePath) { FileInputStream fileInputStream = null; byte[] bytesArray = null; try { File file = new File(filePath); bytesArray = new byte[(int) file.length()]; //read file into bytes[] fileInputStream = new FileInputStream(file); fileInputStream.read(bytesArray); } catch (IOException e) { e.printStackTrace(); } finally { if (fileInputStream != null) { try { fileInputStream.close(); } catch (IOException e) { e.printStackTrace(); } } } return bytesArray; } public static File createTempImageFile(Context context, String fileName) throws IOException { // Create an image file name File storageDir = new File(context.getCacheDir(), DOCUMENTS_DIR); return File.createTempFile(fileName, \u0026#34;.jpg\u0026#34;, storageDir); } public static String getFileName(@NonNull Context context, Uri uri) { String mimeType = context.getContentResolver().getType(uri); String filename = null; if (mimeType == null \u0026amp;\u0026amp; context != null) { String path = getPath(context, uri); if (path == null) { filename = getName(uri.toString()); } else { File file = new File(path); filename = file.getName(); } } else { Cursor returnCursor = context.getContentResolver().query(uri, null, null, null, null); if (returnCursor != null) { int nameIndex = returnCursor.getColumnIndex(OpenableColumns.DISPLAY_NAME); returnCursor.moveToFirst(); filename = returnCursor.getString(nameIndex); returnCursor.close(); } } return filename; } public static String getName(String filename) { if (filename == null) { return null; } int index = filename.lastIndexOf(\u0026#39;/\u0026#39;); return filename.substring(index + 1); } } 参考： Android Q 隐私权变更：分区存储 Save a file on external storage Android 10(Android Q) 适配 使用存储访问框架打开文件 Android Q 沙箱适配多媒体文件总结 ","permalink":"https://zhoutao822.github.io/posts/saf/","summary":"Android Q之后对系统存储方式进行了调整，简而言之就是禁止开发人员随意通过路径访问操作外部存储文件，内部存储没有影响。这样做的目的很明显，即往后原生Android的文件管理器将不会出现各种App生成的乱七八糟的文件，不同类型的文件都在其各自相应的位置。","title":"Android-Q适配-存储方式"},{"content":"Android中很多地方都需要跨线程通信，这是由于Android主线程不允许进行复杂的网络请求或者其他非常耗时的操作，否则会导致ANR，主线程只能进行UI操作，比如修改某个控件的text、设置某个控件不可见等等，因此网络请求等操作需要在其他线程中完成，当数据在其他线程中获取完毕时，通过跨线程通信将数据传到主线程中，主线程就可以直接根据数据进行UI操作。常见的跨线程通信的方式有Handler、AsyncTask、EventBus以及RxJava等，前两个是Android自带，后两者是封装好的第三方库。\n1. Handler Handler是Android中最简单的线程间通信方式，同时也可以在同一个线程中发送消息，但是使用时需要注意内存泄漏的问题。\n1.1 Handler简单使用 还是以和风天气请求为例，我们的目标是在子线程中请求数据，然后通过Handler将数据传到主线程中并显示出来。\npublic class MainActivity extends AppCompatActivity { private final static String KEY = \u0026#34;XXXXXXXXXX\u0026#34;; private final static String URL = \u0026#34;https://free-api.heweather.net/s6/weather/\u0026#34;; private TextView textView; private Handler handler; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); textView = findViewById(R.id.textView); // Handler的实例化，重写handleMessage方法用于等待处理msg， // handleMessage方法是回调，在回调中更新UI，此时执行在主线程， // 在Android Studio中会提示这里存在内存泄漏问题 handler = new Handler() { @Override public void handleMessage(Message msg) { super.handleMessage(msg); textView.setText(msg.obj.toString()); } }; // 在子线程开启一个网络请求 new Thread(new Runnable() { @Override public void run() { // Retrofit通用代码 Retrofit retrofit = new Retrofit.Builder() .baseUrl(URL) // 设置网络请求的公共Url地址 .addConverterFactory(GsonConverterFactory.create()) // 设置数据解析器 .build(); Api api = retrofit.create(Api.class); Call\u0026lt;WeatherEntity\u0026gt; call = api.getNowWeather(\u0026#34;beijing\u0026#34;, KEY); try { // 为了在当前子线程获取数据，这里直接使用execute WeatherEntity result = call.execute().body(); // Message的实例化方法Message.obtain Message message = Message.obtain(); // 可以通过Message附加很多数据，这里仅用obj，保存我们网络请求得到的实例 message.obj = result; // 通过handler.sendMessage(message)实现调用回调方法，完成数据传输 // 这种操作有点类似于接口回调 handler.sendMessage(message); } catch (IOException e) { e.printStackTrace(); } } }).start(); } } 这里的内存泄露的原因可以参考其他资料，主要是Java 中非静态内部类和匿名内部类会持有外部类的引用同时Handler 的生命周期比外部类长导致的。如何解决，肯定就是让Handler是静态内部类就完事了\npublic class MainActivity extends AppCompatActivity { private final static String KEY = \u0026#34;XXXXXXXXXX\u0026#34;; private final static String URL = \u0026#34;https://free-api.heweather.net/s6/weather/\u0026#34;; private TextView textView; private Handler handler; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); textView = findViewById(R.id.textView); // 使用自定义的静态内部类 handler = new MyHandler(this); // 子线程请求没有变化 new Thread(new Runnable() { @Override public void run() { Retrofit retrofit = new Retrofit.Builder() .baseUrl(URL) // 设置网络请求的公共Url地址 .addConverterFactory(GsonConverterFactory.create()) // 设置数据解析器 .build(); Api api = retrofit.create(Api.class); Call\u0026lt;WeatherEntity\u0026gt; call = api.getNowWeather(\u0026#34;beijing\u0026#34;, KEY); try { WeatherEntity result = call.execute().body(); Message message = Message.obtain(); message.obj = result; handler.sendMessage(message); } catch (IOException e) { e.printStackTrace(); } } }).start(); } @Override protected void onDestroy() { handler.removeCallbacksAndMessages(null); super.onDestroy(); } // public void handleMessage(Message msg) { textView.setText(msg.obj.toString()); } // 自定义静态内部类，与onDestroy中removeCallbacksAndMessages一起使用 public static class MyHandler extends Handler { private WeakReference\u0026lt;MainActivity\u0026gt; reference; public MyHandler(MainActivity mainActivity) { // 同时需要持有对MainActivity的弱引用 this.reference = new WeakReference\u0026lt;\u0026gt;(mainActivity); } @Override public void handleMessage(Message msg) { super.handleMessage(msg); MainActivity mainActivity = reference.get(); if (mainActivity != null) { // 将msg传给MainActivity处理 mainActivity.handleMessage(msg); } } } } 1.2 Handler线程间通信 上面的例子仅演示了从子线程传数据给主线程，那么如果同时需要从主线程传数据给子线程，怎么办\n// 首先需要自定义MyThread，完成Looper的初始化，否则子线程不会自动初始化Looper private class MyThread extends Thread { private Looper looper; @Override public void run() { super.run(); Looper.prepare(); looper = Looper.myLooper(); Looper.loop(); } } // 然后在onCreate方法中 Log.i(\u0026#34;aaaa\u0026#34;, String.valueOf(Thread.currentThread())); MyThread thread = new MyThread(); thread.start(); // 必须先启动子线程 while (true) { // 确保子线程中的Looper初始化完成 if (thread.looper != null) { // 此时handler的handleMessage方法是在子线程MyThread中执行的 // 两处log中线程的值是不一样的，通过Handler的构造方法实现子线程的调用 handler = new Handler(thread.looper) { @Override public void handleMessage(Message msg) { Log.i(\u0026#34;aaaa\u0026#34;, String.valueOf(msg.what) + Thread.currentThread()); } }; handler.sendEmptyMessage(12321); break; } } // 如果使用定义好的HandlerThread，则不需要继承Thread，直接使用， // HandlerThread默认帮我们完成了Looper的初始化 Log.i(\u0026#34;aaaa\u0026#34;, String.valueOf(Thread.currentThread())); // HandlerThread需要用String的构造方法，我们在log中也可以看到 HandlerThread thread = new HandlerThread(\u0026#34;new thread\u0026#34;); thread.start(); while (true) { if (thread.getLooper() != null) { handler = new Handler(thread.getLooper()) { @Override public void handleMessage(Message msg) { Log.i(\u0026#34;aaaa\u0026#34;, String.valueOf(msg.what) + Thread.currentThread()); } }; handler.sendEmptyMessage(12321); break; } } 为什么子线程需要初始化Looper，而主线程不需要？\n首先需要明白的是，只有需要处理消息的线程才需要Looper，即哪个线程执行了handleMessage方法，则线程需要Looper，原因在源码分析中解释；主线程以及HandlerThread会自动进行Looper的初始化，而new Thread()不会，因此在第二个例子中，子线程需要处理消息，所以需要初始化Looper而第一个例子中主线程不需要。\nHandler的初始化，其构造方法依赖于什么，为什么第二个例子中Handler不是在主线程中初始化的吗？\n首先需要知道的是Handler是可以被跨线程调用的，而View是不可以的，举个例子，如果在第一个例子中我们在子线程中调用textView.setText(result.toString());，则会报错CalledFromWrongThreadException: Only the original thread that created a view hierarchy can touch its views.，而Handler没问题，Handler默认构造方法new Handler()会将当前线程的Looper保存在自己这个实例中，即将主线程中的Looper保存，而带参数的构造方法new Handler(thread.looper)会保存thread的looper在实例中，又因为Handler是可以跨线程调用的，所以区分Handler属于哪个线程其实是根据构造方法传入的参数决定的，至于Handler归属于不同的线程会有什么影响，在源码分析中解释。\n1.3 Handler源码分析 以从子线程向主线程发送消息为例，首先从ActivityThread的main方法开始，前面说过主线程中的Looper是自动初始化的，其初始化的位置就在ActivityThread的main方法中\n// ActivityThread.java 核心就两个Looper.prepareMainLooper()和Looper.loop() public static void main(String[] args) { // ... Looper.prepareMainLooper(); // ... // 显然这里是不会执行的 if (false) { Looper.myLooper().setMessageLogging(new LogPrinter(Log.DEBUG, \u0026#34;ActivityThread\u0026#34;)); } // End of event ActivityThreadMain. Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); Looper.loop(); throw new RuntimeException(\u0026#34;Main thread loop unexpectedly exited\u0026#34;); } 再看看Looper.prepareMainLooper()的作用\n// Looper.java 看注释就知道是是为主线程初始化Looper，关键还是看prepare方法，再看myLooper /** * Initialize the current thread as a looper, marking it as an * application\u0026#39;s main looper. The main looper for your application * is created by the Android environment, so you should never need * to call this function yourself. See also: {@link #prepare()} */ public static void prepareMainLooper() { prepare(false); synchronized (Looper.class) { if (sMainLooper != null) { throw new IllegalStateException(\u0026#34;The main Looper has already been prepared.\u0026#34;); } sMainLooper = myLooper(); } } // prepare方法通过sThreadLocal set了一个Looper实例， // 一个Looper实例保存了MessageQueue和Thread.currentThread() private static void prepare(boolean quitAllowed) { if (sThreadLocal.get() != null) { throw new RuntimeException(\u0026#34;Only one Looper may be created per thread\u0026#34;); } sThreadLocal.set(new Looper(quitAllowed)); } // myLooper方法从sThreadLocal get到Looper，那正好对应上面prepare set的Looper， // ThreadLocal的作用是可以保存线程内的变量，简而言之就是通过ThreadLocal的set和get方法 // 处理的变量仅属于某个线程，以Looper为例，在某个线程中有且仅有一个 /** * Return the Looper object associated with the current thread. Returns * null if the calling thread is not associated with a Looper. */ public static @Nullable Looper myLooper() { return sThreadLocal.get(); } // 最后调用了Looper.loop() /** * Run the message queue in this thread. Be sure to call * {@link #quit()} to end the loop. */ public static void loop() { // Looper.loop()会进入一个死循环，但是这个循环并不会导致卡死， // 涉及到Linux pipe/epoll机制，简单说就是在主线程的MessageQueue没有消息时， // 便阻塞在loop的queue.next()中的nativePollOnce()方法里，此时主线程会释放CPU资源进入休眠状态， // 直到下个消息到达或者有事务发生，通过往pipe管道写端写入数据来唤醒主线程工作。 // 这里采用的epoll机制，是一种IO多路复用机制，可以同时监控多个描述符， // 当某个描述符就绪(读或写就绪)，则立刻通知相应程序进行读或写操作，本质同步I/O，即读写是阻塞的。 // 所以说，主线程大多数时候都是处于休眠状态，并不会消耗大量CPU资源。 // 先拿到当前线程的Looper，然后拿到Looper中的MessageQueue final Looper me = myLooper(); if (me == null) { throw new RuntimeException(\u0026#34;No Looper; Looper.prepare() wasn\u0026#39;t called on this thread.\u0026#34;); } final MessageQueue queue = me.mQueue; // ... // 开启循环，Android中主线程上所有的点击事件、UI绘制都是通过Message发送到MessageQueue中等待执行 // 所以这里必须是死循环，因为如果跳出了这个循环说明已经无法再继续处理任何Message，那么随之而来的肯定就是 // 应用崩溃或者重启Looper，但是这里的循环并不会导致卡死，理由在上面已经简要说明了 for (;;) { // 循环的作用就是通过queue.next()不断地从MessageQueue取出Message，next方法中也是一个死循环， // 正常情况下queue.next()应该返回一个有效的Message，或者休眠不返回任何值，如果返回null， // 说明出了问题 Message msg = queue.next(); // might block if (msg == null) { // 当取出的message为空时说明MessageQueue被终止了，因此跳出循环，执行其他操作，比如重启Looper或者崩溃？ // No message indicates that the message queue is quitting. return; } // ... // 当我们取到有效的Message后，就需要知道这个Message应该由谁来处理，即Target，从Message源码中可知， // 这个Target实际上就是Handler，最终调用的就是Handler的dispatchMessage方法，从这里我们就知道了 // 只要其他线程能够将Message发送到主线程的MessageQueue中，那么这个Message就可以被主线程的Handler处理 try { msg.target.dispatchMessage(msg); dispatchEnd = needEndTime ? SystemClock.uptimeMillis() : 0; } finally { if (traceTag != 0) { Trace.traceEnd(traceTag); } } // ... // 最后需要对Message对象进行回收 msg.recycleUnchecked(); } } ActivityThread的main方法中对主线程的Looper进行初始化，同样的主线程的MessageQueue也准备好对其中的Message进行分发，这都是通过死循环实现的，相当于MessageQueue是一个等待队列，有消息来了，他就取消息并调用Message对应的Handler的dispatchMessage方法，如果没有就休眠，然后我们看看Handler的初始化以及Message的发送是如何实现的\n// Handler.java Handler的构造方法分为两类，一类是参数带Looper的，另一类是不带Looper // 不带Looper的构造函数最终会调用到最后一个构造函数，并进行Looper的初始化； // 带Looper的构造函数会直接保存参数中的Looper实例 public Handler() { this(null, false); } public Handler(Callback callback) { this(callback, false); } public Handler(Looper looper) { this(looper, null, false); } public Handler(Looper looper, Callback callback) { this(looper, callback, false); } public Handler(boolean async) { this(null, async); } public Handler(Looper looper, Callback callback, boolean async) { mLooper = looper; mQueue = looper.mQueue; mCallback = callback; mAsynchronous = async; } public Handler(Callback callback, boolean async) { if (FIND_POTENTIAL_LEAKS) { final Class\u0026lt;? extends Handler\u0026gt; klass = getClass(); if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) \u0026amp;\u0026amp; (klass.getModifiers() \u0026amp; Modifier.STATIC) == 0) { Log.w(TAG, \u0026#34;The following Handler class should be static or leaks might occur: \u0026#34; + klass.getCanonicalName()); } } // Looper的myLooper方法会初始化当前线程的Looper mLooper = Looper.myLooper(); if (mLooper == null) { throw new RuntimeException( \u0026#34;Can\u0026#39;t create handler inside thread \u0026#34; + Thread.currentThread() + \u0026#34; that has not called Looper.prepare()\u0026#34;); } mQueue = mLooper.mQueue; mCallback = callback; mAsynchronous = async; } 然后调用handler.sendMessage(message);\n// Handler.java sendMessage方法会直接调用sendMessageDelayed // sendMessageDelayed就是多个延时的效果 public final boolean sendMessage(Message msg) { return sendMessageDelayed(msg, 0); } public final boolean sendMessageDelayed(Message msg, long delayMillis) { if (delayMillis \u0026lt; 0) { delayMillis = 0; } // 通过加上SystemClock.uptimeMillis()可以直接得到执行的具体时间 return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis); } public boolean sendMessageAtTime(Message msg, long uptimeMillis) { MessageQueue queue = mQueue; if (queue == null) { RuntimeException e = new RuntimeException( this + \u0026#34; sendMessageAtTime() called with no mQueue\u0026#34;); Log.w(\u0026#34;Looper\u0026#34;, e.getMessage(), e); return false; } // 最终还是使用Handler的MessageQueue return enqueueMessage(queue, msg, uptimeMillis); } private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) { // 注意这里将Message的target设置为当前handler msg.target = this; if (mAsynchronous) { msg.setAsynchronous(true); } // 然后调用MessageQueue的enqueueMessage方法 return queue.enqueueMessage(msg, uptimeMillis); } // MessageQueue.java enqueueMessage将Message加入链表中 boolean enqueueMessage(Message msg, long when) { if (msg.target == null) { throw new IllegalArgumentException(\u0026#34;Message must have a target.\u0026#34;); } if (msg.isInUse()) { throw new IllegalStateException(msg + \u0026#34; This message is already in use.\u0026#34;); } synchronized (this) { // 如果MessageQueue被终止了，那么Message还需要回收 if (mQuitting) { IllegalStateException e = new IllegalStateException( msg.target + \u0026#34; sending message to a Handler on a dead thread\u0026#34;); Log.w(TAG, e.getMessage(), e); msg.recycle(); return false; } msg.markInUse(); msg.when = when; Message p = mMessages; boolean needWake; // 根据msg.next基本可以发现Message是一个链表中的节点，也就是说MessageQueue中的mMessages // 是一种链表形式的结构，其中mMessages是表头，当执行next方法时就会将表头也就是mMessages表示的 // Message返回，当我们传入的Message满足以下任意条件时，可以将此Message作为表头： // 1. 表头本身为空，很明显当没有任何Message传入的时候； // 2. 当我们传入的Message没有任何延迟，这也很显然，立即执行的Message当然要放第一个； // 3. 当我们传入的Message的执行时间在表头的执行时间之前，这也很显然，按照时间排序。 if (p == null || when == 0 || when \u0026lt; p.when) { // New head, wake up the event queue if blocked. msg.next = p; mMessages = msg; needWake = mBlocked; } else { // 如果Message不是表头位置，那么肯定就是链表中的某个位置 // Inserted within the middle of the queue. Usually we don\u0026#39;t have to wake // up the event queue unless there is a barrier at the head of the queue // and the message is the earliest asynchronous message in the queue. needWake = mBlocked \u0026amp;\u0026amp; p.target == null \u0026amp;\u0026amp; msg.isAsynchronous(); Message prev; for (;;) { // 链表的遍历，还要判断时间when prev = p; p = p.next; if (p == null || when \u0026lt; p.when) { break; } if (needWake \u0026amp;\u0026amp; p.isAsynchronous()) { needWake = false; } } // 这就很简单了，有序链表中加入某个节点，排序方式为when的值 msg.next = p; // invariant: p == prev.next prev.next = msg; } // We can assume mPtr != 0 because mQuitting is false. if (needWake) { nativeWake(mPtr); } } return true; } 到这里我们就知道了Message被Handler加到了Handler线程的MessageQueue中，而Handler线程中的Looper一直在等待Message进入MessageQueue，通过queue.next()取出Message，然后调用Handler的dispatchMessage方法\n/** * Handle system messages here. */ public void dispatchMessage(Message msg) { // dispatchMessage处理Message的方式也很简单 // 首先判断Message是否设置了Callback，如果有 // 则执行message.callback.run() if (msg.callback != null) { handleCallback(msg); } else { // 如果没有，则判断Handler是否初始化设置了Callback， // 这个和Handler的构造函数相关 if (mCallback != null) { if (mCallback.handleMessage(msg)) { return; } } // 否则就执行handler重写的handleMessage方法， // 这个方法是在我们继承Handler时重写的，或者 // 在使用Handler匿名内部类时重写的 handleMessage(msg); } } 以上就是完整的通过Handler从子线程发送消息到主线程并执行的过程，也解决了我的一些问题：\n1.为什么要设计Handler来传输消息？\n因为多线程的情况下并不确定子线程何时能够执行完毕获取数据，所以需要设计Handler实现一种回调机制，即当子线程数据获取完成后将数据传到主线程中，通过主线程中的回调决定如何处理传来的数据。\n2.为什么要用MessageQueue和Looper这种工具？\n我想是因为既然子线程并不确定何时结束，其次如果存在多个子线程向主线程传递消息，那干脆将这些消息都放在一个队列MessageQueue中，因为多个子线程之间的执行顺序我们也无法确定，如果放在队列中，那么根据消息附加的时间来进行排序我们就可以按照顺序读取从各个子线程发送过来的消息了，与此同时，需要一个能够不停地读取队列中消息的工具Looper，Looper可以循环取数据但是不会阻塞卡死。\n1.4 Handler进阶 Handler除了可以发送Message外，还可以post Runnable，Runnable是接口，提供run方法，Thread类实现了Runnable接口，所以Thread需要实现run方法，run方法中的内容就是执行在Thread线程中，如果Runnable是通过Handler post，那么根据Message的原理，应该明白此Runnable就是运行在Handler归属的线程中\n@Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); textView = findViewById(R.id.textView); // handler不重写handleMessage方法 handler = new Handler(); new Thread(new Runnable() { @Override public void run() { // Retrofit通用代码 Retrofit retrofit = new Retrofit.Builder() .baseUrl(URL) // 设置网络请求的公共Url地址 .addConverterFactory(GsonConverterFactory.create()) // 设置数据解析器 .build(); Api api = retrofit.create(Api.class); Call\u0026lt;WeatherEntity\u0026gt; call = api.getNowWeather(\u0026#34;beijing\u0026#34;, KEY); try { // 为了在当前子线程获取数据，这里直接使用execute final WeatherEntity result = call.execute().body(); // 通过post直接修改textView的text handler.post(new Runnable() { @Override public void run() { textView.setText(result.toString()); } }); } catch (IOException e) { e.printStackTrace(); } } }).start(); } 因为textView只能在主线程进行设置，所以很显然handler post的Runnable是在主线程运行的，这样就不需要传递数据，而是直接处理数据了，下面看看Runnable是如何被处理的\n// Handler.java public final boolean post(Runnable r) { // sendMessageDelayed之前分析过，这里是将Runnable放入Message中了 return sendMessageDelayed(getPostMessage(r), 0); } // 通过Message保存了这个Runnable，保存在callback，这个之前在dispatchMessage中见过 private static Message getPostMessage(Runnable r) { Message m = Message.obtain(); m.callback = r; return m; } public void dispatchMessage(Message msg) { // 之前sendMessage都是走的第二个判断，post走的就是第一个判断， // 我们的Runnable现在不为空 if (msg.callback != null) { handleCallback(msg); } else { if (mCallback != null) { if (mCallback.handleMessage(msg)) { return; } } handleMessage(msg); } } // 结果很明显了，就是执行了Runnable的run方法 private static void handleCallback(Message message) { message.callback.run(); } 下面演示一下多个线程向主线程发送消息会产生怎样的结果，自定义线程MessageThread用于发送Message，普通的Thread用于post Runnable\n@Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); textView = findViewById(R.id.textView); // handler根据传过来的Message的what值进行不同的操作 handler = new Handler() { @Override public void handleMessage(Message msg) { switch (msg.what) { case 0: Log.i(\u0026#34;aaaa\u0026#34;, \u0026#34;Thread 0: \u0026#34; + msg.obj.toString()); break; case 1: Log.i(\u0026#34;aaaa\u0026#34;, \u0026#34;Thread 1: \u0026#34; + msg.obj.toString()); break; case 2: Log.i(\u0026#34;aaaa\u0026#34;, \u0026#34;Thread 2: \u0026#34; + msg.obj.toString()); break; } } }; // 开启三个线程发送Message，加上延时 new MessageThread(0, \u0026#34;thread 0 hahaha\u0026#34;, 3000).start(); new MessageThread(1, \u0026#34;thread 1 oooooo\u0026#34;, 1000).start(); new MessageThread(2, \u0026#34;thread 2 yyyyyy\u0026#34;, 2000).start(); // post Runnable也加上延时，注意这里的postDelayed并不会阻塞主线程， // 原理同Looper.loop()，所以不会引起ANR，这个延时只会影响此Message在MessageQueue // 中的位置 new Thread(new Runnable() { @Override public void run() { handler.postDelayed(new Runnable() { @Override public void run() { Log.i(\u0026#34;aaaa\u0026#34;, \u0026#34;MainThread\u0026#34;); } }, 10000); } }).start(); } private class MessageThread extends Thread { private int what; private String text; private long delay; public MessageThread(int what, String text, long delay) { this.what = what; this.text = text; this.delay = delay; } @Override public void run() { Message message = Message.obtain(); message.what = what; message.obj = text; handler.sendMessageDelayed(message, delay); } } log结果为\nThread 1: thread 1 oooooo Thread 2: thread 2 yyyyyy Thread 0: thread 0 hahaha MainThread 2. AsyncTask 通过Handler实现的多线程通信在使用上还是有很多不方便的地方，比如需要显示的创建子线程，每次创建子线程都是对资源的消耗，当然也可以使用线程池来减少线程资源的创建与销毁，同时需要定义Handler的处理方式，对于每一个需要处理消息的线程都需要定义其Handler，这样就显得比较乱，因此可以使用AsyncTask来替代，先看一下如何使用。\n2.1 AsyncTask简单使用 // 依然以请求和风天气数据为例，现在我们为加载数据时显示进度，为什么要显示进度呢 // 从设计理念来看，当我们给某些需要长时间等待的操作加上进度条时，用户对这个操作的 // 容忍度会增加，比如常见的进入游戏的界面，会显示进度条，这样的话就算耗时相对较长， // 但是用户可以根据进度有一个心理预期，从而提升容忍度；如果你的耗时操作没有任何进度 // 提示，那么用户很容易觉得你的应用是不是卡死了，从而降低了体验 public class MainActivity extends AppCompatActivity { private static final String KEY = \u0026#34;XXXXXXXXXXXX\u0026#34;; private static final String URL = \u0026#34;https://free-api.heweather.net/s6/weather/\u0026#34;; private TextView textView; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); textView = findViewById(R.id.textView); MyTask task = new MyTask(); // execute的参数等价于doInBackground的参数 task.execute(\u0026#34;beijing\u0026#34;, 50L); } // AsyncTask是抽象类，需要自定义Task并实现doInBackground方法，除了doInBackground之外 // 还有几个方法用于初始化、显示进度、输出结果等功能，三个参数Object, Integer, WeatherEntity为泛型参数 private class MyTask extends AsyncTask\u0026lt;Object, Integer, WeatherEntity\u0026gt; { // onPreExecute在主线程执行，用于做一些提前的初始化 @Override protected void onPreExecute() { textView.setText(\u0026#34;Start!!\u0026#34;); } // doInBackground在子线程执行，不需要显示地创建Thread，这里的参数params // 是一个泛型参数，也就是说可以传入多个参数，相当于参数数组，参数的传入是 // task.execute传入，返回值由AsyncTask第三个泛型参数决定，同时也是 // onPostExecute的输入参数 @Override protected WeatherEntity doInBackground(Object... params) { // 根据传入的顺序读取，location就是beijing，delay就是50L， // 为了模拟进度，这里传入一个延时，正式使用时需要根据数据实际传输的进度 // 展示进度 String location = (String) params[0]; long delay = (long) params[1]; WeatherEntity result = null; try { // 先获取数据，我们知道这里取数据的速度其实是很快的 result = getData(location); } catch (IOException e) { e.printStackTrace(); } // 然后显示进度，这里仅模拟 try { int count = 0; int length = 1; while (count \u0026lt; 99) { count += length; // 可调用publishProgress（）显示进度, 之后将执行onProgressUpdate（） publishProgress(count); // 模拟耗时任务 Thread.sleep(delay); } } catch (InterruptedException e) { e.printStackTrace(); } // 最后返回取到的数据 return result; } // onProgressUpdate在主线程执行，显示进度 @Override protected void onProgressUpdate(Integer... values) { textView.setText(String.format(Locale.CHINA, \u0026#34;加载进度：%d%%\u0026#34;, values[0])); } // onPostExecute在主线程执行，用于处理doInBackground返回的数据 @Override protected void onPostExecute(WeatherEntity weatherEntity) { textView.setText(weatherEntity.toString()); } // AsyncTask可以通过调用isCancelled主动终止 @Override protected void onCancelled() { textView.setText(\u0026#34;Cancel!!!\u0026#34;); } private WeatherEntity getData(String location) throws IOException { Retrofit retrofit = new Retrofit.Builder() .baseUrl(URL) .addConverterFactory(GsonConverterFactory.create()) .build(); Api api = retrofit.create(Api.class); Call\u0026lt;WeatherEntity\u0026gt; call = api.getNowWeather(location, KEY); return call.execute().body(); } } } 2.2 AsyncTask源码分析 首先从task.execute开始\n// AsyncTask.java @MainThread public final AsyncTask\u0026lt;Params, Progress, Result\u0026gt; execute(Params... params) { // executeOnExecutor传入两个参数sDefaultExecutor和params， // sDefaultExecutor看名字就知道是一个Executor，Executor提供execute方法， // 用于消耗Runnable，我们先看看sDefaultExecutor是什么 return executeOnExecutor(sDefaultExecutor, params); } // sDefaultExecutor实际上是new SerialExecutor()，static修饰加上 // synchronized修饰execute方法，保证多个Task启动execute时是按照顺序执行的 private static class SerialExecutor implements Executor { // SerialExecutor提供一个队列mTasks用于保存Runnable // mActive表示当前需要执行的Runnable final ArrayDeque\u0026lt;Runnable\u0026gt; mTasks = new ArrayDeque\u0026lt;Runnable\u0026gt;(); Runnable mActive; // execute方法把传入的Runnable加入到队列中，但是不是直接加入的， // 而是通过new Runnable改造了，让其在执行了run之后会执行scheduleNext public synchronized void execute(final Runnable r) { mTasks.offer(new Runnable() { public void run() { try { r.run(); } finally { scheduleNext(); } } }); if (mActive == null) { scheduleNext(); } } // scheduleNext从mTasks的对头取Runnable，通过THREAD_POOL_EXECUTOR // 执行Runnable，联系SerialExecutor的execute方法，就知道了一旦调用了 // SerialExecutor的execute方法，就会不断从mTasks取任务，然后交给线程池 // THREAD_POOL_EXECUTOR去执行，至于线程池是如何execute暂时不解释， // 只需要知道线程池会分配空闲的线程并执行传入的mFuture的run方法即可 protected synchronized void scheduleNext() { if ((mActive = mTasks.poll()) != null) { THREAD_POOL_EXECUTOR.execute(mActive); } } } // THREAD_POOL_EXECUTOR就是传说中的线程池，THREAD_POOL_EXECUTOR.execute // 会自动使用线程池中空闲的线程完成mActive的任务 /** * An {@link Executor} that can be used to execute tasks in parallel. */ public static final Executor THREAD_POOL_EXECUTOR; static { ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor( CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE_SECONDS, TimeUnit.SECONDS, sPoolWorkQueue, sThreadFactory); threadPoolExecutor.allowCoreThreadTimeOut(true); THREAD_POOL_EXECUTOR = threadPoolExecutor; } // 明白了sDefaultExecutor本质上是线程池，接下来看executeOnExecutor怎么调用线程池 @MainThread public final AsyncTask\u0026lt;Params, Progress, Result\u0026gt; executeOnExecutor(Executor exec, Params... params) { if (mStatus != Status.PENDING) { switch (mStatus) { case RUNNING: throw new IllegalStateException(\u0026#34;Cannot execute task:\u0026#34; + \u0026#34; the task is already running.\u0026#34;); case FINISHED: throw new IllegalStateException(\u0026#34;Cannot execute task:\u0026#34; + \u0026#34; the task has already been executed \u0026#34; + \u0026#34;(a task can be executed only once)\u0026#34;); } } // 首先设置了状态为RUNNING mStatus = Status.RUNNING; // 这里是不是很熟悉，我们继承AsyncTask时重写的onPreExecute方法 onPreExecute(); // 然后将参数保存在mWorker.mParams mWorker.mParams = params; // 调用exec.execute，这里的exec就是上面的SerialExecutor exec.execute(mFuture); return this; } // 此时我们需要明白mWorker和mFuture是什么，这里就要了解子类继承父类时，构造方法的执行了 // 在我们MyTask task = new MyTask();时，其实完成了父类的无参构造方法的执行，也就是AsyncTask // 的无参构造方法 /** * Creates a new asynchronous task. This constructor must be invoked on the UI thread. */ public AsyncTask() { this((Looper) null); } // 也就是说mWorker和mFuture在new MyTask()时已经完成了初始化 public AsyncTask(@Nullable Looper callbackLooper) { // callbackLooper为null，所以mHandler为getMainHandler方法的返回值， // 看名字就知道返回的是主线程的Handler，但是这个Handler有点东西 mHandler = callbackLooper == null || callbackLooper == Looper.getMainLooper() ? getMainHandler() : new Handler(callbackLooper); // mWorker提供了一个对象WorkerRunnable，WorkerRunnable实现了Callable接口的call方法 // 当mWorker的call方法被执行时，我们就可以得到结果 mWorker = new WorkerRunnable\u0026lt;Params, Result\u0026gt;() { public Result call() throws Exception { mTaskInvoked.set(true); Result result = null; try { Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND); //noinspection unchecked // 很熟悉的doInBackground方法，传入的参数为mWorker的mParams，即我们 // 在task.execute(\u0026#34;beijing\u0026#34;, 50L);传入的参数 result = doInBackground(mParams); Binder.flushPendingCommands(); } catch (Throwable tr) { mCancelled.set(true); throw tr; } finally { postResult(result); } return result; } }; // mFuture以mWorker为参数实现了FutureTask，这里的FutureTask可以被SerialExecutor execute， // 会调用FutureTask的run方法，run方法中会执行mWorker的call方法，最终会调用FutureTask的done方法 mFuture = new FutureTask\u0026lt;Result\u0026gt;(mWorker) { @Override protected void done() { try { // get方法得到的是FutureTask执行run方法后得到的result postResultIfNotInvoked(get()); } catch (InterruptedException e) { android.util.Log.w(LOG_TAG, e); } catch (ExecutionException e) { throw new RuntimeException(\u0026#34;An error occurred while executing doInBackground()\u0026#34;, e.getCause()); } catch (CancellationException e) { postResultIfNotInvoked(null); } } }; } // postResultIfNotInvoked会进一步处理结果 private void postResultIfNotInvoked(Result result) { final boolean wasTaskInvoked = mTaskInvoked.get(); if (!wasTaskInvoked) { postResult(result); } } // postResult通过主线程的Handler发送了数据result，并标记MESSAGE_POST_RESULT // 表示数据已经获取完毕，应该交给主线程处理 private Result postResult(Result result) { @SuppressWarnings(\u0026#34;unchecked\u0026#34;) Message message = getHandler().obtainMessage(MESSAGE_POST_RESULT, new AsyncTaskResult\u0026lt;Result\u0026gt;(this, result)); message.sendToTarget(); return result; } // 还是记得上文介绍的Handler吗，它还有额外的功能 private static class InternalHandler extends Handler { public InternalHandler(Looper looper) { super(looper); } @SuppressWarnings({\u0026#34;unchecked\u0026#34;, \u0026#34;RawUseOfParameterizedType\u0026#34;}) @Override public void handleMessage(Message msg) { // 在处理Message时，还可以判断并选择执行onProgressUpdate AsyncTaskResult\u0026lt;?\u0026gt; result = (AsyncTaskResult\u0026lt;?\u0026gt;) msg.obj; switch (msg.what) { // 上面说的数据获取完毕会标记MESSAGE_POST_RESULT case MESSAGE_POST_RESULT: // There is only one result // 调用mTask，这里就是AsyncTask的finish方法 result.mTask.finish(result.mData[0]); break; case MESSAGE_POST_PROGRESS: result.mTask.onProgressUpdate(result.mData); break; } } } // 熟悉的重写isCancelled和onPostExecute private void finish(Result result) { if (isCancelled()) { // 如果主动调用isCancelled则走onCancelled onCancelled(result); } else { // 或者最终回到我们重写的onPostExecute onPostExecute(result); } mStatus = Status.FINISHED; } // 以上就是正常的AsyncTask执行流程，但是别忘了我们有一个进度显示的功能 @WorkerThread protected final void publishProgress(Progress... values) { if (!isCancelled()) { // 通过Handler发送进度数据values // 这里就对应了上面的主线程的Handler的另一个功能，显示进度 getHandler().obtainMessage(MESSAGE_POST_PROGRESS, new AsyncTaskResult\u0026lt;Progress\u0026gt;(this, values)).sendToTarget(); } } 整理一下流程，很显然的是AsyncTask本质上还是基于Handler，但是在对线程的处理上采用了线程池，具体的执行过程：\n在new MyTask()时初始化了主线程的Handler和线程池，构造了FutureTask并提供了doInBackground的回调，并提供了通过sendToTarget的方式处理result和progress的方式； 当我们执行task.execute(\u0026quot;beijing\u0026quot;, 50L);的方法时，提供了onPreExecute的回调，并将参数传给第1步中的FutureTask，然后使用SerialExecutor execute第1步构造的的FutureTask，本质上还是线程池，只是附加了功能：连续处理队列中的所有任务； 最后将得到结果通过上面sendToTarget后Handler的回调handleMessage处理发送的数据 仔细思考一下就会发现，AsyncTask提供了一个显示进度的方法，比较适用于上传下载文件的场景，因为下载进度与下载文件的大小是可知的，但是很多http框架比如Retrofit，可以很方便在接受Response的时候监听下载进度，导致AsyncTask无用武之处；同时对于登录注册功能来说，登录进度并不是很适合量化，所以也不适用；还有其他的场景我暂时也没有想到。这就导致了AsyncTask的作用被弱化了，除了集成doInBackground和onPostExecute方法就没有什么亮眼之处。\nAsyncTask也提供了带Looper或者Handler参数的构造函数，此时会影响的只有postResult和publishProgress方法，即这两个方法会发送消息到Looper的线程中，但是子线程的Handler需要自定义handleMessage并自行判断msg.what，包括MESSAGE_POST_RESULT和MESSAGE_POST_PROGRESS，实现从子线程到子线程的消息传递。\n3. EventBus EventBus比上面介绍的两种方式更加强大，除了线程间通信之外，还可以在Activity间传递消息，同时兼具灵活的线程切换功能，先直接上一个简单的例子，依然是请求和风天气数据\n1.首先使用EventBus需要自定义MessageEvent，即通过EventBus传递的消息载体\npublic class MessageEvent { private Object msg; public MessageEvent(Object msg) { this.msg = msg; } public Object getMsg() { return msg; } public void setMsg(Object msg) { this.msg = msg; } @Override public String toString() { return \u0026#34;MessageEvent{\u0026#34; + \u0026#34;msg=\u0026#34; + msg + \u0026#39;}\u0026#39;; } } 2.在需要处理消息的地方（Activity）中定义Subscribe方法，这个方法可以自动接收其他地方传来的消息\n// Subscribe注解修饰处理MessageEvent的方法，有几个参数threadMode、sticky、priority /** 首先是threadMode： POSTING：默认，表示事件处理函数的线程跟发布事件的线程在同一个线程。 MAIN：表示事件处理函数的线程在主线程(UI)线程，因此在这里不能进行耗时操作。 BACKGROUND：表示事件处理函数的线程在后台线程，因此不能进行UI操作。 如果发布事件的线程是主线程(UI线程)，那么事件处理函数将会开启一个后台线程， 如果果发布事件的线程是在后台线程，那么事件处理函数就使用该线程。 ASYNC：表示无论事件发布的线程是哪一个，事件处理函数始终会新建一个子线程运行，同样不能进行UI操作。 然后是sticky，sticky用于表示是否接收粘性事件 最后是priority，priority决定不同的Subscribe方法接收事件的优先级，数值越大越早接收， 先接受的Subscribe方法还可以禁止事件继续传递下去 1. 只有当两个订阅方法使用相同的ThreadMode参数的时候，它们的优先级才会与priority指定的值一致； 2. 只有当某个订阅方法的ThreadMode参数为POSTING的时候，它才能停止该事件的继续分发。 **/ // requestData方法用于处理发送的消息是String，其他则打印log @Subscribe(threadMode = ThreadMode.BACKGROUND) public void requestData(MessageEvent message) { if (message.getMsg() instanceof String) { Retrofit retrofit = new Retrofit.Builder() .baseUrl(URL) .addConverterFactory(GsonConverterFactory.create()) .build(); Api api = retrofit.create(Api.class); Call\u0026lt;WeatherEntity\u0026gt; call = api.getNowWeather(message.getMsg().toString(), KEY); try { // 通过EventBus把请求得到的天气发送出去 EventBus.getDefault().post(new MessageEvent(call.execute().body())); } catch (IOException e) { e.printStackTrace(); } } else if (message.getMsg() instanceof WeatherEntity) { Log.i(\u0026#34;aaaa\u0026#34;, \u0026#34;ThreadMode.BACKGROUND: \u0026#34; + message.getMsg().toString()); } } // showMessage方法用于处理发送的消息是WeatherEntity，将其显示到TextView上，其他类型则打印log @Subscribe(threadMode = ThreadMode.MAIN) public void showMessage(MessageEvent message) { if (message.getMsg() instanceof WeatherEntity) { textView.setText(message.getMsg().toString()); } else if (message.getMsg() instanceof String) { Log.i(\u0026#34;aaaa\u0026#34;, \u0026#34;ThreadMode.MAIN: \u0026#34; + message.getMsg().toString()); } } 3.在onStart和onStop中注册和取消注册\n@Override protected void onStart() { EventBus.getDefault().register(this); super.onStart(); } @Override protected void onStop() { EventBus.getDefault().unregister(this); super.onStop(); } 4.发送消息\n@Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); textView = findViewById(R.id.textView); textView.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { // 发送的消息本体是String，即请求的location EventBus.getDefault().post(new MessageEvent(\u0026#34;beijing\u0026#34;)); } }); } 当我们点击textView的时候就会发送消息new MessageEvent(\u0026quot;beijing\u0026quot;)出去，如果打断点观察消息发送的流程就会清楚：\n我们在主线程发送的消息会首先由ThreadMode.MAIN的方法处理，此时就会打印log： 然后消息会发送到requestData方法，而requestData方法是ThreadMode.BACKGROUND，所以它会在子线程中执行，我们在子线程中又发了new MessageEvent(call.execute().body())，因此消息会首先由ThreadMode.BACKGROUND的方法处理，即requestData方法自身，此时打印log； 最后消息又传到了showMessage方法中，而showMessage方法是ThreadMode.MAIN，所以可以执行在主线程，因此textView被设置了text，整个消息传递流程结束。 根据上面的例子基本可以了解了EventBus发送消息的机制，类似于广播，不同的threadMode参数决定这个方法的执行线程，而消息发送时会首先发到当前线程的方法中，如果在这个方法中消息没有被取消，则会继续广播到其他线程的方法中，具体顺序可以测试一下，直到没有可以处理此消息的方法，整个消息传播的流程就结束了。\n// 以下列方法处理从主线程发送的MessageEvent，我们观察一下log的顺序 @Subscribe(threadMode = ThreadMode.MAIN) public void broadcastMessage1(MessageEvent message) { Log.i(\u0026#34;aaaa\u0026#34;, \u0026#34;ThreadMode.MAIN: \u0026#34; + message.getMsg().toString()); } @Subscribe(threadMode = ThreadMode.BACKGROUND) public void broadcastMessage2(MessageEvent message) { Log.i(\u0026#34;aaaa\u0026#34;, \u0026#34;ThreadMode.BACKGROUND: \u0026#34; + message.getMsg().toString()); } @Subscribe(threadMode = ThreadMode.POSTING) public void broadcastMessage3(MessageEvent message) { Log.i(\u0026#34;aaaa\u0026#34;, \u0026#34;ThreadMode.POSTING: \u0026#34; + message.getMsg().toString()); } @Subscribe(threadMode = ThreadMode.ASYNC) public void broadcastMessage4(MessageEvent message) { Log.i(\u0026#34;aaaa\u0026#34;, \u0026#34;ThreadMode.ASYNC: \u0026#34; + message.getMsg().toString()); } 依次是MAIN -\u0026gt; POSTING -\u0026gt; BACKGROUND -\u0026gt; ASYNC\n2019-07-28 20:40:38.419 28604-28604/com.example.gsondemo I/aaaa: ThreadMode.MAIN: beijing 2019-07-28 20:40:38.420 28604-28604/com.example.gsondemo I/aaaa: ThreadMode.POSTING: beijing 2019-07-28 20:40:38.421 28604-28765/com.example.gsondemo I/aaaa: ThreadMode.BACKGROUND: beijing 2019-07-28 20:40:38.422 28604-28766/com.example.gsondemo I/aaaa: ThreadMode.ASYNC: beijing 在看一下从BACKGROUND子线程发送的MessageEvent，依次是BACKGROUND -\u0026gt; POSTING -\u0026gt; MAIN -\u0026gt; ASYNC\n2019-07-28 20:53:27.151 30433-30481/com.example.gsondemo I/aaaa: ThreadMode.BACKGROUND: shanghai 2019-07-28 20:53:27.151 30433-30481/com.example.gsondemo I/aaaa: ThreadMode.POSTING: shanghai 2019-07-28 20:53:27.152 30433-30433/com.example.gsondemo I/aaaa: ThreadMode.MAIN: shanghai 2019-07-28 20:53:27.152 30433-30482/com.example.gsondemo I/aaaa: ThreadMode.ASYNC: shanghai 消息广播的规则应该是首先是发送到post所在的线程，然后是POSTING，然后是其他线程，最后是ASYNC，因此我们可以在POSTING方法中取消消息的广播，那么消息就会被中断。\n普通事件删除 EventBus.getDefault().cancelEventDelivery(event); 粘性事件删除 //指定粘性事件删除 T stickyEvent = EventBus.getDefault().getStickyEvent(eventType); if (stickyEvent != null) { EventBus.getDefault().removeStickyEvent(stickyEvent); } //删除所有粘性事件 EventBus.getDefault().removeAllStickyEvents(); 除了普通事件之外，EventBus还可以发送粘性事件，解释起来比较复杂，简而言之就是让消息“飞一会”，在我们主动注册时才处理消息，用代码来解释\n// 代码是类似的，只是这次不在onStart方法内注册，而是通过button点击注册 @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); textView = findViewById(R.id.textView); button = findViewById(R.id.button); textView.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { // postSticky替代post EventBus.getDefault().postSticky(new MessageEvent(\u0026#34;beijing\u0026#34;)); } }); button.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { EventBus.getDefault().register(MainActivity.this); } }); } // 增加sticky = true @Subscribe(threadMode = ThreadMode.BACKGROUND, sticky = true) public void requestData(MessageEvent message) { if (message.getMsg() instanceof String) { Retrofit retrofit = new Retrofit.Builder() .baseUrl(URL) .addConverterFactory(GsonConverterFactory.create()) .build(); Api api = retrofit.create(Api.class); Call\u0026lt;WeatherEntity\u0026gt; call = api.getNowWeather(message.getMsg().toString(), KEY); try { EventBus.getDefault().post(new MessageEvent(call.execute().body())); } catch (IOException e) { e.printStackTrace(); } } else if (message.getMsg() instanceof WeatherEntity) { Log.i(\u0026#34;aaaa\u0026#34;, \u0026#34;ThreadMode.BACKGROUND: \u0026#34; + message.getMsg().toString()); } } // 增加sticky = true @Subscribe(threadMode = ThreadMode.MAIN, sticky = true) public void showMessage(MessageEvent message) { if (message.getMsg() instanceof WeatherEntity) { textView.setText(message.getMsg().toString()); } else if (message.getMsg() instanceof String) { Log.i(\u0026#34;aaaa\u0026#34;, \u0026#34;ThreadMode.MAIN: \u0026#34; + message.getMsg().toString()); } } @Override protected void onStart() { super.onStart(); } @Override protected void onStop() { EventBus.getDefault().unregister(this); super.onStop(); } 这样的结果就是当我们点击textView时，事件就会发出，但是Subscribe方法没有接收，当且仅当我们点击了button时，事件才开始被接收，即我们让消息在运行时“飞了一会”，消息并不会丢失，当我们主动去注册时才开始处理，这就是粘性事件。\npriority就不详细解释了，对于有相同threadMode的方法，priority值越大越先接收到消息。\nEventBus源码解析暂时留个坑。\n4. RxJava RxJava – Reactive Extensions for the JVM – a library for composing asynchronous and event-based programs using observable sequences for the Java VM.\nRxJava也是一个可以用于处理线程间通信的工具，但是功能非常强大（不仅限于线程间通信），不仅可以用于Java Web项目也可以在Android项目中使用，RxJava的使用方式与上述各种工具或者框架不太一样，它是通过流式调用的形式使用的。目前有三个版本分别是Version 1.x、Version 2.x以及最新的Version 3.x，新版本加入新的特性比如背压、Java 8等等，这里仅演示RxJava2\nimplementation \u0026#34;io.reactivex.rxjava2:rxjava:2.2.8\u0026#34; // 必要rxjava2依赖 implementation \u0026#34;io.reactivex.rxjava2:rxandroid:2.1.0\u0026#34; // 必要rxandrroid依赖，切线程时需要用到AndroidSchedulers.mainThread() 4.1 RxJava结合Retrofit 还是以请求和风天气数据为例，这是Retrofit与RxJava的结合使用，RxJava使用的是观察者模式，这里就不详细解释\nRetrofit retrofit = new Retrofit.Builder() .baseUrl(URL) .addConverterFactory(GsonConverterFactory.create()) .addCallAdapterFactory(RxJava2CallAdapterFactory.create()) .build(); Api api = retrofit.create(Api.class); // 这里的getNowWeather方法在Api.java中返回的是Observable api.getNowWeather(\u0026#34;beijing\u0026#34;, KEY) .subscribeOn(Schedulers.io()) // subscribeOn参数为io线程，表明getNowWeather请求数据执行在io线程 .observeOn(AndroidSchedulers.mainThread()) // observeOn参数为主线程，表明请求结束传递的数据在主线程处理 .subscribe(new Consumer\u0026lt;WeatherEntity\u0026gt;() { // subscribe定义上面observeOn进行的方法，RxJava2中以Consumer代理处理，一般来说有两个Consumer，一个用于处理请求成功的数据，另一个处理异常 @Override public void accept(WeatherEntity weatherEntity) throws Exception { textView.setText(weatherEntity.toString()); } }, new Consumer\u0026lt;Throwable\u0026gt;() { @Override public void accept(Throwable throwable) throws Exception { Log.i(\u0026#34;aaaa\u0026#34;, throwable.getMessage()); } }); 4.2 RxJava源码分析 虽然上面的代码只演示了RxJava的线程切换功能，但是实际上RxJava的功能非常强大，在处理大量数据的情况下能够更加简洁有效的代码完成，同时兼具数据变换的功能，这里三言两语很难表述清除，需要实战演练就能够明白，与此同时，基于RxJava我们也可以自定义更多的工具函数，以RxJava流式调用的方式来使用。\nObservable警告：RxJava提供的各种方法比如subscribeOn、observeOn以及doOnNext等都会创建新的Observable和Observer，Observable是数据的被观察者，它保存了我们需要的数据；Observer是数据的观察者，数据如何发送、在哪个线程处理、如何处理异常等都是通过Observer处理的，一般来说每一个自定义的Observable都有一个内部类Observer，只是这个Observer是给上一级的Observable调用\n首先我们需要知道retrofit.create(Api.class)创建了什么，这个在Retrofit框架分析中已经做过了，在这种情况下是通过RxJava2CallAdapterFactory的RxJava2CallAdapter调用adapt方法返回的Observable\n// RxJava2CallAdapter.java @Override public Object adapt(Call\u0026lt;R\u0026gt; call) { // 首先是创建CallExecuteObservable Observable\u0026lt;Response\u0026lt;R\u0026gt;\u0026gt; responseObservable = isAsync ? new CallEnqueueObservable\u0026lt;\u0026gt;(call) : new CallExecuteObservable\u0026lt;\u0026gt;(call); Observable\u0026lt;?\u0026gt; observable; if (isResult) { observable = new ResultObservable\u0026lt;\u0026gt;(responseObservable); } else if (isBody) { // 然后根据参数，返回的是BodyObservable observable = new BodyObservable\u0026lt;\u0026gt;(responseObservable); } else { observable = responseObservable; } if (scheduler != null) { observable = observable.subscribeOn(scheduler); } if (isFlowable) { return observable.toFlowable(BackpressureStrategy.LATEST); } if (isSingle) { return observable.singleOrError(); } if (isMaybe) { return observable.singleElement(); } if (isCompletable) { return observable.ignoreElements(); } return RxJavaPlugins.onAssembly(observable); } 而BodyObservable继承自Observable，并且有一个内部类BodyObserver\n// BodyObservable.java final class BodyObservable\u0026lt;T\u0026gt; extends Observable\u0026lt;T\u0026gt; { private final Observable\u0026lt;Response\u0026lt;T\u0026gt;\u0026gt; upstream; BodyObservable(Observable\u0026lt;Response\u0026lt;T\u0026gt;\u0026gt; upstream) { this.upstream = upstream; } // subscribeActual方法会在Observable调用subscribe方法时被调用 @Override protected void subscribeActual(Observer\u0026lt;? super T\u0026gt; observer) { upstream.subscribe(new BodyObserver\u0026lt;T\u0026gt;(observer)); } private static class BodyObserver\u0026lt;R\u0026gt; implements Observer\u0026lt;Response\u0026lt;R\u0026gt;\u0026gt; { private final Observer\u0026lt;? super R\u0026gt; observer; private boolean terminated; BodyObserver(Observer\u0026lt;? super R\u0026gt; observer) { this.observer = observer; } // BodyObserver实现了Observer的4个方法onSubscribe、onNext、onComplete、onError， // 但是不是BodyObserver自己完成的，而是通过传入的observer代替完成大部分功能，而BodyObserver // 只对传过来的Response进行简单判断就交给observer了 @Override public void onSubscribe(Disposable disposable) { observer.onSubscribe(disposable); } @Override public void onNext(Response\u0026lt;R\u0026gt; response) { if (response.isSuccessful()) { // 比如判断response是否是成功从服务器返回的，然后交给observer的onNext方法， // 此时传给observer的就是response的body了，对应我们使用的GsonConverterFactory， // 那这个body就是WeatherEntity实例 observer.onNext(response.body()); } else { terminated = true; Throwable t = new HttpException(response); try { observer.onError(t); } catch (Throwable inner) { Exceptions.throwIfFatal(inner); RxJavaPlugins.onError(new CompositeException(t, inner)); } } } @Override public void onComplete() { if (!terminated) { observer.onComplete(); } } @Override public void onError(Throwable throwable) { if (!terminated) { observer.onError(throwable); } else { // This should never happen! onNext handles and forwards errors automatically. Throwable broken = new AssertionError( \u0026#34;This should never happen! Report as a bug with the full stacktrace.\u0026#34;); //noinspection UnnecessaryInitCause Two-arg AssertionError constructor is 1.7+ only. broken.initCause(throwable); RxJavaPlugins.onError(broken); } } } } 创建完Observable后紧接着是subscribeOn、observeOn以及subscribe方法，很显然这些方法都是Observable的方法\n// Observable.java @CheckReturnValue @SchedulerSupport(SchedulerSupport.CUSTOM) public final Observable\u0026lt;T\u0026gt; subscribeOn(Scheduler scheduler) { ObjectHelper.requireNonNull(scheduler, \u0026#34;scheduler is null\u0026#34;); return RxJavaPlugins.onAssembly(new ObservableSubscribeOn\u0026lt;T\u0026gt;(this, scheduler)); } // Observable.java @NonNull public static \u0026lt;T\u0026gt; Observable\u0026lt;T\u0026gt; onAssembly(@NonNull Observable\u0026lt;T\u0026gt; source) { // 一般来说onObservableAssembly在没有调用reset方法的情况下为空，所以这里肯定为空 Function\u0026lt;? super Observable, ? extends Observable\u0026gt; f = onObservableAssembly; if (f != null) { return apply(f, source); } // 也就是说这个onAssembly方法直接返回了source，所以上面的subscribeOn方法返回的是ObservableSubscribeOn return source; } subscribeOn方法之后我们得到了一个新的ObservableSubscribeOn，它保存了BodyObservable以及加入的参数Schedulers.io()，接下来继续调用observeOn\n// Observable.java @CheckReturnValue @SchedulerSupport(SchedulerSupport.CUSTOM) public final Observable\u0026lt;T\u0026gt; observeOn(Scheduler scheduler) { return observeOn(scheduler, false, bufferSize()); } @CheckReturnValue @SchedulerSupport(SchedulerSupport.CUSTOM) public final Observable\u0026lt;T\u0026gt; observeOn(Scheduler scheduler, boolean delayError, int bufferSize) { ObjectHelper.requireNonNull(scheduler, \u0026#34;scheduler is null\u0026#34;); ObjectHelper.verifyPositive(bufferSize, \u0026#34;bufferSize\u0026#34;); // observeOn显然又返回了一个ObservableObserveOn return RxJavaPlugins.onAssembly(new ObservableObserveOn\u0026lt;T\u0026gt;(this, scheduler, delayError, bufferSize)); } observeOn方法之后我们得到了新的ObservableObserveOn，它保存了ObservableSubscribeOn以及参数AndroidSchedulers.mainThread()，最后调用subscribe方法\n// Observable.java @CheckReturnValue @SchedulerSupport(SchedulerSupport.NONE) public final Disposable subscribe(Consumer\u0026lt;? super T\u0026gt; onNext, Consumer\u0026lt;? super Throwable\u0026gt; onError) { // subscribe方法可以接受多种参数，比如我这里对应上面的两个Consumer参数，其中第一个Consumer名字是onNext， // 第二个Consumer名字是onError，看到这里基本上明白了这两个Consumer的功能，就是执行处理onNext传入的数据以及处理 // onError传入的异常 return subscribe(onNext, onError, Functions.EMPTY_ACTION, Functions.emptyConsumer()); } @CheckReturnValue @SchedulerSupport(SchedulerSupport.NONE) public final Disposable subscribe(Consumer\u0026lt;? super T\u0026gt; onNext, Consumer\u0026lt;? super Throwable\u0026gt; onError, Action onComplete, Consumer\u0026lt;? super Disposable\u0026gt; onSubscribe) { ObjectHelper.requireNonNull(onNext, \u0026#34;onNext is null\u0026#34;); ObjectHelper.requireNonNull(onError, \u0026#34;onError is null\u0026#34;); ObjectHelper.requireNonNull(onComplete, \u0026#34;onComplete is null\u0026#34;); ObjectHelper.requireNonNull(onSubscribe, \u0026#34;onSubscribe is null\u0026#34;); // 然后对onNext、onError、onComplete、onSubscribe四个Consumer进行封装， // 整合成一个LambdaObserver，也就是说，本质上我们subscribe的参数最终还是Observer LambdaObserver\u0026lt;T\u0026gt; ls = new LambdaObserver\u0026lt;T\u0026gt;(onNext, onError, onComplete, onSubscribe); subscribe(ls); return ls; } @SchedulerSupport(SchedulerSupport.NONE) @Override public final void subscribe(Observer\u0026lt;? super T\u0026gt; observer) { ObjectHelper.requireNonNull(observer, \u0026#34;observer is null\u0026#34;); try { // RxJavaPlugins.onSubscribe类似上面的onAssembly方法，这里没有做任何操作 // 等价于observer = observer observer = RxJavaPlugins.onSubscribe(this, observer); ObjectHelper.requireNonNull(observer, \u0026#34;The RxJavaPlugins.onSubscribe hook returned a null Observer. Please change the handler provided to RxJavaPlugins.setOnObservableSubscribe for invalid null returns. Further reading: https://github.com/ReactiveX/RxJava/wiki/Plugins\u0026#34;); // 然后调用subscribeActual，要知道ObservableObserveOn中重写了subscribeActual方法，所以我们再回到 // ObservableObserveOn中，需要记住的是这个observer保存了我们定义的两个Consumer subscribeActual(observer); } catch (NullPointerException e) { // NOPMD throw e; } catch (Throwable e) { Exceptions.throwIfFatal(e); // can\u0026#39;t call onError because no way to know if a Disposable has been set or not // can\u0026#39;t call onSubscribe because the call might have set a Subscription already RxJavaPlugins.onError(e); NullPointerException npe = new NullPointerException(\u0026#34;Actually not, but can\u0026#39;t throw other exceptions due to RS\u0026#34;); npe.initCause(e); throw npe; } } 前面的构造Observable的顺序是：CallExecuteObservable -\u0026gt; BodyObservable -\u0026gt; ObservableSubscribeOn -\u0026gt; ObservableObserveOn，每一级Observable都是以上一级Observable作为参数够早的，CallExecuteObservable和BodyObservable是没有设置Scheduler参数的，ObservableSubscribeOn和ObservableObserveOn有Scheduler参数，Scheduler参数决定了Observer执行的线程；当我们调用subscribe方法会自底向上依次调用Observable的subscribeActual方法，在调用subscribeActual方法是会调用上一级的subscribe方法，传入的参数就是Observer，Observer的构造顺序是：自定义Consumer -\u0026gt; LambdaObserver -\u0026gt; ObserveOnObserver -\u0026gt; SubscribeOnObserver -\u0026gt; BodyObserver，最顶层的CallExecuteObservable是没有Observer的，每一级的Observer都会以下一级的Observer作为参数\n// ObservableObserveOn.java @Override protected void subscribeActual(Observer\u0026lt;? super T\u0026gt; observer) { // source就是ObservableObserveOn构造时传入的第一个参数，对应ObservableSubscribeOn， // 由于scheduler对应AndroidSchedulers.mainThread()，本质上是HandlerScheduler if (scheduler instanceof TrampolineScheduler) { source.subscribe(observer); } else { // 调用的是HandlerScheduler的createWorker方法,返回的是HandlerWorker， // HandlerWorker保存了两个参数，一个是Handler，另一个bool async， // 因为AndroidSchedulers.mainThread()，所以此处的Handler是new Handler(Looper.getMainLooper())， // 即主线程中的Handler，async为false Scheduler.Worker w = scheduler.createWorker(); // 构造新的ObserveOnObserver，传入的参数有LambdaObserver和HandlerWorker // 然后调用ObservableSubscribeOn的subscribe方法，这是一个递归调用，subscribe就是上面的， // 又因为subscribeActual，所以还是调用ObservableSubscribeOn的subscribeActual方法 source.subscribe(new ObserveOnObserver\u0026lt;T\u0026gt;(observer, w, delayError, bufferSize)); } } 当我们走到了ObservableSubscribeOn的subscribeActual方法时，需要开始使用observer（上一级Observable的内部类Observer）进行预处理或者发送数据，因为RxJava的onSubscribe是最先被调用的，所以我们需要先调用onSubscribe方法，会依次向上调用Observer的onSubscribe方法，由于Observer保存了如何发送数据的方法onNext以及处理异常的方法onError以及表示已完成的onComplete，所以如果传到最上级的Observable，那么就可以在CallExecuteObservable的subscribeActual方法中调用传入的Observer的各种方法，从而对数据进行发送、处理等\n// ObservableSubscribeOn.java @Override public void subscribeActual(final Observer\u0026lt;? super T\u0026gt; observer) { // observer是上面构造的ObserveOnObserver，将其转换为SubscribeOnObserver // 将上一级传进来的订阅者包装为线程安全的原子变量 final SubscribeOnObserver\u0026lt;T\u0026gt; parent = new SubscribeOnObserver\u0026lt;T\u0026gt;(observer); // 然后调用ObserveOnObserver的onSubscribe，调用onSubscribe即开始预处理，onSubscribe会调用 // 我们定义的Consumer（本示例未使用onSubscribe的Consumer，所以没有做任何操作） observer.onSubscribe(parent); // ObservableSubscribeOn的scheduler对应Schedulers.io()，即IoScheduler // SubscribeTask会被放在BlockingQueue队列中，这里就是开始执行我们实际请求的关键转折了， // 之前都是铺垫，然后在指定的线程中执行source(上一级)的subscribe，即IO线程的工作 // source.subscribe(parent)，这里的source实际就是BodyObservable parent.setDisposable(scheduler.scheduleDirect(new SubscribeTask(parent))); } final class SubscribeTask implements Runnable { private final SubscribeOnObserver\u0026lt;T\u0026gt; parent; SubscribeTask(SubscribeOnObserver\u0026lt;T\u0026gt; parent) { this.parent = parent; } @Override public void run() { // 这里的source是BodyObservable source.subscribe(parent); } } scheduler的作用就是通过内部Worker将task交给线程池进行处理，因为ObservableSubscribeOn是通过调用subscribeOn方法生成的，因此很大程度上会运行在其他线程，也就是说SubscribeTask的run方法是执行在Worker的线程池中，即从现在开始的subscribe都是在Worker线程中而不是主线程了\n// Scheduler.java @NonNull public Disposable scheduleDirect(@NonNull Runnable run) { return scheduleDirect(run, 0L, TimeUnit.NANOSECONDS); } @NonNull public Disposable scheduleDirect(@NonNull Runnable run, long delay, @NonNull TimeUnit unit) { // 这个createWorker就是IoScheduler的createWorker，返回的是EventLoopWorker，此EventLoopWorker // 运行的线程通过线程池CachedWorkerPool提供 final Worker w = createWorker(); final Runnable decoratedRun = RxJavaPlugins.onSchedule(run); DisposeTask task = new DisposeTask(decoratedRun, w); // w.schedule会在ScheduledThreadPoolExecutor中安排task被执行，task会被放在队列中 w.schedule(task, delay, unit); return task; } 在看BodyObservable的subscribe方法前先看一下onSubscribe做了些什么\n// ObservableObserveOn.java 内部类ObserveOnObserver的onSubscribe方法 @Override public void onSubscribe(Disposable d) { if (DisposableHelper.validate(this.upstream, d)) { this.upstream = d; // 这里的d是SubscribeOnObserver，所以跳过 if (d instanceof QueueDisposable) { @SuppressWarnings(\u0026#34;unchecked\u0026#34;) QueueDisposable\u0026lt;T\u0026gt; qd = (QueueDisposable\u0026lt;T\u0026gt;) d; int m = qd.requestFusion(QueueDisposable.ANY | QueueDisposable.BOUNDARY); if (m == QueueDisposable.SYNC) { sourceMode = m; queue = qd; done = true; downstream.onSubscribe(this); schedule(); return; } if (m == QueueDisposable.ASYNC) { sourceMode = m; queue = qd; downstream.onSubscribe(this); return; } } // 这个队列用于保存数据，之后会用，bufferSize大小默认是128 queue = new SpscLinkedArrayQueue\u0026lt;T\u0026gt;(bufferSize); // 而downstream是ObserveOnObserver构造函数的第一个参数，即我们调用subscribe方法时 // 传入的LambdaObserver（但是通过Consumer实现的） downstream.onSubscribe(this); } } // LambdaObserver.java @Override public void onSubscribe(Disposable d) { if (DisposableHelper.setOnce(this, d)) { try { // onSubscribe也只是调用onSubscribe.accept，还记得上面我们的LambdaObserver构造时仅使用了 // onNext和onError，所以onSubscribe其实是空的，这里没有任何作用 onSubscribe.accept(this); } catch (Throwable ex) { Exceptions.throwIfFatal(ex); d.dispose(); onError(ex); } } } 回到subscribe的调用链，在子线程（线程池）\n// BodyObservable.java @Override protected void subscribeActual(Observer\u0026lt;? super T\u0026gt; observer) { // 这里的upstream是CallExecuteObservable upstream.subscribe(new BodyObserver\u0026lt;T\u0026gt;(observer)); } 通过subscribe最终调用到了最顶层的Observable的subscribeActual方法，且传入的下一级的内部类Observer，用于提供onXXX方法传递数据，执行在子线程（线程池）\n// CallExecuteObservable.java @Override protected void subscribeActual(Observer\u0026lt;? super Response\u0026lt;T\u0026gt;\u0026gt; observer) { // Since Call is a one-shot type, clone it for each new observer. Call\u0026lt;T\u0026gt; call = originalCall.clone(); CallDisposable disposable = new CallDisposable(call); // CallExecuteObservable是我们实际开始调用Retrofit请求数据的开始 // 首先需要调用observer的onSubscribe，这里是BodyObserver， // 还记得上面的LambdaObserver的onSubscribe， // 这里其实什么事情都没有做 observer.onSubscribe(disposable); if (disposable.isDisposed()) { return; } boolean terminated = false; try { // 然后调用call.execute()，如果记得Retrofit，那么就知道这里发出了请求，也就是说这个方法执行在IO线程 Response\u0026lt;T\u0026gt; response = call.execute(); if (!disposable.isDisposed()) { // 然后通过onNext方法将结果发射出去，这个observer就是BodyObserver observer.onNext(response); } if (!disposable.isDisposed()) { terminated = true; observer.onComplete(); } } catch (Throwable t) { Exceptions.throwIfFatal(t); if (terminated) { RxJavaPlugins.onError(t); } else if (!disposable.isDisposed()) { try { observer.onError(t); } catch (Throwable inner) { Exceptions.throwIfFatal(inner); RxJavaPlugins.onError(new CompositeException(t, inner)); } } } } onNext方法的向下一级传递\n// BodyObservable.java 内部类BodyObserver的onNext方法 @Override public void onNext(Response\u0026lt;R\u0026gt; response) { if (response.isSuccessful()) { // BodyObserver判断了一下请求结果response，然后将body发射出去 // 这里的observer就是SubscribeOnObserver observer.onNext(response.body()); } else { terminated = true; Throwable t = new HttpException(response); try { observer.onError(t); } catch (Throwable inner) { Exceptions.throwIfFatal(inner); RxJavaPlugins.onError(new CompositeException(t, inner)); } } } // ObservableSubscribeOn.java 内部类SubscribeOnObserver @Override public void onNext(T t) { // 这里的downstream是ObserveOnObserver downstream.onNext(t); } 这里因为ObservableObserveOn是通过observeOn创建的，而这里发生了线程切换，我们的例子中是主线程，所以需要通过Handler将后续的任务切换到主线程中\n// ObservableObserveOn.java 内部类ObserveOnObserver @Override public void onNext(T t) { if (done) { return; } if (sourceMode != QueueDisposable.ASYNC) { // 这里的queue是SpscLinkedArrayQueue，我们把传出来的数据保存在队列中了 queue.offer(t); } // 最终调用schedule schedule(); } void schedule() { if (getAndIncrement() == 0) { // worker是初始化时调用observeOn传入的主线程的HandlerScheduler的内部类HandlerWorker， // 这里的schedule方法传入this，即ObserveOnObserver，与此同时ObserveOnObserver // 实现了Runnable的接口，可以作为Runnable，它的run方法会在下面被执行 worker.schedule(this); } } // HandlerScheduler.java 内部类HandlerWorker @Override @SuppressLint(\u0026#34;NewApi\u0026#34;) // Async will only be true when the API is available to call. public Disposable schedule(Runnable run, long delay, TimeUnit unit) { if (run == null) throw new NullPointerException(\u0026#34;run == null\u0026#34;); if (unit == null) throw new NullPointerException(\u0026#34;unit == null\u0026#34;); if (disposed) { return Disposables.disposed(); } run = RxJavaPlugins.onSchedule(run); // HandlerWorker的schedule方法，我们传入的run即上面的ObserveOnObserver // ScheduledRunnable也是Runnable，但是它的run方法仅仅是调用了传入的run的run方法 // 也就是说如果我们执行了scheduled的run方法等价于执行了run的方法，也就是 // ObserveOnObserver的run方法 ScheduledRunnable scheduled = new ScheduledRunnable(handler, run); // scheduled的run方法执行是通过handler处理的，通过sendMessageDelayed实现的 Message message = Message.obtain(handler, scheduled); message.obj = this; // Used as token for batch disposal of this worker\u0026#39;s runnables. if (async) { message.setAsynchronous(true); } // 也就是在这里我们将在主线程执行ObserveOnObserver的run方法 handler.sendMessageDelayed(message, unit.toMillis(delay)); // Re-check disposed state for removing in case we were racing a call to dispose(). if (disposed) { handler.removeCallbacks(scheduled); return Disposables.disposed(); } return scheduled; } // ObservableObserveOn.java 内部类ObserveOnObserver @Override public void run() { if (outputFused) { drainFused(); } else { // 这里执行的是drainNormal drainNormal(); } } void drainNormal() { int missed = 1; // 还记得上面的SpscLinkedArrayQueue，之前我们在onNext方法中把传过来的数据保存在队列中 // 接下来需要从队列中取出数据 final SimpleQueue\u0026lt;T\u0026gt; q = queue; // downstream即LambdaObserver final Observer\u0026lt;? super T\u0026gt; a = downstream; // 这里用循环是因为RxJava支持连续发送多个数据，那么最终数据都保存在队列中 // 所以取数据的时候就可以通过循环来一次性获取队列中的所有数据，而SpscLinkedArrayQueue // 的最大容量，根据之前的代码我们知道是128 for (;;) { if (checkTerminated(done, q.isEmpty(), a)) { return; } for (;;) { boolean d = done; T v; try { // q.poll从队列中取出数据 v = q.poll(); } catch (Throwable ex) { Exceptions.throwIfFatal(ex); disposed = true; upstream.dispose(); q.clear(); a.onError(ex); worker.dispose(); return; } boolean empty = v == null; if (checkTerminated(d, empty, a)) { return; } if (empty) { break; } // a即为LambdaObserver，v为我们从队列中取出来的数据，也是 // 我们通过handler传入的数据，通过onNext发出，而这个onNext // 就是我们定义的第一个Consumer，通过这个Consumer的accept方法 // 在主线程实现TextView的设置 a.onNext(v); } missed = addAndGet(-missed); if (missed == 0) { break; } } } // LambdaObserver.java @Override public void onNext(T t) { if (!isDisposed()) { try { // 我们定义的Consumer的accept方法 onNext.accept(t); } catch (Throwable e) { Exceptions.throwIfFatal(e); get().dispose(); onError(e); } } } 综上，RxJava的简单源码分析流程就完成了，整个RxJava调用流程可以分为两个阶段：构造阶段和subscribe阶段，在调用subscribe方法前的步骤我称之为构造阶段，这个过程中主要工作是创建被观察者Observable，每一次使用RxJava的方法时都会创建新的Observable，每个新的Observable都会以上一级的Observable作为参数，其中部分Observable还需要Scheduler参数，用于切换线程，构造阶段仅仅是将Observable连接起来；在调用subscribe方法时开始了subscribe阶段，这个阶段的任务是将我们自定义的Consumer（或者可以当作观察者Observer）通过Observable的subscribe方法连接起来（subscribe的过程中可能会调用onSubscribe方法进行预处理，初始化一些队列什么的，onSubscribe方法与onNext、onError、onComplete方法有点区别），当我们的subscribe方法走到最顶层时会开始启动Observer的onXXX方法传递数据或者传出异常等等，因为之前已经将Observer连接起来，所以此时onXXX方法的调用也是链式的，层层向下传递，直到调用我们自定义的Consumer（在此过程中会通过在构造阶段传入的Scheduler实现线程切换）。\n如果完整的看过一遍分析流程就会发现其实Observable和Observer的调用链是很简单的，但是随之也有几个疑问：\n1.为什么要用Observable和Observer的形式？\n首先需要明白的是，RxJava的目的是提供一个便于进行数据处理的框架，通过流式调用实现线程切换、数据类型转换等，也就是说数据从A -\u0026gt; B -\u0026gt; C可以是不同类型的数据或者是在不同线程处理，最适合的模式就是观察者模式，比如我们常见的OnClickListener，它传递的是点击事件，再比如我们自定义的传递数据的接口回调，都是观察者模式。简而言之就是，A通过B提供的接口将数据传到B中进行处理，B通过C提供的接口将数传到C中进行处理，由此可以进行数据的传递，当然这只是数据传递的流程，具体的调用流程就是上面的总结。使用Observable和Observer的形式，一是便于我们自定义数据转换的Observable和Observer，二是可以实现流式调用，三是这里面实现了这种接口回调的功能。\n2.subscribeOn和observeOn是如何切换线程的？\nsubscribeOn会指定我们在调用subscribeOn之前的Observable中数据处理的线程，observeOn会指定我们在调用observeOn之后的Observable中数据处理的线程。这是因为两者切换线程的位置不同，subscribeOn会在subscribeActual的方法中切换线程，导致后续所有的调用都是在subscribeOn指定的线程中，而subscribeActual方法是自底向上调用的，因此会影响subscribeOn之前的所有方法；而observeOn是在ObserveOnObserver的onNext方法中进行线程切换的，因此会影响observeOn后面数据传递的方法。\n参考： RxJava2 EventBus Android Handler 消息机制详述 Android 多线程：手把手教你使用AsyncTask EventBus使用详解 Rxjava这一篇就够了，墙裂推荐 精彩的RxJava源码剖析 给 Android 开发者的 RxJava 详解 ","permalink":"https://zhoutao822.github.io/posts/rxjava/","summary":"Android中很多地方都需要跨线程通信，这是由于Android主线程不允许进行复杂的网络请求或者其他非常耗时的操作，否则会导致ANR，主线程只能进行UI操作，比如修改某个控件的text、设置某个控件不可见等等，因此网络请求等操作需要在其他线程中完成，当数据在其他线程中获取完毕时，通过跨线程通信将数据传到主线程中，主线程就可以直接根据数据进行UI操作。常见的跨线程通信的方式有Handler、AsyncTask、EventBus以及RxJava等，前两个是Android自带，后两者是封装好的第三方库。","title":"Android框架-RxJava"},{"content":"Snackbar是类似与Toast的一种信息提示控件，但是与Toast不同的是Snackbar是从界面底部弹出的且支持一个点击事件，默认情况下Snackbar内部有两个子控件分别是TextView和Button，两者水平排列，TextView用于显示信息，Button用于实现点击事件。\n1. Snackbar使用 Snackbar属于Material组件中的一种，如果你的应用使用了Material Theme以及AppCompatActivity，则Snackbar会获得圆角、四周有margin空隙的效果。\n默认情况下使用Snackbar，调用的方式也非常类似Toast\n// view是当前页面内的某个view，根据源码可知，make方法会找view的父view， // 直到父view是FrameLayout或者CoordinateLayout，然后将其作为root给inflate方法调用 // inflate会加载默认的布局文件，这里根据是否使用Material Theme会加载不同的布局文件， // 即上文我提到的效果，与此同时会将text的内容赋给布局文件中的TextView， // 如果父view是CoordinateLayout，则Snackbar还支持右滑取消的功能， // Snackbar.LENGTH_SHORT就类似于Toast.LENGTH_SHORT用于控制Snackbar的持续时间 Snackbar snackbar = Snackbar.make(view, text, Snackbar.LENGTH_SHORT); snackbar.show(); 2. Snackbar自定义Content 显然原生的Snackbar没有提供setContentView的方法，为了能够自定义Snackbar的布局，我们需要对Snackbar的一些参数进行修改，比如如果我们需要自定义Snackbar的margin以及自定义Snackbar的内容\npublic class SnackbarUtil { private int duration; private View anchor; private ViewGroup customView; private int sideMargin; private int bottomMargin; private Snackbar delegete; /** * SnackbarUtil is used to create Snackbar, if you setEnableCustom(false) or in default * you will get the origin Snackbar from Snackbar.make(anchor, text, duration); if you * setEnableCustom(true) in Builder, you must add your defined customView and you can * modify the margin of the customView in Snackbar. * * Your customView\u0026#39;s layout should container 2 layer of Layout, because there is some * UI bug if you just only use 1 layer * * \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; * \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; * android:layout_width=\u0026#34;match_parent\u0026#34; * android:layout_height=\u0026#34;match_parent\u0026#34;\u0026gt; * * \u0026lt;LinearLayout * android:layout_width=\u0026#34;match_parent\u0026#34; * android:layout_height=\u0026#34;wrap_content\u0026#34; * android:background=\u0026#34;@drawable/radius_background\u0026#34; * android:orientation=\u0026#34;vertical\u0026#34;\u0026gt; * * \u0026lt;TextView * android:layout_width=\u0026#34;wrap_content\u0026#34; * android:layout_height=\u0026#34;wrap_content\u0026#34; * android:layout_gravity=\u0026#34;center\u0026#34; * android:padding=\u0026#34;8dp\u0026#34; * android:id=\u0026#34;@+id/textView\u0026#34; * android:text=\u0026#34;hahahahh\u0026#34; * android:textColor=\u0026#34;@color/colorPrimaryDark\u0026#34; * android:textSize=\u0026#34;24sp\u0026#34; /\u0026gt; * \u0026lt;/LinearLayout\u0026gt; * \u0026lt;/LinearLayout\u0026gt; * * Usage: * * snackView is your customView, layout_snackbar is the layout above. * button is the anchor view, if your button is in CoordinatorLayout * the snackbar can be dismissed with swipe action. * * ViewGroup snackView = (ViewGroup) LayoutInflater.from(MainActivity.this).inflate( * R.layout.layout_snackbar, * new LinearLayout(MainActivity.this), * false); * * TextView textView = snackView.findViewById(R.id.textView); * textView.setOnClickListener(new View.OnClickListener() { * * @param duration Snackbar duration, default Snackbar.LENGTH_SHORT; * @param anchor must need, with anchor the Snackbar will find its root; * @param customView must need if setEnableCustom(true) in Builder; * @param sideMargin customView left and right margin in Snackbar; * @param bottomMargin customView bottom margin in Snackbar; * @Override public void onClick(View v) { * Toast.makeText(MainActivity.this, \u0026#34;12121\u0026#34;, Toast.LENGTH_LONG).show(); * } * }); * Snackbar snackbar = new SnackbarUtil.Builder() * .setAnchor(button) * .setBottomMargin(80) * .setDuration(Snackbar.LENGTH_SHORT) * .setText(\u0026#34;32323\u0026#34;) * .setCustomView(snackView) * .setSideMargin(20) * .build(); * snackbar.show(); */ SnackbarUtil(int duration, View anchor, ViewGroup customView, int sideMargin, int bottomMargin) { this.duration = duration; this.anchor = anchor; this.customView = customView; this.sideMargin = sideMargin; this.bottomMargin = bottomMargin; this.delegete = Snackbar.make(anchor, \u0026#34;\u0026#34;, duration); } private Snackbar create() { // 通过getView获取Snackbar的layout Snackbar.SnackbarLayout layout = (Snackbar.SnackbarLayout) delegete.getView(); // 为了自定义margin，这里需要将Snackbar的背景设置为透明，textView可以设置为INVISIBLE也可以不设置 // 只要没有在make加入text即可 layout.setBackgroundColor(Color.TRANSPARENT); TextView textView = layout.findViewById(com.google.android.material.R.id.snackbar_text); textView.setVisibility(View.INVISIBLE); // customView为我们传入的自定义view，自定义view是如何调用inflate可以参考注释， // 但是customView必须包含两层layout这是因为UI上有bug，具体可以自行测试， // 所以我们实际设置的margin是第2层layout的margin，第2层layout有背景色， // 所以最终呈现出Snackbar有margin的效果，但是要知道实际上Snackbar的布局 // 还是占据了整个底部空间 View childLayout = customView.getChildAt(0); final ViewGroup.MarginLayoutParams params = (ViewGroup.MarginLayoutParams) childLayout.getLayoutParams(); // MarginLayoutParams设置margin params.setMargins(params.leftMargin + sideMargin, params.topMargin, params.rightMargin + sideMargin, params.bottomMargin + bottomMargin); childLayout.setLayoutParams(params); // Add the view to the Snackbar\u0026#39;s layout layout.addView(customView, 0); // Show the Snackbar return delegete; } // 由于参数较多，所以采用建造者模式 public static final class Builder { private boolean enableCustom; private String text; private int duration; private View anchor; private ViewGroup customView; private int sideMargin; private int bottomMargin; Builder(boolean enableCustom) { this.enableCustom = enableCustom; this.duration = Snackbar.LENGTH_SHORT; this.text = \u0026#34;\u0026#34;; this.sideMargin = 0; this.bottomMargin = 0; } public Builder() { this(false); } public Builder setEnableCustom(boolean enableCustom) { this.enableCustom = enableCustom; return this; } public Builder setText(String text) { this.text = text; return this; } public Builder setDuration(int duration) { this.duration = duration; return this; } public Builder setAnchor(View anchor) { this.anchor = anchor; return this; } public Builder setCustomView(ViewGroup customView) { this.customView = customView; return this; } public Builder setSideMargin(int sideMargin) { this.sideMargin = sideMargin; return this; } public Builder setBottomMargin(int bottomMargin) { this.bottomMargin = bottomMargin; return this; } public Snackbar build() { // 通过enableCustom控制是否使用自定义Content，自定义Content的点击事件需要 // 在Snackbar的外面处理 if (!enableCustom) { return Snackbar.make(anchor, text, duration); } if (anchor == null) { throw new IllegalArgumentException( \u0026#34;No suitable parent found from the given view. Please provide a valid view.\u0026#34;); } if (customView == null) { throw new IllegalArgumentException( \u0026#34;No custom view found. Please provide a valid view or setEnableCustom(false).\u0026#34;); } return new SnackbarUtil(duration, anchor, customView, sideMargin, bottomMargin).create(); } } } 最终效果\n参考： MATERIAL DESIGN ","permalink":"https://zhoutao822.github.io/posts/snackbar/","summary":"Snackbar是类似与Toast的一种信息提示控件，但是与Toast不同的是Snackbar是从界面底部弹出的且支持一个点击事件，默认情况下Snackbar内部有两个子控件分别是TextView和Button，两者水平排列，TextView用于显示信息，Button用于实现点击事件。","title":"Material组件-Snackbar"},{"content":"json是一种数据格式，类似与键值对的形式，常用于服务器与客户端之间数据传输，以键值对形式传输的数据在客户端进行解析时必然需要对不同的key寻找其对应的value，通常来说这种解析数据的过程非常繁琐，但是没有难度，所以Google推出了Gson这个工具，用于解析json数据并直接将其实例化。\n1. Gson使用 以解析和风天气的数据为例，请求返回的json数据如下\n{ \u0026#34;HeWeather6\u0026#34;: [ { \u0026#34;basic\u0026#34;: { \u0026#34;cid\u0026#34;: \u0026#34;CN101010100\u0026#34;, \u0026#34;location\u0026#34;: \u0026#34;北京\u0026#34;, \u0026#34;parent_city\u0026#34;: \u0026#34;北京\u0026#34;, \u0026#34;admin_area\u0026#34;: \u0026#34;北京\u0026#34;, \u0026#34;cnty\u0026#34;: \u0026#34;中国\u0026#34;, \u0026#34;lat\u0026#34;: \u0026#34;39.90498734\u0026#34;, \u0026#34;lon\u0026#34;: \u0026#34;116.4052887\u0026#34;, \u0026#34;tz\u0026#34;: \u0026#34;+8.00\u0026#34; }, \u0026#34;update\u0026#34;: { \u0026#34;loc\u0026#34;: \u0026#34;2019-07-18 16:45\u0026#34;, \u0026#34;utc\u0026#34;: \u0026#34;2019-07-18 08:45\u0026#34; }, \u0026#34;status\u0026#34;: \u0026#34;ok\u0026#34;, \u0026#34;now\u0026#34;: { \u0026#34;cloud\u0026#34;: \u0026#34;10\u0026#34;, \u0026#34;cond_code\u0026#34;: \u0026#34;101\u0026#34;, \u0026#34;cond_txt\u0026#34;: \u0026#34;多云\u0026#34;, \u0026#34;fl\u0026#34;: \u0026#34;35\u0026#34;, \u0026#34;hum\u0026#34;: \u0026#34;54\u0026#34;, \u0026#34;pcpn\u0026#34;: \u0026#34;0.0\u0026#34;, \u0026#34;pres\u0026#34;: \u0026#34;1000\u0026#34;, \u0026#34;tmp\u0026#34;: \u0026#34;32\u0026#34;, \u0026#34;vis\u0026#34;: \u0026#34;6\u0026#34;, \u0026#34;wind_deg\u0026#34;: \u0026#34;279\u0026#34;, \u0026#34;wind_dir\u0026#34;: \u0026#34;西风\u0026#34;, \u0026#34;wind_sc\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;wind_spd\u0026#34;: \u0026#34;3\u0026#34; } } ] } 1.构造对应json数据的实体类，这里使用的Android Studio的插件GsonFormat，可以直接根据json数据生成代码\npublic class WeatherEntity { private List\u0026lt;HeWeather6Bean\u0026gt; HeWeather6; public List\u0026lt;HeWeather6Bean\u0026gt; getHeWeather6() { return HeWeather6; } public void setHeWeather6(List\u0026lt;HeWeather6Bean\u0026gt; HeWeather6) { this.HeWeather6 = HeWeather6; } // 重写以下toString方法，便于后续观察数据传输是否正确 @NonNull @Override public String toString() { return HeWeather6.get(0).toString(); } public static class HeWeather6Bean { /** * basic : {\u0026#34;cid\u0026#34;:\u0026#34;CN101010100\u0026#34;,\u0026#34;location\u0026#34;:\u0026#34;北京\u0026#34;,\u0026#34;parent_city\u0026#34;:\u0026#34;北京\u0026#34;,\u0026#34;admin_area\u0026#34;:\u0026#34;北京\u0026#34;,\u0026#34;cnty\u0026#34;:\u0026#34;中国\u0026#34;,\u0026#34;lat\u0026#34;:\u0026#34;39.90498734\u0026#34;,\u0026#34;lon\u0026#34;:\u0026#34;116.4052887\u0026#34;,\u0026#34;tz\u0026#34;:\u0026#34;+8.00\u0026#34;} * update : {\u0026#34;loc\u0026#34;:\u0026#34;2019-07-18 16:45\u0026#34;,\u0026#34;utc\u0026#34;:\u0026#34;2019-07-18 08:45\u0026#34;} * status : ok * now : {\u0026#34;cloud\u0026#34;:\u0026#34;10\u0026#34;,\u0026#34;cond_code\u0026#34;:\u0026#34;101\u0026#34;,\u0026#34;cond_txt\u0026#34;:\u0026#34;多云\u0026#34;,\u0026#34;fl\u0026#34;:\u0026#34;35\u0026#34;,\u0026#34;hum\u0026#34;:\u0026#34;54\u0026#34;,\u0026#34;pcpn\u0026#34;:\u0026#34;0.0\u0026#34;,\u0026#34;pres\u0026#34;:\u0026#34;1000\u0026#34;,\u0026#34;tmp\u0026#34;:\u0026#34;32\u0026#34;,\u0026#34;vis\u0026#34;:\u0026#34;6\u0026#34;,\u0026#34;wind_deg\u0026#34;:\u0026#34;279\u0026#34;,\u0026#34;wind_dir\u0026#34;:\u0026#34;西风\u0026#34;,\u0026#34;wind_sc\u0026#34;:\u0026#34;1\u0026#34;,\u0026#34;wind_spd\u0026#34;:\u0026#34;3\u0026#34;} */ private BasicBean basic; private UpdateBean update; private String status; private NowBean now; @NonNull @Override public String toString() { return status + \u0026#34; \\n \u0026#34; + basic.toString() + \u0026#34; \\n \u0026#34; + update.toString() + \u0026#34; \\n \u0026#34; + now.toString(); } public BasicBean getBasic() { return basic; } public void setBasic(BasicBean basic) { this.basic = basic; } public UpdateBean getUpdate() { return update; } public void setUpdate(UpdateBean update) { this.update = update; } public String getStatus() { return status; } public void setStatus(String status) { this.status = status; } public NowBean getNow() { return now; } public void setNow(NowBean now) { this.now = now; } public static class BasicBean { /** * cid : CN101010100 * location : 北京 * parent_city : 北京 * admin_area : 北京 * cnty : 中国 * lat : 39.90498734 * lon : 116.4052887 * tz : +8.00 */ private String cid; private String location; private String parent_city; private String admin_area; private String cnty; private String lat; private String lon; private String tz; @NonNull @Override public String toString() { return \u0026#34;cid : \u0026#34; + cid + \u0026#34;\\n\u0026#34; + \u0026#34;location : \u0026#34; + location + \u0026#34;\\n\u0026#34; + \u0026#34;parent_city : \u0026#34; + parent_city + \u0026#34;\\n\u0026#34; + \u0026#34;admin_area : \u0026#34; + admin_area + \u0026#34;\\n\u0026#34; + \u0026#34;cnty : \u0026#34; + cnty + \u0026#34;\\n\u0026#34; + \u0026#34;lat : \u0026#34; + lat + \u0026#34;\\n\u0026#34; + \u0026#34;lon : \u0026#34; + lon + \u0026#34;\\n\u0026#34; + \u0026#34;tz : \u0026#34; + tz + \u0026#34;\\n\u0026#34;; } public String getCid() { return cid; } public void setCid(String cid) { this.cid = cid; } public String getLocation() { return location; } public void setLocation(String location) { this.location = location; } public String getParent_city() { return parent_city; } public void setParent_city(String parent_city) { this.parent_city = parent_city; } public String getAdmin_area() { return admin_area; } public void setAdmin_area(String admin_area) { this.admin_area = admin_area; } public String getCnty() { return cnty; } public void setCnty(String cnty) { this.cnty = cnty; } public String getLat() { return lat; } public void setLat(String lat) { this.lat = lat; } public String getLon() { return lon; } public void setLon(String lon) { this.lon = lon; } public String getTz() { return tz; } public void setTz(String tz) { this.tz = tz; } } public static class UpdateBean { /** * loc : 2019-07-18 16:45 * utc : 2019-07-18 08:45 */ private String loc; private String utc; @NonNull @Override public String toString() { return \u0026#34;loc : \u0026#34; + loc + \u0026#34;\\n\u0026#34; + \u0026#34;utc : \u0026#34; + utc + \u0026#34;\\n\u0026#34;; } public String getLoc() { return loc; } public void setLoc(String loc) { this.loc = loc; } public String getUtc() { return utc; } public void setUtc(String utc) { this.utc = utc; } } public static class NowBean { /** * cloud : 10 * cond_code : 101 * cond_txt : 多云 * fl : 35 * hum : 54 * pcpn : 0.0 * pres : 1000 * tmp : 32 * vis : 6 * wind_deg : 279 * wind_dir : 西风 * wind_sc : 1 * wind_spd : 3 */ private String cloud; private String cond_code; private String cond_txt; private String fl; private String hum; private String pcpn; private String pres; private String tmp; private String vis; private String wind_deg; private String wind_dir; private String wind_sc; private String wind_spd; @NonNull @Override public String toString() { return \u0026#34;cloud : \u0026#34; + cloud + \u0026#34;\\n\u0026#34; + \u0026#34;cond_code : \u0026#34; + cond_code + \u0026#34;\\n\u0026#34; + \u0026#34;cond_txt : \u0026#34; + cond_txt + \u0026#34;\\n\u0026#34; + \u0026#34;fl : \u0026#34; + fl + \u0026#34;\\n\u0026#34; + \u0026#34;hum : \u0026#34; + hum + \u0026#34;\\n\u0026#34; + \u0026#34;pcpn : \u0026#34; + pcpn + \u0026#34;\\n\u0026#34; + \u0026#34;pres : \u0026#34; + pres + \u0026#34;\\n\u0026#34; + \u0026#34;tmp : \u0026#34; + tmp + \u0026#34;\\n\u0026#34; + \u0026#34;vis : \u0026#34; + vis + \u0026#34;\\n\u0026#34; + \u0026#34;wind_deg : \u0026#34; + wind_deg + \u0026#34;\\n\u0026#34; + \u0026#34;wind_dir : \u0026#34; + wind_dir + \u0026#34;\\n\u0026#34; + \u0026#34;wind_sc : \u0026#34; + wind_sc + \u0026#34;\\n\u0026#34; + \u0026#34;wind_spd : \u0026#34; + wind_spd + \u0026#34;\\n\u0026#34;; } public String getCloud() { return cloud; } public void setCloud(String cloud) { this.cloud = cloud; } public String getCond_code() { return cond_code; } public void setCond_code(String cond_code) { this.cond_code = cond_code; } public String getCond_txt() { return cond_txt; } public void setCond_txt(String cond_txt) { this.cond_txt = cond_txt; } public String getFl() { return fl; } public void setFl(String fl) { this.fl = fl; } public String getHum() { return hum; } public void setHum(String hum) { this.hum = hum; } public String getPcpn() { return pcpn; } public void setPcpn(String pcpn) { this.pcpn = pcpn; } public String getPres() { return pres; } public void setPres(String pres) { this.pres = pres; } public String getTmp() { return tmp; } public void setTmp(String tmp) { this.tmp = tmp; } public String getVis() { return vis; } public void setVis(String vis) { this.vis = vis; } public String getWind_deg() { return wind_deg; } public void setWind_deg(String wind_deg) { this.wind_deg = wind_deg; } public String getWind_dir() { return wind_dir; } public void setWind_dir(String wind_dir) { this.wind_dir = wind_dir; } public String getWind_sc() { return wind_sc; } public void setWind_sc(String wind_sc) { this.wind_sc = wind_sc; } public String getWind_spd() { return wind_spd; } public void setWind_spd(String wind_spd) { this.wind_spd = wind_spd; } } } } 2.使用OkHttp构造请求\nOkHttpClient client = new OkHttpClient(); Request request = new Request.Builder() .get() .url(baseUrl) .build(); Call call = client.newCall(request); call.enqueue(new Callback() { @Override public void onFailure(@NotNull Call call, @NotNull IOException e) { } @Override public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException { } }); 3.在onResponse方法中处理请求，使用Gson对response的json数据进行实例化\n@Override public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException { final String ret = response.body().string(); runOnUiThread(new Runnable() { @Override public void run() { Gson gson = new Gson(); WeatherEntity weatherEntity = gson.fromJson(ret, WeatherEntity.class); textView.setText(weatherEntity.toString()); } }); } 只要对比一下就知道了，从ret到weatherEntity，完成了对json数据的实例化，我们不需要new一个对象再通过set方法赋值就可以得到一个实例，最后直接使用此实例即可。\n2. Gson源码分析 首先new了一个Gson对象\npublic Gson() { this(Excluder.DEFAULT, FieldNamingPolicy.IDENTITY, Collections.\u0026lt;Type, InstanceCreator\u0026lt;?\u0026gt;\u0026gt;emptyMap(), DEFAULT_SERIALIZE_NULLS, DEFAULT_COMPLEX_MAP_KEYS, DEFAULT_JSON_NON_EXECUTABLE, DEFAULT_ESCAPE_HTML, DEFAULT_PRETTY_PRINT, DEFAULT_LENIENT, DEFAULT_SPECIALIZE_FLOAT_VALUES, LongSerializationPolicy.DEFAULT, null, DateFormat.DEFAULT, DateFormat.DEFAULT, Collections.\u0026lt;TypeAdapterFactory\u0026gt;emptyList(), Collections.\u0026lt;TypeAdapterFactory\u0026gt;emptyList(), Collections.\u0026lt;TypeAdapterFactory\u0026gt;emptyList()); } // 这里很明显，比较重要的类是TypeAdapterFactory，作用稍后再说 Gson(final Excluder excluder, final FieldNamingStrategy fieldNamingStrategy, final Map\u0026lt;Type, InstanceCreator\u0026lt;?\u0026gt;\u0026gt; instanceCreators, boolean serializeNulls, boolean complexMapKeySerialization, boolean generateNonExecutableGson, boolean htmlSafe, boolean prettyPrinting, boolean lenient, boolean serializeSpecialFloatingPointValues, LongSerializationPolicy longSerializationPolicy, String datePattern, int dateStyle, int timeStyle, List\u0026lt;TypeAdapterFactory\u0026gt; builderFactories, List\u0026lt;TypeAdapterFactory\u0026gt; builderHierarchyFactories, List\u0026lt;TypeAdapterFactory\u0026gt; factoriesToBeAdded) { this.excluder = excluder; this.fieldNamingStrategy = fieldNamingStrategy; this.instanceCreators = instanceCreators; this.constructorConstructor = new ConstructorConstructor(instanceCreators); this.serializeNulls = serializeNulls; this.complexMapKeySerialization = complexMapKeySerialization; this.generateNonExecutableJson = generateNonExecutableGson; this.htmlSafe = htmlSafe; this.prettyPrinting = prettyPrinting; this.lenient = lenient; this.serializeSpecialFloatingPointValues = serializeSpecialFloatingPointValues; this.longSerializationPolicy = longSerializationPolicy; this.datePattern = datePattern; this.dateStyle = dateStyle; this.timeStyle = timeStyle; this.builderFactories = builderFactories; this.builderHierarchyFactories = builderHierarchyFactories; List\u0026lt;TypeAdapterFactory\u0026gt; factories = new ArrayList\u0026lt;TypeAdapterFactory\u0026gt;(); // 内置的TypeAdapter，比如ObjectTypeAdapter用于处理Object类型数据 // built-in type adapters that cannot be overridden factories.add(TypeAdapters.JSON_ELEMENT_FACTORY); factories.add(ObjectTypeAdapter.FACTORY); // excluder用于控制属性的是否支持序列化与反序列化，比如用@Expose修饰的属性， // 优先级必须在所有TypeAdapter之前 // the excluder must precede all adapters that handle user-defined types factories.add(excluder); // 开发人员自定义的TypeAdapter，优先级相对较高 // users\u0026#39; type adapters factories.addAll(factoriesToBeAdded); // 基础类型数据，包括String、Integer等包装类型 // type adapters for basic platform types factories.add(TypeAdapters.STRING_FACTORY); factories.add(TypeAdapters.INTEGER_FACTORY); factories.add(TypeAdapters.BOOLEAN_FACTORY); factories.add(TypeAdapters.BYTE_FACTORY); factories.add(TypeAdapters.SHORT_FACTORY); TypeAdapter\u0026lt;Number\u0026gt; longAdapter = longAdapter(longSerializationPolicy); factories.add(TypeAdapters.newFactory(long.class, Long.class, longAdapter)); factories.add(TypeAdapters.newFactory(double.class, Double.class, doubleAdapter(serializeSpecialFloatingPointValues))); factories.add(TypeAdapters.newFactory(float.class, Float.class, floatAdapter(serializeSpecialFloatingPointValues))); factories.add(TypeAdapters.NUMBER_FACTORY); factories.add(TypeAdapters.ATOMIC_INTEGER_FACTORY); factories.add(TypeAdapters.ATOMIC_BOOLEAN_FACTORY); factories.add(TypeAdapters.newFactory(AtomicLong.class, atomicLongAdapter(longAdapter))); factories.add(TypeAdapters.newFactory(AtomicLongArray.class, atomicLongArrayAdapter(longAdapter))); factories.add(TypeAdapters.ATOMIC_INTEGER_ARRAY_FACTORY); factories.add(TypeAdapters.CHARACTER_FACTORY); factories.add(TypeAdapters.STRING_BUILDER_FACTORY); factories.add(TypeAdapters.STRING_BUFFER_FACTORY); factories.add(TypeAdapters.newFactory(BigDecimal.class, TypeAdapters.BIG_DECIMAL)); factories.add(TypeAdapters.newFactory(BigInteger.class, TypeAdapters.BIG_INTEGER)); factories.add(TypeAdapters.URL_FACTORY); factories.add(TypeAdapters.URI_FACTORY); factories.add(TypeAdapters.UUID_FACTORY); factories.add(TypeAdapters.CURRENCY_FACTORY); factories.add(TypeAdapters.LOCALE_FACTORY); factories.add(TypeAdapters.INET_ADDRESS_FACTORY); factories.add(TypeAdapters.BIT_SET_FACTORY); factories.add(DateTypeAdapter.FACTORY); factories.add(TypeAdapters.CALENDAR_FACTORY); factories.add(TimeTypeAdapter.FACTORY); factories.add(SqlDateTypeAdapter.FACTORY); factories.add(TypeAdapters.TIMESTAMP_FACTORY); factories.add(ArrayTypeAdapter.FACTORY); factories.add(TypeAdapters.CLASS_FACTORY); // 集合类型优先级较低，包括Map、Collection等 // type adapters for composite and user-defined types factories.add(new CollectionTypeAdapterFactory(constructorConstructor)); factories.add(new MapTypeAdapterFactory(constructorConstructor, complexMapKeySerialization)); this.jsonAdapterFactory = new JsonAdapterAnnotationTypeAdapterFactory(constructorConstructor); factories.add(jsonAdapterFactory); factories.add(TypeAdapters.ENUM_FACTORY); // 反射类型优先级最低，而这个反射类型就是我们自定义WeatherEntity的TypeAdapter factories.add(new ReflectiveTypeAdapterFactory( constructorConstructor, fieldNamingStrategy, excluder, jsonAdapterFactory)); this.factories = Collections.unmodifiableList(factories); } 然后直接看fromJson方法，传入的参数为String和.class，返回值为.class的实例\npublic \u0026lt;T\u0026gt; T fromJson(String json, Class\u0026lt;T\u0026gt; classOfT) throws JsonSyntaxException { // 此处只要分析fromJson方法 Object object = fromJson(json, (Type) classOfT); // wrap仅仅把基础类型转为包装类型，cast用于类型转换，把Object类型转为object的实际类型 return Primitives.wrap(classOfT).cast(object); } public \u0026lt;T\u0026gt; T fromJson(String json, Type typeOfT) throws JsonSyntaxException { if (json == null) { return null; } // 通过StringReader将String类型的json数据转为StringReader StringReader reader = new StringReader(json); // 又调用fromJson方法 T target = (T) fromJson(reader, typeOfT); return target; } public \u0026lt;T\u0026gt; T fromJson(Reader json, Type typeOfT) throws JsonIOException, JsonSyntaxException { // 又将StringReader转为JsonReader JsonReader jsonReader = newJsonReader(json); // 继续调用fromJson T object = (T) fromJson(jsonReader, typeOfT); assertFullConsumption(object, jsonReader); return object; } public \u0026lt;T\u0026gt; T fromJson(JsonReader reader, Type typeOfT) throws JsonIOException, JsonSyntaxException { boolean isEmpty = true; boolean oldLenient = reader.isLenient(); reader.setLenient(true); try { // 核心代码在try catch内，我们得到的JsonReader需要通过TypeAdapter的read方法转为Java对象 // 所以接下来需要分析JsonReader的功能，以及这里默认使用的TypeAdapter的功能 reader.peek(); isEmpty = false; TypeToken\u0026lt;T\u0026gt; typeToken = (TypeToken\u0026lt;T\u0026gt;) TypeToken.get(typeOfT); TypeAdapter\u0026lt;T\u0026gt; typeAdapter = getAdapter(typeToken); T object = typeAdapter.read(reader); return object; } catch (EOFException e) { /* * For compatibility with JSON 1.5 and earlier, we return null for empty * documents instead of throwing. */ if (isEmpty) { return null; } throw new JsonSyntaxException(e); } catch (IllegalStateException e) { throw new JsonSyntaxException(e); } catch (IOException e) { // TODO(inder): Figure out whether it is indeed right to rethrow this as JsonSyntaxException throw new JsonSyntaxException(e); } catch (AssertionError e) { throw new AssertionError(\u0026#34;AssertionError (GSON \u0026#34; + GsonBuildConfig.VERSION + \u0026#34;): \u0026#34; + e.getMessage(), e); } finally { reader.setLenient(oldLenient); } } JsonReader并不是直接通过String解析出来的，首先经过了StringReader，那么先看看StringReader的构造，StringReader继承自Reader，需要实现read方法，read方法一般是用于读取字符到buffer中\n// StringReader.java 这里只保存了String的值和长度 /** * Creates a new string reader. * * @param s String providing the character stream. */ public StringReader(String s) { this.str = s; this.length = s.length(); } JsonReader并不是继承自Reader，JsonReader需要配合TypeAdapter使用\n// Gson.java newJsonReader将StringReader转为JsonReader对象，DEFAULT_LENIENT为false，暂时不明白 /** * Returns a new JSON reader configured for the settings on this Gson instance. */ public JsonReader newJsonReader(Reader reader) { JsonReader jsonReader = new JsonReader(reader); jsonReader.setLenient(lenient); return jsonReader; } getAdapter方法如何获取到TypeAdapter\n/** * Returns the type adapter for {@code} type. * * @throws IllegalArgumentException if this GSON cannot serialize and * deserialize {@code type}. */ @SuppressWarnings(\u0026#34;unchecked\u0026#34;) public \u0026lt;T\u0026gt; TypeAdapter\u0026lt;T\u0026gt; getAdapter(TypeToken\u0026lt;T\u0026gt; type) { // 初始情况下typeTokenCache为空 TypeAdapter\u0026lt;?\u0026gt; cached = typeTokenCache.get(type == null ? NULL_KEY_SURROGATE : type); if (cached != null) { return (TypeAdapter\u0026lt;T\u0026gt;) cached; } // calls初始也为空 Map\u0026lt;TypeToken\u0026lt;?\u0026gt;, FutureTypeAdapter\u0026lt;?\u0026gt;\u0026gt; threadCalls = calls.get(); boolean requiresThreadLocalCleanup = false; if (threadCalls == null) { threadCalls = new HashMap\u0026lt;TypeToken\u0026lt;?\u0026gt;, FutureTypeAdapter\u0026lt;?\u0026gt;\u0026gt;(); calls.set(threadCalls); requiresThreadLocalCleanup = true; } // ThreadLocal在这里是防止老是执行for (TypeAdapterFactory factory : factories) 递归查找， // 如果不用ThreadLocal干预的话，就会导致堆栈溢出 // the key and value type parameters always agree FutureTypeAdapter\u0026lt;T\u0026gt; ongoingCall = (FutureTypeAdapter\u0026lt;T\u0026gt;) threadCalls.get(type); if (ongoingCall != null) { return ongoingCall; } try { FutureTypeAdapter\u0026lt;T\u0026gt; call = new FutureTypeAdapter\u0026lt;T\u0026gt;(); threadCalls.put(type, call); // TypeAdapter是从Gson初始化的factories中按照顺序遍历得到的， // 所以接下来需要看这里使用的是哪个TypeAdapterFactory for (TypeAdapterFactory factory : factories) { TypeAdapter\u0026lt;T\u0026gt; candidate = factory.create(this, type); if (candidate != null) { call.setDelegate(candidate); typeTokenCache.put(type, candidate); return candidate; } } throw new IllegalArgumentException(\u0026#34;GSON (\u0026#34; + GsonBuildConfig.VERSION + \u0026#34;) cannot handle \u0026#34; + type); } finally { threadCalls.remove(type); if (requiresThreadLocalCleanup) { calls.remove(); } } } ReflectiveTypeAdapterFactory的create方法得到我们处理WeatherEntity的TypeAdapter\n// ReflectiveTypeAdapterFactory.java create方法返回的是Adapter @Override public \u0026lt;T\u0026gt; TypeAdapter\u0026lt;T\u0026gt; create(Gson gson, final TypeToken\u0026lt;T\u0026gt; type) { Class\u0026lt;? super T\u0026gt; raw = type.getRawType(); if (!Object.class.isAssignableFrom(raw)) { return null; // it\u0026#39;s a primitive! } ObjectConstructor\u0026lt;T\u0026gt; constructor = constructorConstructor.get(type); return new Adapter\u0026lt;T\u0026gt;(constructor, getBoundFields(gson, type, raw)); } // Adapter的read方法就是返回WeatherEntity的位置 Adapter(ObjectConstructor\u0026lt;T\u0026gt; constructor, Map\u0026lt;String, BoundField\u0026gt; boundFields) { this.constructor = constructor; this.boundFields = boundFields; } // read实际上是被递归调用的 @Override public T read(JsonReader in) throws IOException { // JsonReader中保存了我们需要解析的字符串数据，所以也封装了一些读取的函数， // 通过peek判断JsonReader是否已经读到结尾了来结束解析的过程 if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } // 两个类ObjectConstructor和BoundField，看名字就知道了ObjectConstructor // 用于构造实例，BoundField用于指定属性 T instance = constructor.construct(); try { // JsonReader有几个方法，比如beginObject和beginArray，表明要开始解析 // JsonReader的数据了，beginObject表明需要解析为对象，beginArray表明需要解析为 // 数组 in.beginObject(); // hasNext表明数据是否到达结尾 while (in.hasNext()) { // nextName可以获取json数据中的key String name = in.nextName(); // 通过将name转为BoundField，为后续生成属性做铺垫 BoundField field = boundFields.get(name); // 如果不能生成此属性或者不允许反序列化，则跳过此key对应的value数据 if (field == null || !field.deserialized) { in.skipValue(); } else { // 然后需要对属性进行赋值，因此需要看BoundField的read方法做了些什么 field.read(in, instance); } } } catch (IllegalStateException e) { throw new JsonSyntaxException(e); } catch (IllegalAccessException e) { throw new AssertionError(e); } in.endObject(); // 最后返回我们的实例 return instance; } // BoundField来源于getBoundFields方法 private Map\u0026lt;String, BoundField\u0026gt; getBoundFields(Gson context, TypeToken\u0026lt;?\u0026gt; type, Class\u0026lt;?\u0026gt; raw) { Map\u0026lt;String, BoundField\u0026gt; result = new LinkedHashMap\u0026lt;String, BoundField\u0026gt;(); if (raw.isInterface()) { return result; } Type declaredType = type.getType(); while (raw != Object.class) { // 首先获得我们自定义WeatherEntity的属性 Field[] fields = raw.getDeclaredFields(); for (Field field : fields) { // 对于每一个属性我们通过Excluder判断是否有@Expose或者其他注解修饰 // 根据注解的要求保存这个属性是否支持序列化serialize和反序列化deserialize boolean serialize = excludeField(field, true); boolean deserialize = excludeField(field, false); if (!serialize \u0026amp;\u0026amp; !deserialize) { continue; } accessor.makeAccessible(field); Type fieldType = $Gson$Types.resolve(type.getType(), raw, field.getGenericType()); // 因为Gson支持序列化时指定key的名称，所以会有一些替代名称，替代名称可以有多个，因此需要 // 通过getFieldNames获取属性的所有序列化时的名称列表（第一个为属性名，其他可以是设置的替代名称） List\u0026lt;String\u0026gt; fieldNames = getFieldNames(field); BoundField previous = null; for (int i = 0, size = fieldNames.size(); i \u0026lt; size; ++i) { String name = fieldNames.get(i); if (i != 0) serialize = false; // only serialize the default name // result的value boundField是通过createBoundField得到的，且只有第一个名称允许序列化 BoundField boundField = createBoundField(context, field, name, TypeToken.get(fieldType), serialize, deserialize); BoundField replaced = result.put(name, boundField); if (previous == null) previous = replaced; } if (previous != null) { throw new IllegalArgumentException(declaredType + \u0026#34; declares multiple JSON fields named \u0026#34; + previous.name); } } type = TypeToken.get($Gson$Types.resolve(type.getType(), raw, raw.getGenericSuperclass())); raw = type.getRawType(); } return result; } // createBoundField返回我们需要的BoundField private ReflectiveTypeAdapterFactory.BoundField createBoundField( final Gson context, final Field field, final String name, final TypeToken\u0026lt;?\u0026gt; fieldType, boolean serialize, boolean deserialize) { final boolean isPrimitive = Primitives.isPrimitive(fieldType.getRawType()); // special casing primitives here saves ~5% on Android... JsonAdapter annotation = field.getAnnotation(JsonAdapter.class); TypeAdapter\u0026lt;?\u0026gt; mapped = null; if (annotation != null) { mapped = jsonAdapterFactory.getTypeAdapter( constructorConstructor, context, fieldType, annotation); } // mapped也是通过getAdapter获取的，但是fieldType已经改变了，变成了我们定义的实体类的下一级 final boolean jsonAdapterPresent = mapped != null; if (mapped == null) mapped = context.getAdapter(fieldType); final TypeAdapter\u0026lt;?\u0026gt; typeAdapter = mapped; return new ReflectiveTypeAdapterFactory.BoundField(name, serialize, deserialize) { @SuppressWarnings({\u0026#34;unchecked\u0026#34;, \u0026#34;rawtypes\u0026#34;}) // the type adapter and field type always agree @Override void write(JsonWriter writer, Object value) throws IOException, IllegalAccessException { Object fieldValue = field.get(value); TypeAdapter t = jsonAdapterPresent ? typeAdapter : new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType()); t.write(writer, fieldValue); } // 在调用read方法时就产生了递归 @Override void read(JsonReader reader, Object value) throws IOException, IllegalAccessException { // 由于属性的类型不同，此处的typeAdapter变为从factories遍历获取， // 如果我们这里的reader是String，那么typeAdapter为TypeAdapters.STRING_FACTORY // 然后按照TypeAdapters.STRING_FACTORY的逻辑读取数据 Object fieldValue = typeAdapter.read(reader); if (fieldValue != null || !isPrimitive) { // set方法把值fieldValue赋给对象value field.set(value, fieldValue); } } @Override public boolean writeField(Object value) throws IOException, IllegalAccessException { if (!serialized) return false; Object fieldValue = field.get(value); return fieldValue != value; // avoid recursion for example for Throwable.cause } }; } 我们目前知道了属性是通过getDeclaredFields拿到的，然后通过递归的方式调用typeAdapter的read方法，然后将从JsonReader中获取到的值赋给属性，关键是属性实例是如何得到的T instance = constructor.construct();，默认情况下是ConstructorConstructor，通过ConstructorConstructor构造某个属性的实例\n// ConstructorConstructor.java 默认instanceCreators为空 public \u0026lt;T\u0026gt; ObjectConstructor\u0026lt;T\u0026gt; get(TypeToken\u0026lt;T\u0026gt; typeToken) { final Type type = typeToken.getType(); final Class\u0026lt;? super T\u0026gt; rawType = typeToken.getRawType(); // first try an instance creator @SuppressWarnings(\u0026#34;unchecked\u0026#34;) // types must agree final InstanceCreator\u0026lt;T\u0026gt; typeCreator = (InstanceCreator\u0026lt;T\u0026gt;) instanceCreators.get(type); if (typeCreator != null) { return new ObjectConstructor\u0026lt;T\u0026gt;() { @Override public T construct() { return typeCreator.createInstance(type); } }; } // Next try raw type match for instance creators @SuppressWarnings(\u0026#34;unchecked\u0026#34;) // types must agree final InstanceCreator\u0026lt;T\u0026gt; rawTypeCreator = (InstanceCreator\u0026lt;T\u0026gt;) instanceCreators.get(rawType); if (rawTypeCreator != null) { return new ObjectConstructor\u0026lt;T\u0026gt;() { @Override public T construct() { return rawTypeCreator.createInstance(type); } }; } // 我们构造的实例一般是通过newDefaultConstructor得到的 ObjectConstructor\u0026lt;T\u0026gt; defaultConstructor = newDefaultConstructor(rawType); if (defaultConstructor != null) { return defaultConstructor; } // newDefaultImplementationConstructor用于构造Map和List以及它们的父类接口的实例 ObjectConstructor\u0026lt;T\u0026gt; defaultImplementation = newDefaultImplementationConstructor(type, rawType); if (defaultImplementation != null) { return defaultImplementation; } // finally try unsafe return newUnsafeAllocator(type, rawType); } private \u0026lt;T\u0026gt; ObjectConstructor\u0026lt;T\u0026gt; newDefaultConstructor(Class\u0026lt;? super T\u0026gt; rawType) { try { // getDeclaredConstructor通过反射得到目标类的构造函数 final Constructor\u0026lt;? super T\u0026gt; constructor = rawType.getDeclaredConstructor(); if (!constructor.isAccessible()) { accessor.makeAccessible(constructor); } return new ObjectConstructor\u0026lt;T\u0026gt;() { @SuppressWarnings(\u0026#34;unchecked\u0026#34;) // T is the same raw type as is requested @Override public T construct() { try { Object[] args = null; // 返回初始参数都为null的实例 return (T) constructor.newInstance(args); } catch (InstantiationException e) { // TODO: JsonParseException ? throw new RuntimeException(\u0026#34;Failed to invoke \u0026#34; + constructor + \u0026#34; with no args\u0026#34;, e); } catch (InvocationTargetException e) { // TODO: don\u0026#39;t wrap if cause is unchecked! // TODO: JsonParseException ? throw new RuntimeException(\u0026#34;Failed to invoke \u0026#34; + constructor + \u0026#34; with no args\u0026#34;, e.getTargetException()); } catch (IllegalAccessException e) { throw new AssertionError(e); } } }; } catch (NoSuchMethodException e) { return null; } } 读取json字符串的工作是由JsonReader完成的，以解析下面此json字符串为例（删减版），服务器传过来的数据可能没有换行\n{ \u0026#34;HeWeather6\u0026#34;: [ { \u0026#34;basic\u0026#34;: { \u0026#34;cid\u0026#34;: \u0026#34;CN101010100\u0026#34;, \u0026#34;location\u0026#34;: \u0026#34;北京\u0026#34; }, \u0026#34;update\u0026#34;: { \u0026#34;loc\u0026#34;: \u0026#34;2019-07-18 16:45\u0026#34; }, \u0026#34;status\u0026#34;: \u0026#34;ok\u0026#34; }] } 根据上文代码分析我们知道解析数据的起点是ReflectiveTypeAdapterFactory中Adapter的read方法\n@Override public T read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } T instance = constructor.construct(); try { // 从in.beginObject开始对json数据进行解析 in.beginObject(); while (in.hasNext()) { String name = in.nextName(); // 14. 得到解析的key后构造属性 BoundField field = boundFields.get(name); if (field == null || !field.deserialized) { in.skipValue(); } else { // 15. 并且递归解析后面的数据，深度优先，这里会调用CollectionTypeAdapterFactory的Adapter的read方法 // CollectionTypeAdapterFactory用于处理集合类数据，这里会调用peek方法 field.read(in, instance); } } } catch (IllegalStateException e) { throw new JsonSyntaxException(e); } catch (IllegalAccessException e) { throw new AssertionError(e); } in.endObject(); return instance; } // JsonReader.java peeked是标志位，初始为PEEKED_NONE，表明还没有开始任何解析过程 // JsonReader解析数据的过程很有意思，它是依靠peeked标志位来决定如何处理下一个字符， // peeked初始值为PEEKED_NONE，表明标志位为空所以需要读取json数据，根据读取的字符设置peeked // 的值，然后再根据peeked的值决定下一个字符如何处理 /** * Consumes the next token from the JSON stream and asserts that it is the * beginning of a new object. */ public void beginObject() throws IOException { int p = peeked; if (p == PEEKED_NONE) { // 初始值peeked为PEEKED_NONE，调用doPeek方法设置peeked的标志 p = doPeek(); } if (p == PEEKED_BEGIN_OBJECT) { // 4. 由于doPeek将p置为PEEKED_BEGIN_OBJECT，所以需要将JsonScope.EMPTY_OBJECT // 加入stack中，并peeked重置为PEEKED_NONE push(JsonScope.EMPTY_OBJECT); peeked = PEEKED_NONE; } else { throw new IllegalStateException(\u0026#34;Expected BEGIN_OBJECT but was \u0026#34; + peek() + locationString()); } } // doPeek是整个解析过程中的核心代码，其他的函数都会调用到doPeek int doPeek() throws IOException { // 除了有peeked标志还有stack数组，stack数组保存解析json数据的进度，stack初始值全为0， // 初始化后将stack[0]置为JsonScope.EMPTY_DOCUMENT，表明还未开始解析 // 6. 在hasNext方法中再次执行doPeek，此时peekStack为JsonScope.NONEMPTY_OBJECT int peekStack = stack[stackSize - 1]; // 25. stack的top被置为JsonScope.EMPTY_ARRAY，表明期望的数据是Array if (peekStack == JsonScope.EMPTY_ARRAY) { // 继续重置stack top为JsonScope.NONEMPTY_ARRAY stack[stackSize - 1] = JsonScope.NONEMPTY_ARRAY; } else if (peekStack == JsonScope.NONEMPTY_ARRAY) { // Look for a comma before the next element. int c = nextNonWhitespace(true); switch (c) { case \u0026#39;]\u0026#39;: return peeked = PEEKED_END_ARRAY; case \u0026#39;;\u0026#39;: checkLenient(); // fall-through case \u0026#39;,\u0026#39;: break; default: throw syntaxError(\u0026#34;Unterminated array\u0026#34;); } } else if (peekStack == JsonScope.EMPTY_OBJECT || peekStack == JsonScope.NONEMPTY_OBJECT) { // 7. 又将stack的top置为JsonScope.DANGLING_NAME stack[stackSize - 1] = JsonScope.DANGLING_NAME; // Look for a comma before the next element. if (peekStack == JsonScope.NONEMPTY_OBJECT) { int c = nextNonWhitespace(true); switch (c) { case \u0026#39;}\u0026#39;: return peeked = PEEKED_END_OBJECT; case \u0026#39;;\u0026#39;: checkLenient(); // fall-through case \u0026#39;,\u0026#39;: break; default: throw syntaxError(\u0026#34;Unterminated object\u0026#34;); } } // 8. 读取下一个字符 \u0026#34; int c = nextNonWhitespace(true); switch (c) { case \u0026#39;\u0026#34;\u0026#39;: // 9. 显然将peeked置为PEEKED_DOUBLE_QUOTED_NAME return peeked = PEEKED_DOUBLE_QUOTED_NAME; case \u0026#39;\\\u0026#39;\u0026#39;: checkLenient(); return peeked = PEEKED_SINGLE_QUOTED_NAME; case \u0026#39;}\u0026#39;: if (peekStack != JsonScope.NONEMPTY_OBJECT) { return peeked = PEEKED_END_OBJECT; } else { throw syntaxError(\u0026#34;Expected name\u0026#34;); } default: checkLenient(); pos--; // Don\u0026#39;t consume the first character in an unquoted string. if (isLiteral((char) c)) { return peeked = PEEKED_UNQUOTED_NAME; } else { throw syntaxError(\u0026#34;Expected name\u0026#34;); } } } else if (peekStack == JsonScope.DANGLING_NAME) { // 17. 之前stack的top被置为JsonScope.DANGLING_NAME // 然后stack的top置为JsonScope.NONEMPTY_OBJECT，表明object对象还没有读取完成 stack[stackSize - 1] = JsonScope.NONEMPTY_OBJECT; // Look for a colon before the value. // 下一个字符是 : int c = nextNonWhitespace(true); switch (c) { case \u0026#39;:\u0026#39;: break; case \u0026#39;=\u0026#39;: checkLenient(); if ((pos \u0026lt; limit || fillBuffer(1)) \u0026amp;\u0026amp; buffer[pos] == \u0026#39;\u0026gt;\u0026#39;) { pos++; } break; default: throw syntaxError(\u0026#34;Expected \u0026#39;:\u0026#39;\u0026#34;); } } else if (peekStack == JsonScope.EMPTY_DOCUMENT) { // 1. peekStack初始为JsonScope.EMPTY_DOCUMENT if (lenient) { // lenient在调用read方法之前被置为true，结束后被置为false consumeNonExecutePrefix(); } // stack[0]被置为JsonScope.NONEMPTY_DOCUMENT stack[stackSize - 1] = JsonScope.NONEMPTY_DOCUMENT; } else if (peekStack == JsonScope.NONEMPTY_DOCUMENT) { int c = nextNonWhitespace(false); if (c == -1) { return peeked = PEEKED_EOF; } else { checkLenient(); pos--; } } else if (peekStack == JsonScope.CLOSED) { throw new IllegalStateException(\u0026#34;JsonReader is closed\u0026#34;); } // 2. c是第一个字符 { // 18. c是 [ // 26. c是 { int c = nextNonWhitespace(true); switch (c) { case \u0026#39;]\u0026#39;: if (peekStack == JsonScope.EMPTY_ARRAY) { return peeked = PEEKED_END_ARRAY; } // fall-through to handle \u0026#34;,]\u0026#34; case \u0026#39;;\u0026#39;: case \u0026#39;,\u0026#39;: // In lenient mode, a 0-length literal in an array means \u0026#39;null\u0026#39;. if (peekStack == JsonScope.EMPTY_ARRAY || peekStack == JsonScope.NONEMPTY_ARRAY) { checkLenient(); pos--; return peeked = PEEKED_NULL; } else { throw syntaxError(\u0026#34;Unexpected value\u0026#34;); } case \u0026#39;\\\u0026#39;\u0026#39;: checkLenient(); return peeked = PEEKED_SINGLE_QUOTED; case \u0026#39;\u0026#34;\u0026#39;: return peeked = PEEKED_DOUBLE_QUOTED; case \u0026#39;[\u0026#39;: // 19. 将peeked置为PEEKED_BEGIN_ARRAY // 表明开始解析Array类型数据 return peeked = PEEKED_BEGIN_ARRAY; case \u0026#39;{\u0026#39;: // 3. peeked被置为PEEKED_BEGIN_OBJECT // 27. peeked被置为PEEKED_BEGIN_OBJECT return peeked = PEEKED_BEGIN_OBJECT; default: pos--; // Don\u0026#39;t consume the first character in a literal value. } int result = peekKeyword(); if (result != PEEKED_NONE) { return result; } result = peekNumber(); if (result != PEEKED_NONE) { return result; } if (!isLiteral(buffer[pos])) { throw syntaxError(\u0026#34;Expected value\u0026#34;); } checkLenient(); return peeked = PEEKED_UNQUOTED; } // NON_EXECUTE_PREFIX包括\u0026#34;)]}\u0026#39;\\n\u0026#34;，即如果json字符串第一个字符在NON_EXECUTE_PREFIX中 // 说明这个字符出了错误，buffer是1024长度的数组用于缓存json数据，pos表示我们读取数据的位置， // consumeNonExecutePrefix用于 /** * Consumes the non-execute prefix if it exists. */ private void consumeNonExecutePrefix() throws IOException { // fast forward through the leading whitespace nextNonWhitespace(true); pos--; if (pos + NON_EXECUTE_PREFIX.length \u0026gt; limit \u0026amp;\u0026amp; !fillBuffer(NON_EXECUTE_PREFIX.length)) { return; } for (int i = 0; i \u0026lt; NON_EXECUTE_PREFIX.length; i++) { if (buffer[pos + i] != NON_EXECUTE_PREFIX[i]) { return; // not a security token! } } // we consumed a security token! pos += NON_EXECUTE_PREFIX.length; } // 5. 在while循环里判断hasNext，显然peeked此时为PEEKED_NONE，所以执行doPeek /** * Returns true if the current array or object has another element. */ public boolean hasNext() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } // 10. p为PEEKED_DOUBLE_QUOTED_NAME，显然返回true return p != PEEKED_END_OBJECT \u0026amp;\u0026amp; p != PEEKED_END_ARRAY; } // 11. 然后通过in.nextName()读取json数据 /** * Returns the next token, a {@link com.google.gson.stream.JsonToken#NAME property name}, and * consumes it. * * @throws java.io.IOException if the next token in the stream is not a property * name. */ public String nextName() throws IOException { // 12. 此时peeked为PEEKED_DOUBLE_QUOTED_NAME int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } String result; if (p == PEEKED_UNQUOTED_NAME) { result = nextUnquotedValue(); } else if (p == PEEKED_SINGLE_QUOTED_NAME) { result = nextQuotedValue(\u0026#39;\\\u0026#39;\u0026#39;); } else if (p == PEEKED_DOUBLE_QUOTED_NAME) { // 13. 调用nextQuotedValue，nextQuotedValue方法读取buffer中不为 \u0026#34; 的字符串， // 简而言之就是在已知我们已经读取到双引号的情况下，将两个双引号之间的数据获取到， // 所以这里的result为HeWeather6 result = nextQuotedValue(\u0026#39;\u0026#34;\u0026#39;); } else { throw new IllegalStateException(\u0026#34;Expected a name but was \u0026#34; + peek() + locationString()); } // 最后还是需要重置peeked为PEEKED_NONE peeked = PEEKED_NONE; // 将result保存到pathNames中 pathNames[stackSize - 1] = result; return result; } // 16. peek继续调用doPeek /** * Returns the type of the next token without consuming it. */ public JsonToken peek() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } switch (p) { case PEEKED_BEGIN_OBJECT: return JsonToken.BEGIN_OBJECT; case PEEKED_END_OBJECT: return JsonToken.END_OBJECT; case PEEKED_BEGIN_ARRAY: // 20. 返回JsonToken.BEGIN_ARRAY return JsonToken.BEGIN_ARRAY; case PEEKED_END_ARRAY: return JsonToken.END_ARRAY; case PEEKED_SINGLE_QUOTED_NAME: case PEEKED_DOUBLE_QUOTED_NAME: case PEEKED_UNQUOTED_NAME: return JsonToken.NAME; case PEEKED_TRUE: case PEEKED_FALSE: return JsonToken.BOOLEAN; case PEEKED_NULL: return JsonToken.NULL; case PEEKED_SINGLE_QUOTED: case PEEKED_DOUBLE_QUOTED: case PEEKED_UNQUOTED: case PEEKED_BUFFERED: return JsonToken.STRING; case PEEKED_LONG: case PEEKED_NUMBER: return JsonToken.NUMBER; case PEEKED_EOF: return JsonToken.END_DOCUMENT; default: throw new AssertionError(); } } // 23. beginArray用于解析Array类型数据 /** * Consumes the next token from the JSON stream and asserts that it is the * beginning of a new array. */ public void beginArray() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } // 由于peeked被置为PEEKED_BEGIN_ARRAY // stack的top被置为JsonScope.EMPTY_ARRAY if (p == PEEKED_BEGIN_ARRAY) { push(JsonScope.EMPTY_ARRAY); pathIndices[stackSize - 1] = 0; peeked = PEEKED_NONE; } else { throw new IllegalStateException(\u0026#34;Expected BEGIN_ARRAY but was \u0026#34; + peek() + locationString()); } } @Override public Collection\u0026lt;E\u0026gt; read(JsonReader in) throws IOException { // 21. in.peek()返回JsonToken.BEGIN_ARRAY if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } Collection\u0026lt;E\u0026gt; collection = constructor.construct(); // 22.所以调用beginArray解析数据 in.beginArray(); // 24. 继续判断hasNext，但是还是通过doPeek解析 while (in.hasNext()) { // 28. hasNext返回true，elementTypeAdapter是通过gson.getAdapter获取的， // 本质上还是ReflectiveTypeAdapterFactory的Adapter的read方法，那么下一个属性的实例化 // 又进入了递归的模式，与此同时我们对于Array类型的属性是通过构造collection对象来加入下一级的 // 对象 E instance = elementTypeAdapter.read(in); collection.add(instance); } in.endArray(); return collection; } JsonReader可以完成的内容非常多，基本可以解析大多数的数据，而你只需要调用其中的beginArray、endArray、beginObject、endObject、hasNext等方法就可以得到json字符串中正确的数据部分，而且不需要考虑括号、引号、分号等等，在这些方法中就已经帮你跳过了，所以你也可以自定义json解析规则，实例代码在JsonReader的注释中给出了\n[ { \u0026#34;id\u0026#34;: 912345678901, \u0026#34;text\u0026#34;: \u0026#34;How do I read a JSON stream in Java?\u0026#34;, \u0026#34;geo\u0026#34;: null, \u0026#34;user\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;json_newb\u0026#34;, \u0026#34;followers_count\u0026#34;: 41 } }, { \u0026#34;id\u0026#34;: 912345678902, \u0026#34;text\u0026#34;: \u0026#34;@json_newb just use JsonReader!\u0026#34;, \u0026#34;geo\u0026#34;: [50.454722, -104.606667], \u0026#34;user\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;jesse\u0026#34;, \u0026#34;followers_count\u0026#34;: 2 } } ] public List\u0026lt;Message\u0026gt; readJsonStream(InputStream in) throws IOException { JsonReader reader = new JsonReader(new InputStreamReader(in, \u0026#34;UTF-8\u0026#34;)); try { return readMessagesArray(reader); } finally { reader.close(); } } public List\u0026lt;Message\u0026gt; readMessagesArray(JsonReader reader) throws IOException { List\u0026lt;Message\u0026gt; messages = new ArrayList\u0026lt;Message\u0026gt;(); reader.beginArray(); while (reader.hasNext()) { messages.add(readMessage(reader)); } reader.endArray(); return messages; } public Message readMessage(JsonReader reader) throws IOException { long id = -1; String text = null; User user = null; List\u0026lt;Double\u0026gt; geo = null; reader.beginObject(); while (reader.hasNext()) { String name = reader.nextName(); if (name.equals(\u0026#34;id\u0026#34;)) { id = reader.nextLong(); } else if (name.equals(\u0026#34;text\u0026#34;)) { text = reader.nextString(); } else if (name.equals(\u0026#34;geo\u0026#34;) \u0026amp;\u0026amp; reader.peek() != JsonToken.NULL) { geo = readDoublesArray(reader); } else if (name.equals(\u0026#34;user\u0026#34;)) { user = readUser(reader); } else { reader.skipValue(); } } reader.endObject(); return new Message(id, text, user, geo); } public List\u0026lt;Double\u0026gt; readDoublesArray(JsonReader reader) throws IOException { List\u0026lt;Double\u0026gt; doubles = new ArrayList\u0026lt;Double\u0026gt;(); reader.beginArray(); while (reader.hasNext()) { doubles.add(reader.nextDouble()); } reader.endArray(); return doubles; } public User readUser(JsonReader reader) throws IOException { String username = null; int followersCount = -1; reader.beginObject(); while (reader.hasNext()) { String name = reader.nextName(); if (name.equals(\u0026#34;name\u0026#34;)) { username = reader.nextString(); } else if (name.equals(\u0026#34;followers_count\u0026#34;)) { followersCount = reader.nextInt(); } else { reader.skipValue(); } } reader.endObject(); return new User(username, followersCount); } 以上就是Gson解析json数据并实例化的过程，反之toJson将实例转为json数据也差不多。解析json数据是一个深度优先遍历的过程，同时根据各种括号、分号、引号判断数据类型以及数据的值，Gson在解析的过程中有一些非常亮眼的设计思路：\nTypeAdapterFactory工厂类，用于提供TypeAdapter，TypeAdapter用于将json数据转为实例，由于Java中包含大量的基础类型和自定义类型，所以Gson提供了对应的基础类型的TypeAdapterFactory工厂，这些工厂提供的Adapter可以按照设计好的方式调用JsonReader的各种方法读取数据并转为实例；同时对于自定义类型，提供了ReflectiveTypeAdapterFactory，通过反射的方式构造实例，同时根据不同的属性的类型，又可以使用TypeToken来表示便于后续查找合适的TypeAdapter； JsonReader的强大功能，为了获取到json数据中的有效数据，比如属性名称、属性的值以及属性的类型，JsonReader加入了两个非常关键的参数peeked和stack，peeked用于标志当前的解析步骤是否完成，比如在调用beginObject后，peeked经历PEEKED_NONE -\u0026gt; PEEKED_BEGIN_OBJECT -\u0026gt; PEEKED_NONE的过程，通过doPeek完成这些步骤的转换，只要最终为PEEKED_NONE，说明前面都没有发生错误；其次是stack，stack保存了当前进行的流程，比如JsonScope.EMPTY_ARRAY、JsonScope.NONEMPTY_ARRAY、JsonScope.NONEMPTY_OBJECT等等，通过doPeek判断字符串，我们就知道了当前json数据可能是属于什么类型，从而将符号进行划分再判断，减少了需要判断的条件。 参考： Gson User Guide ","permalink":"https://zhoutao822.github.io/posts/gson/","summary":"json是一种数据格式，类似与键值对的形式，常用于服务器与客户端之间数据传输，以键值对形式传输的数据在客户端进行解析时必然需要对不同的key寻找其对应的value，通常来说这种解析数据的过程非常繁琐，但是没有难度，所以Google推出了Gson这个工具，用于解析json数据并直接将其实例化。","title":"Android框架-Gson"},{"content":"Http，超文本传输协议，Https，更加安全的超文本传输协议，目前大量用于客户端与服务端之间的信息交流，属于应用层协议，下面有传输层TCP协议、网络层IP协议以及数据链路层为其提供保障。以登录功能为例，每一次输入账户密码后点击登录按钮就做了一次对服务器的Http请求（POST），我们收到的结果比如账号密码错误或者登录成功等信息就是服务器对Http请求的回复。Http与Https的区别在于后者采用了SSL（Secure Socket Layer安全套接层），简而言之就是对传输的数据进行了加密。具体细节可以在HTTPS Tutorials或者其他资料中找到。\n1. GET和POST Http协议中比较常用的请求是GET和POST请求，可以说大部分客户端与服务端之间的数据交互都是通过这两个请求方法，以GET和POST请求为例\nGET用于请求数据，按照设计要求，GET请求不会对服务器数据进行修改，也就是说我们通过GET可以请求各种资源（静态页面等等），其中比较重要的参数包括：\nHost：需要请求的服务器\nUser-Agent：代理，表明你的身份，一般来说浏览器发送的请求会自动添加，可以人为修改伪造身份\nConnection：可以建立TCP长连接，属于HTTP/1.1的优化功能\n这个GET请求的目的就是从www.wrox.com这个服务器取index.htm这个页面\nGET /index.htm HTTP/1.1 Host: www.wrox.com User-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.6) Gecko/20050225 Firefox/1.0.1 Connection: Keep-Alive POST请求用于修改服务器数据，按照设计的要求，可以通过POST方法可以向服务器提交数据由服务器处理后返回，这里比较重要的参数包括：\nContent-Type：请求实体的格式\nContent-Length：请求实体的长度\n以及请求实体的内容，会空一行再写，比如这里的name1=value1\u0026amp;name2=value2\n这个POST请求的目的是向w3schools.com服务器下/test/demo_form.asp发送数据参数name1=value1\u0026amp;name2=value2，然后服务器会返回处理后的结果\nPOST /test/demo_form.asp HTTP/1.1 Host: w3schools.com User-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.6) Gecko/20050225 Firefox/1.0.1 Content-Type: application/x-www-form-urlencoded Content-Length: 40 Connection: Keep-Alive name1=value1\u0026amp;name2=value2 以上就是Http中GET和POST方法的简要介绍了，实际上Http协议还包括一些其他方法，以及TCP握手、SSL握手等建立连接的过程、对称与非对称加密等细节步骤，这里就不多描述，可以看其他资料。\n2. OkHttp OkHttp是一个封装好的Http请求客户端，它既可用于Java项目也可以用于Android项目，通过调用构建好的http client，我们就可以发出http请求。\nAndroid中需要网络权限\u0026lt;uses-permission android:name=\u0026quot;android.permission.INTERNET\u0026quot; /\u0026gt;\n2.1 OkHttp.GET 1.创建OkHttpClient对象\nOkHttpClient client = new OkHttpClient(); 2.创建Request对象，URL则为我们需要的请求URL，一般来说此URL包含了Host、请求内容，比如https://zhoutao822.coding.me/2019/01/03/XGBoost/0.png\nRequest request = new Request.Builder() .url(URL) .build(); 3.将Request封装为Call\nCall call = client.newCall(request); 4.调用同步或异步的请求方法\n// 这是异步调用，通过enqueue方法 call.enqueue(new Callback() { @Override public void onFailure(Call call, IOException e) { Toast.makeText(MainActivity.this, \u0026#34;get failed\u0026#34;, Toast.LENGTH_SHORT).show(); } @Override public void onResponse(Call call, Response response) throws IOException { final String ret = response.body().string(); runOnUiThread(new Runnable() { @Override public void run() { textView.setText(ret); } }); } }); // 这是同步调用 Response response = call.execute(); 异步调用意味着可以在主线程中调用call.enqueue方法，而同步调用方式只能在另一个线程中调用，通过handler将数据传回主线程，完整代码为\npublic class MainActivity extends AppCompatActivity { private final static String URL = \u0026#34;https://free-api.heweather.net/s6/weather/now?location=beijing\u0026amp;key=XXXXXXXXX\u0026#34;; private static Handler handler = new Handler(); @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); final TextView textView = findViewById(R.id.text); OkHttpClient client = new OkHttpClient(); Request request = new Request.Builder() .get() .url(URL) .build(); Call call = client.newCall(request); call.enqueue(new Callback() { @Override public void onFailure(Call call, IOException e) { Toast.makeText(MainActivity.this, \u0026#34;get failed\u0026#34;, Toast.LENGTH_SHORT).show(); } @Override public void onResponse(Call call, Response response) throws IOException { final String ret = response.body().string(); runOnUiThread(new Runnable() { @Override public void run() { textView.setText(ret); } }); } }); // 下面是同步调用 // new Thread(new Runnable() { // @Override // public void run() { // OkHttpClient client = new OkHttpClient(); // Request request = new Request.Builder() // .get() // .url(URL) // .build(); // Call call = client.newCall(request); // try { // final Response response = call.execute(); // handler.post(new Runnable() { // @Override // public void run() { // try { // textView.setText(response.body().string()); // } catch (IOException e) { // e.printStackTrace(); // } // } // }); // } catch (IOException e) { // e.printStackTrace(); // } // // } // }).start(); } } GET请求下载文件，对于图片url，我们也可以通过GET的方式进行下载，将返回的数据转为本地图片或者直接用在ImageView上\npublic void downloadImg(View view) { OkHttpClient client = new OkHttpClient(); Request request = new Request.Builder() .get() .url(URL) .build(); Call call = client.newCall(request); call.enqueue(new Callback() { @Override public void onFailure(Call call, IOException e) { Log.e(\u0026#34;aaaa\u0026#34;, \u0026#34;onFailure: \u0026#34;); } @Override public void onResponse(Call call, Response response) throws IOException { //拿到字节流 InputStream is = response.body().byteStream(); int len = 0; File file = new File(Environment.getExternalStorageDirectory(), \u0026#34;image.png\u0026#34;); FileOutputStream fos = new FileOutputStream(file); byte[] buf = new byte[128]; while ((len = is.read(buf)) != -1) { fos.write(buf, 0, len); } fos.flush(); //关闭流 fos.close(); is.close(); // 下面是直接把图片放到ImageView上 // final Bitmap bitmap = BitmapFactory.decodeStream(is); // runOnUiThread(new Runnable() { // @Override // public void run() { // imageView.setImageBitmap(bitmap); // } // }); // // is.close(); } }); } GET请求下载文件的同时我们可以计算出下载进度，通过response.body().contentLength()拿到文件总大小，只需要修改上面的onResponse方法\n@Override public void onResponse(Call call, Response response) throws IOException { //拿到字节流 InputStream is = response.body().byteStream(); int len = 0; long sum = 0L; final long total = response.body().contentLength(); File file = new File(Environment.getExternalStorageDirectory(), \u0026#34;image.png\u0026#34;); FileOutputStream fos = new FileOutputStream(file); byte[] buf = new byte[128]; while ((len = is.read(buf)) != -1) { fos.write(buf, 0, len); sum += len; final long finalSum = sum; Log.i(\u0026#34;aaaa\u0026#34;, \u0026#34;onResponse: \u0026#34; + finalSum + \u0026#34;/\u0026#34; + total); runOnUiThread(new Runnable() { @Override public void run() { //将进度设置到TextView中 textView.setText(finalSum + \u0026#34;/\u0026#34; + total); } }); } fos.flush(); //关闭流 fos.close(); is.close(); } 2.2 OkHttp.POST POST与GET非常类似，以传入键值对数据为例\n1.创建OkHttpClient对象\nOkHttpClient client = new OkHttpClient(); 2.构建FormBody，传入参数\nFormBody formBody = new FormBody.Builder() .add(\u0026#34;username\u0026#34;, \u0026#34;admin\u0026#34;) .add(\u0026#34;password\u0026#34;, \u0026#34;admin\u0026#34;) .build(); 3.创建Request对象，URL则为我们需要的请求URL，一般将此URL作为BaseUrl，比如https://www.wanandroid.com/user/login，我们就知道通过这个URL可以发送登录请求，根据API文档直到传入的参数包括username和password，因此需要FormBody\nRequest request = new Request.Builder() .url(URL) .post(formBody) .build(); 4.将Request封装为Call\nCall call = client.newCall(request); 5.调用异步的请求方法\ncall.enqueue(new Callback() { @Override public void onFailure(Call call, IOException e) { Log.e(\u0026#34;aaaa\u0026#34;, \u0026#34;onFailure: \u0026#34;); } @Override public void onResponse(Call call, Response response) throws IOException { final String res = response.body().string(); runOnUiThread(new Runnable() { @Override public void run() { textView.setText(res); } }); } }); POST除了可以发送键值对FormBody形式的请求外，还可以发送json字符串，将FormBody替换为RequestBody\nRequestBody requestBody = RequestBody.create(MediaType.parse(\u0026#34;text/plain;charset=utf-8\u0026#34;), \u0026#34;{username:admin;password:admin}\u0026#34;); 除了以上两种形式的数据之外，Http还可以接受表单形式的数据请求，这也是正常情况下登录流程中发送账号密码的要求，通过表单保存这些数据，再发送到服务器上\nFile file = new File(Environment.getExternalStorageDirectory(), \u0026#34;image.png\u0026#34;); if (!file.exists()){ Toast.makeText(this, \u0026#34;文件不存在\u0026#34;, Toast.LENGTH_SHORT).show(); return; } RequestBody muiltipartBody = new MultipartBody.Builder() //一定要设置这句 .setType(MultipartBody.FORM) .addFormDataPart(\u0026#34;username\u0026#34;, \u0026#34;admin\u0026#34;) .addFormDataPart(\u0026#34;password\u0026#34;, \u0026#34;admin\u0026#34;) .addFormDataPart(\u0026#34;myfile\u0026#34;, \u0026#34;image.png\u0026#34;, RequestBody.create(MediaType.parse(\u0026#34;application/octet-stream\u0026#34;), file)) .build(); 在发送表单请求时，除了字符串还可以添加二进制文件，比如这里将图片转为二进制加入到了表单中。\n除了在表单中上传文件之外，还可以直接发送二进制文件，需要存储权限\u0026lt;uses-permission android:name=\u0026quot;android.permission.WRITE_EXTERNAL_STORAGE\u0026quot;/\u0026gt;\nFile file = new File(Environment.getExternalStorageDirectory(), \u0026#34;image.png\u0026#34;); if (!file.exists()){ Toast.makeText(this, \u0026#34;文件不存在\u0026#34;, Toast.LENGTH_SHORT).show(); }else{ RequestBody requestBody2 = RequestBody.create(MediaType.parse(\u0026#34;application/octet-stream\u0026#34;), file); } POST也可以显示上传进度，但是需要自定义接口\npublic class CountingRequestBody extends RequestBody { //实际起作用的RequestBody private RequestBody delegate; //回调监听 private Listener listener; private CountingSink countingSink; /** * 构造函数初始化成员变量 * @param delegate * @param listener */ public CountingRequestBody(RequestBody delegate, Listener listener){ this.delegate = delegate; this.listener = listener; } @Override public MediaType contentType() { return delegate.contentType(); } @Override public void writeTo(BufferedSink sink) throws IOException { countingSink = new CountingSink(sink); //将CountingSink转化为BufferedSink供writeTo()使用 BufferedSink bufferedSink = Okio.buffer(countingSink); delegate.writeTo(bufferedSink); bufferedSink.flush(); } protected final class CountingSink extends ForwardingSink{ private long byteWritten; public CountingSink(Sink delegate) { super(delegate); } /** * 上传时调用该方法,在其中调用回调函数将上传进度暴露出去,该方法提供了缓冲区的自己大小 * @param source * @param byteCount * @throws IOException */ @Override public void write(Buffer source, long byteCount) throws IOException { super.write(source, byteCount); byteWritten += byteCount; listener.onRequestProgress(byteWritten, contentLength()); } } /** * 返回文件总的字节大小 * 如果文件大小获取失败则返回-1 * @return */ @Override public long contentLength(){ try { return delegate.contentLength(); } catch (IOException e) { return -1; } } /** * 回调监听接口 */ public static interface Listener{ /** * 暴露出上传进度 * @param byteWritted 已经上传的字节大小 * @param contentLength 文件的总字节大小 */ void onRequestProgress(long byteWritted, long contentLength); } } File file = new File(Environment.getExternalStorageDirectory(), \u0026#34;image.png\u0026#34;); if (!file.exists()){ Toast.makeText(this, \u0026#34;文件不存在\u0026#34;, Toast.LENGTH_SHORT).show(); }else{ RequestBody requestBody2 = RequestBody.create(MediaType.parse(\u0026#34;application/octet-stream\u0026#34;), file); } //使用我们自己封装的类 CountingRequestBody countingRequestBody = new CountingRequestBody(requestBody2, new CountingRequestBody.Listener() { @Override public void onRequestProgress(long byteWritted, long contentLength) { //打印进度 Log.d(\u0026#34;aaaa\u0026#34;, \u0026#34;进度 ：\u0026#34; + byteWritted + \u0026#34;/\u0026#34; + contentLength); } }); 2.3 OkHttp源码分析 以发送表单数据请求为例，大致有4步：OkHttpClient构建 -\u0026gt; RequestBody构建 -\u0026gt; Request构建 -\u0026gt; Call构建并调用\n首先看一下OkHttpClient到底是个什么东西，从注释中可以知道OkHttpClient时Call的工厂，具体发送HTTP请求以及接收服务器响应都是通过Call来实现的。\nOkHttpClient还包括以下几个特性：\nOkHttpClient应该用单例模式，这样是为了复用减少内存消耗； 每一个OkHttpClient都持有独立的连接池和线程池； 直接new出来的OkHttpClient是默认配置的； new OkHttpClient.Builder()可以对Client进行配置； 通过client.newBuilder()可以得到一个与client共享连接池和线程池的OkHttpClient，仅在特殊情形下需要； OkHttpClient不是必须主动关闭，client持有的线程和连接在空闲的情况下会被自动回收； 如果需要主动回收，client.dispatcher().executorService().shutdown()可以回收执行的Service，但会导致之后的call被拒绝； client.connectionPool().evictAll()会回收连接池； client.cache().close()会回收Client的缓存（如果在第4步中配置了的话）。 调用默认构造方法话，则默认参数为\npublic Builder() { dispatcher = new Dispatcher(); // Dispatcher持有ExecutorService，通过ExecutorService调用call protocols = DEFAULT_PROTOCOLS; // 默认支持HTTP/2和HTTP/1.1 connectionSpecs = DEFAULT_CONNECTION_SPECS; // 默认连接配置，支持TLS加密的https和普通的不加密http eventListenerFactory = EventListener.factory(EventListener.NONE); // 提供监听各种Event的Listener，通常需要继承EventListener并实现其方法 proxySelector = ProxySelector.getDefault(); // 设置代理，默认是获取系统范围的代理 if (proxySelector == null) { proxySelector = new NullProxySelector(); // 如果系统没有设置代理则将proxySelector设置为NullProxySelector } cookieJar = CookieJar.NO_COOKIES; // CookieJar是一个接口，实现这个接口的方法可以保存Cookies，也可以在发送请求时加上Cookies socketFactory = SocketFactory.getDefault(); // SocketFactory用于构建socket，默认返回DefaultSocketFactory，通过DefaultSocketFactory可以创建Socket hostnameVerifier = OkHostnameVerifier.INSTANCE; // 用于在握手期间验证URL主机名和server的身份信息是否相同 certificatePinner = CertificatePinner.DEFAULT; // CertificatePinner用于在发送请求的过程中嵌入证书（Certificate Pinning），可以防止连接到危险的服务器 proxyAuthenticator = Authenticator.NONE; // 代理服务器需要身份验证的时候需要用到，默认不需要身份验证 authenticator = Authenticator.NONE; connectionPool = new ConnectionPool(); // 默认连接池允许最大5个空闲连接，超过5分钟空闲会被回收 dns = Dns.SYSTEM; // DNS服务，默认使用系统的DNS服务 followSslRedirects = true; // 重定向到https域名，下面都是一些简单配置参数 followRedirects = true; retryOnConnectionFailure = true; callTimeout = 0; connectTimeout = 10_000; readTimeout = 10_000; writeTimeout = 10_000; pingInterval = 0; } client只在后面构建Call的时候用到，那先看一下RequestBody，RequestBody是个抽象类\n// 如果需要自定义RequestBody，则需要继承RequestBody并实现两个抽象方法contentType和writeTo， // 一般来说contentType返回此RequestBody的Content-Type，contentLength返回Content的大小， // 重写writeTo方法实际上是调用BufferedSink的write(content)方法 // RequestBody包含几个默认的create，如果只是发送简单请求，Content的内容不太复杂可以直接使用 public abstract class RequestBody { /** Returns the Content-Type header for this body. */ public abstract @Nullable MediaType contentType(); /** * Returns the number of bytes that will be written to {@code sink} in a call to {@link #writeTo}, * or -1 if that count is unknown. */ public long contentLength() throws IOException { return -1; } /** Writes the content of this request to {@code sink}. */ public abstract void writeTo(BufferedSink sink) throws IOException; /** * Returns a new request body that transmits {@code content}. If {@code contentType} is non-null * and lacks a charset, this will use UTF-8. */ public static RequestBody create(@Nullable MediaType contentType, String content) { Charset charset = Util.UTF_8; if (contentType != null) { charset = contentType.charset(); if (charset == null) { charset = Util.UTF_8; contentType = MediaType.parse(contentType + \u0026#34;; charset=utf-8\u0026#34;); } } byte[] bytes = content.getBytes(charset); return create(contentType, bytes); } /** Returns a new request body that transmits {@code content}. */ public static RequestBody create( final @Nullable MediaType contentType, final ByteString content) { return new RequestBody() { @Override public @Nullable MediaType contentType() { return contentType; } @Override public long contentLength() throws IOException { return content.size(); } @Override public void writeTo(BufferedSink sink) throws IOException { sink.write(content); } }; } /** Returns a new request body that transmits {@code content}. */ public static RequestBody create(final @Nullable MediaType contentType, final byte[] content) { return create(contentType, content, 0, content.length); } /** Returns a new request body that transmits {@code content}. */ public static RequestBody create(final @Nullable MediaType contentType, final byte[] content, final int offset, final int byteCount) { if (content == null) throw new NullPointerException(\u0026#34;content == null\u0026#34;); Util.checkOffsetAndCount(content.length, offset, byteCount); return new RequestBody() { @Override public @Nullable MediaType contentType() { return contentType; } @Override public long contentLength() { return byteCount; } @Override public void writeTo(BufferedSink sink) throws IOException { sink.write(content, offset, byteCount); } }; } /** Returns a new request body that transmits the content of {@code file}. */ public static RequestBody create(final @Nullable MediaType contentType, final File file) { if (file == null) throw new NullPointerException(\u0026#34;file == null\u0026#34;); return new RequestBody() { @Override public @Nullable MediaType contentType() { return contentType; } @Override public long contentLength() { return file.length(); } @Override public void writeTo(BufferedSink sink) throws IOException { Source source = null; try { source = Okio.source(file); sink.writeAll(source); } finally { Util.closeQuietly(source); } } }; } } MultipartBody继承自RequestBody，通过MultipartBody构建RequestBody可以发送更加复杂的数据，比如multipart/form-data表单数据，通过MultipartBody的内部类Builder可以对MultipartBody进行配置（建造者模式）\n// Builder有几个重要的方法 // setType：设置MultipartBody请求的Content-Type，如果是表单数据则为MultipartBody.FORM； // addPart：因为HTTP请求包括Header和Body，因此通过内部类Part封装号Header和Body， // 将Part保存到RequestBody的List\u0026lt;Part\u0026gt;中，可能是为了一次发送多个请求； // addFormDataPart：通过Part构造表单请求； // build：最后通过build方法创建MultipartBody实例，参数来源于前面三个方法 public static final class Builder { private final ByteString boundary; private MediaType type = MIXED; private final List\u0026lt;Part\u0026gt; parts = new ArrayList\u0026lt;\u0026gt;(); public Builder() { // 初始化一个随机的boundary，暂时还不知道有什么用 this(UUID.randomUUID().toString()); } public Builder(String boundary) { this.boundary = ByteString.encodeUtf8(boundary); } /** * Set the MIME type. Expected values for {@code type} are {@link #MIXED} (the default), {@link * #ALTERNATIVE}, {@link #DIGEST}, {@link #PARALLEL} and {@link #FORM}. */ public Builder setType(MediaType type) { if (type == null) { throw new NullPointerException(\u0026#34;type == null\u0026#34;); } if (!type.type().equals(\u0026#34;multipart\u0026#34;)) { throw new IllegalArgumentException(\u0026#34;multipart != \u0026#34; + type); } this.type = type; return this; } /** Add a part to the body. */ public Builder addPart(RequestBody body) { return addPart(Part.create(body)); } /** Add a part to the body. */ public Builder addPart(@Nullable Headers headers, RequestBody body) { return addPart(Part.create(headers, body)); } /** Add a form data part to the body. */ public Builder addFormDataPart(String name, String value) { return addPart(Part.createFormData(name, value)); } /** Add a form data part to the body. */ public Builder addFormDataPart(String name, @Nullable String filename, RequestBody body) { return addPart(Part.createFormData(name, filename, body)); } /** Add a part to the body. */ public Builder addPart(Part part) { if (part == null) throw new NullPointerException(\u0026#34;part == null\u0026#34;); parts.add(part); return this; } /** Assemble the specified parts into a request body. */ public MultipartBody build() { if (parts.isEmpty()) { throw new IllegalStateException(\u0026#34;Multipart body must have at least one part.\u0026#34;); } return new MultipartBody(boundary, type, parts); } } // Part用于构造包含Header和RequestBody的实例，简单来说就是用Header封装好要发送请求的首部参数， // 用RequestBody封装要发送请求的请求数据 public static final class Part { public static Part create(RequestBody body) { return create(null, body); } public static Part create(@Nullable Headers headers, RequestBody body) { if (body == null) { throw new NullPointerException(\u0026#34;body == null\u0026#34;); } if (headers != null \u0026amp;\u0026amp; headers.get(\u0026#34;Content-Type\u0026#34;) != null) { throw new IllegalArgumentException(\u0026#34;Unexpected header: Content-Type\u0026#34;); } if (headers != null \u0026amp;\u0026amp; headers.get(\u0026#34;Content-Length\u0026#34;) != null) { throw new IllegalArgumentException(\u0026#34;Unexpected header: Content-Length\u0026#34;); } return new Part(headers, body); } public static Part createFormData(String name, String value) { return createFormData(name, null, RequestBody.create(null, value)); } public static Part createFormData(String name, @Nullable String filename, RequestBody body) { if (name == null) { throw new NullPointerException(\u0026#34;name == null\u0026#34;); } StringBuilder disposition = new StringBuilder(\u0026#34;form-data; name=\u0026#34;); appendQuotedString(disposition, name); if (filename != null) { disposition.append(\u0026#34;; filename=\u0026#34;); appendQuotedString(disposition, filename); } return create(Headers.of(\u0026#34;Content-Disposition\u0026#34;, disposition.toString()), body); } final @Nullable Headers headers; final RequestBody body; private Part(@Nullable Headers headers, RequestBody body) { this.headers = headers; this.body = body; } public @Nullable Headers headers() { return headers; } public RequestBody body() { return body; } } RequestBody包含了请求首部参数以及请求数据，接下来需要分析Request，Request连接了请求的主机url和RequestBody\n// Request默认构造的是GET请求 public Builder() { this.method = \u0026#34;GET\u0026#34;; this.headers = new Headers.Builder(); } // 通过url方法设置请求的主机名，如果直接传入的是HttpUrl也可以，传入String也可以， // 但是会进行格式验证，会把ws:开头和wss:开头的主机名转换为http:和https: public Builder url(HttpUrl url) { if (url == null) throw new NullPointerException(\u0026#34;url == null\u0026#34;); this.url = url; return this; } /** * Sets the URL target of this request. * * @throws IllegalArgumentException if {@code url} is not a valid HTTP or HTTPS URL. Avoid this * exception by calling {@link HttpUrl#parse}; it returns null for invalid URLs. */ public Builder url(String url) { if (url == null) throw new NullPointerException(\u0026#34;url == null\u0026#34;); // Silently replace web socket URLs with HTTP URLs. if (url.regionMatches(true, 0, \u0026#34;ws:\u0026#34;, 0, 3)) { url = \u0026#34;http:\u0026#34; + url.substring(3); } else if (url.regionMatches(true, 0, \u0026#34;wss:\u0026#34;, 0, 4)) { url = \u0026#34;https:\u0026#34; + url.substring(4); } return url(HttpUrl.get(url)); } // post以及其他方法都是通过传入字符POST或者其他方式调用method public Builder get() { return method(\u0026#34;GET\u0026#34;, null); } public Builder head() { return method(\u0026#34;HEAD\u0026#34;, null); } public Builder post(RequestBody body) { return method(\u0026#34;POST\u0026#34;, body); } public Builder delete(@Nullable RequestBody body) { return method(\u0026#34;DELETE\u0026#34;, body); } public Builder delete() { return delete(Util.EMPTY_REQUEST); } public Builder put(RequestBody body) { return method(\u0026#34;PUT\u0026#34;, body); } public Builder patch(RequestBody body) { return method(\u0026#34;PATCH\u0026#34;, body); } // method方法还是将Request的属性设为method传入的值 public Builder method(String method, @Nullable RequestBody body) { if (method == null) throw new NullPointerException(\u0026#34;method == null\u0026#34;); if (method.length() == 0) throw new IllegalArgumentException(\u0026#34;method.length() == 0\u0026#34;); if (body != null \u0026amp;\u0026amp; !HttpMethod.permitsRequestBody(method)) { throw new IllegalArgumentException(\u0026#34;method \u0026#34; + method + \u0026#34; must not have a request body.\u0026#34;); } if (body == null \u0026amp;\u0026amp; HttpMethod.requiresRequestBody(method)) { throw new IllegalArgumentException(\u0026#34;method \u0026#34; + method + \u0026#34; must have a request body.\u0026#34;); } this.method = method; this.body = body; return this; } // build()方法返回Request对象，并且传入了上面设置的属性 public Request build() { if (url == null) throw new IllegalStateException(\u0026#34;url == null\u0026#34;); return new Request(this); } // 其实Request对象也没有什么具体的功能，也是类似RequestBody封装了HTTP请求的一些参数，包括url请求主机名，method请求的方法， // headers这里也有headers，也就是说我们可以在RequestBody中加入请求首部参数，也可以在Request中加入请求参数，而且Request会覆盖 // RequestBody的参数，在两个地方都封装Header，我觉得应该是为了复用，有些时候Header对于一些请求来说都是相同的，区别只是Body不同 // 因此在Request中设置Header能减少冗余的代码 Request(Builder builder) { this.url = builder.url; this.method = builder.method; this.headers = builder.headers.build(); this.body = builder.body; this.tags = Util.immutableMap(builder.tags); } 以上的RequestBody和Request实际上并没有任何复杂的功能，都是对一个完整的HTTP请求参数的封装，利用了建造者模式，同时将请求数据与请求首部参数以及请求方法和主机名进行解耦，使得开发人员可以灵活的使用各个模块组建一个完整的Request，如何发送这个Request，并接收回调则是在Call中进行的\n// OkHttpClient.java 之前说过OkHttpClient是Call的工厂类，通过newCall方法传入上面构造的Request实例， // 得到一个Call实例，具体的实现是通过RealCall.newRealCall方法 @Override public Call newCall(Request request) { return RealCall.newRealCall(this, request, false /* for web socket */); } 在看RealCall.newRealCall之前首先看一下Call\n// 根据注释说明，我们直到Call是一个接口，Call接口的实现类能够完成具体的HTTP请求发送，且包含request/response对， // 也就意味着可以通过Call的回调获取到服务器返回的数据，一个call不能被执行两次 /** * A call is a request that has been prepared for execution. A call can be canceled. As this object * represents a single request/response pair (stream), it cannot be executed twice. */ public interface Call extends Cloneable { /** Returns the original request that initiated this call. */ Request request(); // execute方法执行时会阻塞当前线程，直到处理完response Response execute() throws IOException; // enqueue方法会通过dispatcher安排request进入队列等待执行，执行完毕后通过Callback回调 void enqueue(Callback responseCallback); // 调用cancel方法可以取消request void cancel(); // 判断call是否已经在执行，比如调用了execute或者enqueue方法 boolean isExecuted(); // 判断call是否被取消 boolean isCanceled(); // 返回整个call执行期间的耗时，包括DNS寻址、连接、写入request body、服务器处理、读取response body等过程 Timeout timeout(); // 复制此call，利用clone得到的call可以继续执行 Call clone(); interface Factory { Call newCall(Request request); } } RealCall实现了Call的接口，所以上面用到的方法都是在RealCall中实现的，首先看RealCall.newRealCall\nprivate RealCall(OkHttpClient client, Request originalRequest, boolean forWebSocket) { this.client = client; this.originalRequest = originalRequest; this.forWebSocket = forWebSocket; this.retryAndFollowUpInterceptor = new RetryAndFollowUpInterceptor(client, forWebSocket); this.timeout = new AsyncTimeout() { @Override protected void timedOut() { cancel(); } }; this.timeout.timeout(client.callTimeoutMillis(), MILLISECONDS); } // newRealCall方法也是仅仅只做了参数传递的工作，最主要的参数是client和originalRequest static RealCall newRealCall(OkHttpClient client, Request originalRequest, boolean forWebSocket) { // Safely publish the Call instance to the EventListener. RealCall call = new RealCall(client, originalRequest, forWebSocket); call.eventListener = client.eventListenerFactory().create(call); return call; } 当我们调用call.execute方法时\n@Override public Response execute() throws IOException { // synchronized锁，确保同一个Call不会被执行两次 synchronized (this) { if (executed) throw new IllegalStateException(\u0026#34;Already Executed\u0026#34;); executed = true; } // captureCallStackTrace跟踪call执行的堆栈 captureCallStackTrace(); // timeout.enter开始记录timeout timeout.enter(); // 将Call Start事件传递出去，通过自定义eventListenerFactory可以对事件进行处理 eventListener.callStart(this); try { // 通过dispatcher调用executed执行请求发送，实际上只是把call加到一个队列中，并没有执行发送请求 client.dispatcher().executed(this); // 通过getResponseWithInterceptorChain获取服务器返回的response，这里才是真正的call被发送出去 Response result = getResponseWithInterceptorChain(); if (result == null) throw new IOException(\u0026#34;Canceled\u0026#34;); return result; } catch (IOException e) { e = timeoutExit(e); eventListener.callFailed(this, e); throw e; } finally { client.dispatcher().finished(this); } } // Dispatcher.java client.dispatcher().executed(this); /** Used by {@code Call#execute} to signal it is in-flight. */ synchronized void executed(RealCall call) { runningSyncCalls.add(call); } // Interceptor也是一个接口，实现Interceptor接口的类可以对Request进行拦截，也就是通过 // 各种Interceptor来实现HTTP请求，比如这里的BridgeInterceptor、CacheInterceptor、 // ConnectInterceptor等等 Response getResponseWithInterceptorChain() throws IOException { // Build a full stack of interceptors. // 注意默认构造的client.interceptors()为空 List\u0026lt;Interceptor\u0026gt; interceptors = new ArrayList\u0026lt;\u0026gt;(); interceptors.addAll(client.interceptors()); interceptors.add(retryAndFollowUpInterceptor); interceptors.add(new BridgeInterceptor(client.cookieJar())); interceptors.add(new CacheInterceptor(client.internalCache())); interceptors.add(new ConnectInterceptor(client)); if (!forWebSocket) { interceptors.addAll(client.networkInterceptors()); } interceptors.add(new CallServerInterceptor(forWebSocket)); // 这里调用的时候，注意index为0，而RealInterceptorChain调用proceed方法 Interceptor.Chain chain = new RealInterceptorChain(interceptors, null, null, null, 0, originalRequest, this, eventListener, client.connectTimeoutMillis(), client.readTimeoutMillis(), client.writeTimeoutMillis()); return chain.proceed(originalRequest); } // RealInterceptorChain.java chain.proceed(originalRequest)的位置，这里的index为0 public Response proceed(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec, RealConnection connection) throws IOException { if (index \u0026gt;= interceptors.size()) throw new AssertionError(); calls++; // If we already have a stream, confirm that the incoming request will use it. if (this.httpCodec != null \u0026amp;\u0026amp; !this.connection.supportsUrl(request.url())) { throw new IllegalStateException(\u0026#34;network interceptor \u0026#34; + interceptors.get(index - 1) + \u0026#34; must retain the same host and port\u0026#34;); } // If we already have a stream, confirm that this is the only call to chain.proceed(). if (this.httpCodec != null \u0026amp;\u0026amp; calls \u0026gt; 1) { throw new IllegalStateException(\u0026#34;network interceptor \u0026#34; + interceptors.get(index - 1) + \u0026#34; must call proceed() exactly once\u0026#34;); } // 注意这里，创建了next RealInterceptorChain，index为1，而interceptors.get(index)拿的就是上文对应的retryAndFollowUpInterceptor // Call the next interceptor in the chain. RealInterceptorChain next = new RealInterceptorChain(interceptors, streamAllocation, httpCodec, connection, index + 1, request, call, eventListener, connectTimeout, readTimeout, writeTimeout); Interceptor interceptor = interceptors.get(index); // 即response时通过BridgeInterceptor的intercept方法得到的 Response response = interceptor.intercept(next); // Confirm that the next interceptor made its required call to chain.proceed(). if (httpCodec != null \u0026amp;\u0026amp; index + 1 \u0026lt; interceptors.size() \u0026amp;\u0026amp; next.calls != 1) { throw new IllegalStateException(\u0026#34;network interceptor \u0026#34; + interceptor + \u0026#34; must call proceed() exactly once\u0026#34;); } // Confirm that the intercepted response isn\u0026#39;t null. if (response == null) { throw new NullPointerException(\u0026#34;interceptor \u0026#34; + interceptor + \u0026#34; returned null\u0026#34;); } if (response.body() == null) { throw new IllegalStateException( \u0026#34;interceptor \u0026#34; + interceptor + \u0026#34; returned a response with no body\u0026#34;); } return response; } // RetryAndFollowUpInterceptor.java RetryAndFollowUpInterceptor用于请求重连，通过connectionPool // 构建StreamAllocation，StreamAllocation用于管理连接、数据流以及Calls @Override public Response intercept(Chain chain) throws IOException { Request request = chain.request(); RealInterceptorChain realChain = (RealInterceptorChain) chain; Call call = realChain.call(); EventListener eventListener = realChain.eventListener(); StreamAllocation streamAllocation = new StreamAllocation(client.connectionPool(), createAddress(request.url()), call, eventListener, callStackTrace); this.streamAllocation = streamAllocation; int followUpCount = 0; Response priorResponse = null; // 通过while死循环发送request while (true) { if (canceled) { streamAllocation.release(); throw new IOException(\u0026#34;Canceled\u0026#34;); } Response response; boolean releaseConnection = true; try { // 这里的realChain交接给BridgeInterceptor response = realChain.proceed(request, streamAllocation, null, null); releaseConnection = false; } catch (RouteException e) { // The attempt to connect via a route failed. The request will not have been sent. if (!recover(e.getLastConnectException(), streamAllocation, false, request)) { throw e.getFirstConnectException(); } releaseConnection = false; continue; } catch (IOException e) { // An attempt to communicate with a server failed. The request may have been sent. boolean requestSendStarted = !(e instanceof ConnectionShutdownException); if (!recover(e, streamAllocation, requestSendStarted, request)) throw e; releaseConnection = false; continue; } finally { // We\u0026#39;re throwing an unchecked exception. Release any resources. if (releaseConnection) { streamAllocation.streamFailed(null); streamAllocation.release(); } } // Attach the prior response if it exists. Such responses never have a body. if (priorResponse != null) { response = response.newBuilder() .priorResponse(priorResponse.newBuilder() .body(null) .build()) .build(); } // 仅仅在发送请求后接收到response，并且没有后续的request时返回，返回值为response Request followUp; try { followUp = followUpRequest(response, streamAllocation.route()); } catch (IOException e) { streamAllocation.release(); throw e; } if (followUp == null) { streamAllocation.release(); return response; } closeQuietly(response.body()); if (++followUpCount \u0026gt; MAX_FOLLOW_UPS) { streamAllocation.release(); throw new ProtocolException(\u0026#34;Too many follow-up requests: \u0026#34; + followUpCount); } if (followUp.body() instanceof UnrepeatableRequestBody) { streamAllocation.release(); throw new HttpRetryException(\u0026#34;Cannot retry streamed HTTP body\u0026#34;, response.code()); } if (!sameConnection(response, followUp.url())) { streamAllocation.release(); streamAllocation = new StreamAllocation(client.connectionPool(), createAddress(followUp.url()), call, eventListener, callStackTrace); this.streamAllocation = streamAllocation; } else if (streamAllocation.codec() != null) { throw new IllegalStateException(\u0026#34;Closing the body of \u0026#34; + response + \u0026#34; didn\u0026#39;t close its backing stream. Bad interceptor?\u0026#34;); } request = followUp; priorResponse = response; } } // BridgeInterceptor.java @Override public Response intercept(Chain chain) throws IOException { // 通过chain得到request Request userRequest = chain.request(); Request.Builder requestBuilder = userRequest.newBuilder(); // 拿到body RequestBody body = userRequest.body(); if (body != null) { MediaType contentType = body.contentType(); if (contentType != null) { // 重新构造header requestBuilder.header(\u0026#34;Content-Type\u0026#34;, contentType.toString()); } long contentLength = body.contentLength(); if (contentLength != -1) { requestBuilder.header(\u0026#34;Content-Length\u0026#34;, Long.toString(contentLength)); requestBuilder.removeHeader(\u0026#34;Transfer-Encoding\u0026#34;); } else { requestBuilder.header(\u0026#34;Transfer-Encoding\u0026#34;, \u0026#34;chunked\u0026#34;); requestBuilder.removeHeader(\u0026#34;Content-Length\u0026#34;); } } if (userRequest.header(\u0026#34;Host\u0026#34;) == null) { requestBuilder.header(\u0026#34;Host\u0026#34;, hostHeader(userRequest.url(), false)); } if (userRequest.header(\u0026#34;Connection\u0026#34;) == null) { requestBuilder.header(\u0026#34;Connection\u0026#34;, \u0026#34;Keep-Alive\u0026#34;); } // If we add an \u0026#34;Accept-Encoding: gzip\u0026#34; header field we\u0026#39;re responsible for also decompressing // the transfer stream. boolean transparentGzip = false; if (userRequest.header(\u0026#34;Accept-Encoding\u0026#34;) == null \u0026amp;\u0026amp; userRequest.header(\u0026#34;Range\u0026#34;) == null) { transparentGzip = true; requestBuilder.header(\u0026#34;Accept-Encoding\u0026#34;, \u0026#34;gzip\u0026#34;); } // 构造带Cookies的header，默认Cookies为空 List\u0026lt;Cookie\u0026gt; cookies = cookieJar.loadForRequest(userRequest.url()); if (!cookies.isEmpty()) { requestBuilder.header(\u0026#34;Cookie\u0026#34;, cookieHeader(cookies)); } if (userRequest.header(\u0026#34;User-Agent\u0026#34;) == null) { requestBuilder.header(\u0026#34;User-Agent\u0026#34;, Version.userAgent()); } // 注意这里的chain的index为1，所以再次调用chain.proceed会使index为2，即CacheInterceptor Response networkResponse = chain.proceed(requestBuilder.build()); HttpHeaders.receiveHeaders(cookieJar, userRequest.url(), networkResponse.headers()); Response.Builder responseBuilder = networkResponse.newBuilder() .request(userRequest); if (transparentGzip \u0026amp;\u0026amp; \u0026#34;gzip\u0026#34;.equalsIgnoreCase(networkResponse.header(\u0026#34;Content-Encoding\u0026#34;)) \u0026amp;\u0026amp; HttpHeaders.hasBody(networkResponse)) { GzipSource responseBody = new GzipSource(networkResponse.body().source()); Headers strippedHeaders = networkResponse.headers().newBuilder() .removeAll(\u0026#34;Content-Encoding\u0026#34;) .removeAll(\u0026#34;Content-Length\u0026#34;) .build(); responseBuilder.headers(strippedHeaders); String contentType = networkResponse.header(\u0026#34;Content-Type\u0026#34;); responseBuilder.body(new RealResponseBody(contentType, -1L, Okio.buffer(responseBody))); } return responseBuilder.build(); } // CacheInterceptor.java CacheInterceptor用于从cache中取request以及向cache中写入response // 如果cache中保存了相同request的response，那么可以实现断网也可以获取response @Override public Response intercept(Chain chain) throws IOException { Response cacheCandidate = cache != null ? cache.get(chain.request()) : null; long now = System.currentTimeMillis(); CacheStrategy strategy = new CacheStrategy.Factory(now, chain.request(), cacheCandidate).get(); Request networkRequest = strategy.networkRequest; Response cacheResponse = strategy.cacheResponse; if (cache != null) { cache.trackResponse(strategy); } if (cacheCandidate != null \u0026amp;\u0026amp; cacheResponse == null) { closeQuietly(cacheCandidate.body()); // The cache candidate wasn\u0026#39;t applicable. Close it. } // If we\u0026#39;re forbidden from using the network and the cache is insufficient, fail. if (networkRequest == null \u0026amp;\u0026amp; cacheResponse == null) { return new Response.Builder() .request(chain.request()) .protocol(Protocol.HTTP_1_1) .code(504) .message(\u0026#34;Unsatisfiable Request (only-if-cached)\u0026#34;) .body(Util.EMPTY_RESPONSE) .sentRequestAtMillis(-1L) .receivedResponseAtMillis(System.currentTimeMillis()) .build(); } // 没有网络则从cache中取对应的response // If we don\u0026#39;t need the network, we\u0026#39;re done. if (networkRequest == null) { return cacheResponse.newBuilder() .cacheResponse(stripBody(cacheResponse)) .build(); } Response networkResponse = null; try { // 注意这里同理chain交接给下一个ConnectInterceptor networkResponse = chain.proceed(networkRequest); } finally { // If we\u0026#39;re crashing on I/O or otherwise, don\u0026#39;t leak the cache body. if (networkResponse == null \u0026amp;\u0026amp; cacheCandidate != null) { closeQuietly(cacheCandidate.body()); } } // If we have a cache response too, then we\u0026#39;re doing a conditional get. if (cacheResponse != null) { if (networkResponse.code() == HTTP_NOT_MODIFIED) { Response response = cacheResponse.newBuilder() .headers(combine(cacheResponse.headers(), networkResponse.headers())) .sentRequestAtMillis(networkResponse.sentRequestAtMillis()) .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis()) .cacheResponse(stripBody(cacheResponse)) .networkResponse(stripBody(networkResponse)) .build(); networkResponse.body().close(); // Update the cache after combining headers but before stripping the // Content-Encoding header (as performed by initContentStream()). cache.trackConditionalCacheHit(); cache.update(cacheResponse, response); return response; } else { closeQuietly(cacheResponse.body()); } } Response response = networkResponse.newBuilder() .cacheResponse(stripBody(cacheResponse)) .networkResponse(stripBody(networkResponse)) .build(); if (cache != null) { if (HttpHeaders.hasBody(response) \u0026amp;\u0026amp; CacheStrategy.isCacheable(response, networkRequest)) { // Offer this request to the cache. CacheRequest cacheRequest = cache.put(response); return cacheWritingResponse(cacheRequest, response); } if (HttpMethod.invalidatesCache(networkRequest.method())) { try { cache.remove(networkRequest); } catch (IOException ignored) { // The cache cannot be written. } } } return response; } // ConnectInterceptor.java StreamAllocation在RetryAndFollowUpInterceptor中被构造用于管理连接 // 因此ConnectInterceptor用于创建真实的HTTP连接RealConnection @Override public Response intercept(Chain chain) throws IOException { RealInterceptorChain realChain = (RealInterceptorChain) chain; Request request = realChain.request(); StreamAllocation streamAllocation = realChain.streamAllocation(); // We need the network to satisfy this request. Possibly for validating a conditional GET. boolean doExtensiveHealthChecks = !request.method().equals(\u0026#34;GET\u0026#34;); HttpCodec httpCodec = streamAllocation.newStream(client, chain, doExtensiveHealthChecks); RealConnection connection = streamAllocation.connection(); // 同理下一任是CallServerInterceptor，因为networkInterceptors为空 return realChain.proceed(request, streamAllocation, httpCodec, connection); } // CallServerInterceptor.java CallServerInterceptor是最后一任Interceptor，它的功能是发送网络Call到服务器 @Override public Response intercept(Chain chain) throws IOException { RealInterceptorChain realChain = (RealInterceptorChain) chain; HttpCodec httpCodec = realChain.httpStream(); StreamAllocation streamAllocation = realChain.streamAllocation(); RealConnection connection = (RealConnection) realChain.connection(); Request request = realChain.request(); long sentRequestMillis = System.currentTimeMillis(); // 将HeadersStart和HeadersEnd通过eventListener传出去 realChain.eventListener().requestHeadersStart(realChain.call()); // 发送请求的方式是通过httpCodec数据流，首先传出去request httpCodec.writeRequestHeaders(request); realChain.eventListener().requestHeadersEnd(realChain.call(), request); // 然后通过httpCodec读取response，其中涉及到request的首部是否包含Expect: 100-continue，不过问题不大 Response.Builder responseBuilder = null; if (HttpMethod.permitsRequestBody(request.method()) \u0026amp;\u0026amp; request.body() != null) { // If there\u0026#39;s a \u0026#34;Expect: 100-continue\u0026#34; header on the request, wait for a \u0026#34;HTTP/1.1 100 // Continue\u0026#34; response before transmitting the request body. If we don\u0026#39;t get that, return // what we did get (such as a 4xx response) without ever transmitting the request body. if (\u0026#34;100-continue\u0026#34;.equalsIgnoreCase(request.header(\u0026#34;Expect\u0026#34;))) { // 如果request的首部包含Expect: 100-continue参数，responseBuilder会被置为null httpCodec.flushRequest(); realChain.eventListener().responseHeadersStart(realChain.call()); responseBuilder = httpCodec.readResponseHeaders(true); } if (responseBuilder == null) { // Write the request body if the \u0026#34;Expect: 100-continue\u0026#34; expectation was met. realChain.eventListener().requestBodyStart(realChain.call()); long contentLength = request.body().contentLength(); // 通过httpCodec创建request数据流，可以通过CountingSink监控数据传输 CountingSink requestBodyOut = new CountingSink(httpCodec.createRequestBody(request, contentLength)); BufferedSink bufferedRequestBody = Okio.buffer(requestBodyOut); request.body().writeTo(bufferedRequestBody); bufferedRequestBody.close(); realChain.eventListener() .requestBodyEnd(realChain.call(), requestBodyOut.successfulCount); } else if (!connection.isMultiplexed()) { // If the \u0026#34;Expect: 100-continue\u0026#34; expectation wasn\u0026#39;t met, prevent the HTTP/1 connection // from being reused. Otherwise we\u0026#39;re still obligated to transmit the request body to // leave the connection in a consistent state. streamAllocation.noNewStreams(); } } httpCodec.finishRequest(); if (responseBuilder == null) { realChain.eventListener().responseHeadersStart(realChain.call()); // 通过httpCodec的readResponseHeaders读取response的header信息，此时responseBuilder不为空 responseBuilder = httpCodec.readResponseHeaders(false); } // 通过responseBuilder构建完整的response Response response = responseBuilder .request(request) .handshake(streamAllocation.connection().handshake()) .sentRequestAtMillis(sentRequestMillis) .receivedResponseAtMillis(System.currentTimeMillis()) .build(); int code = response.code(); if (code == 100) { // server sent a 100-continue even though we did not request one. // try again to read the actual response responseBuilder = httpCodec.readResponseHeaders(false); response = responseBuilder .request(request) .handshake(streamAllocation.connection().handshake()) .sentRequestAtMillis(sentRequestMillis) .receivedResponseAtMillis(System.currentTimeMillis()) .build(); code = response.code(); } realChain.eventListener() .responseHeadersEnd(realChain.call(), response); if (forWebSocket \u0026amp;\u0026amp; code == 101) { // Connection is upgrading, but we need to ensure interceptors see a non-null response body. response = response.newBuilder() .body(Util.EMPTY_RESPONSE) .build(); } else { // 通过httpCodec的openResponseBody创建读取response的body的数据流 response = response.newBuilder() .body(httpCodec.openResponseBody(response)) .build(); } if (\u0026#34;close\u0026#34;.equalsIgnoreCase(response.request().header(\u0026#34;Connection\u0026#34;)) || \u0026#34;close\u0026#34;.equalsIgnoreCase(response.header(\u0026#34;Connection\u0026#34;))) { streamAllocation.noNewStreams(); } if ((code == 204 || code == 205) \u0026amp;\u0026amp; response.body().contentLength() \u0026gt; 0) { throw new ProtocolException( \u0026#34;HTTP \u0026#34; + code + \u0026#34; had non-zero Content-Length: \u0026#34; + response.body().contentLength()); } // 最后返回构建好的response return response; } 以上就是通过call.execute返回response的流程，这里可以发现并没有使用到Service或者多线程，因此在等待服务器响应的过程中会阻塞当前线程，因此Android中不宜直接使用execute方法。\n当我们调用call.enqueue方法时\n@Override public void enqueue(Callback responseCallback) { synchronized (this) { if (executed) throw new IllegalStateException(\u0026#34;Already Executed\u0026#34;); executed = true; } captureCallStackTrace(); eventListener.callStart(this); // 通过dispatcher将responseCallback入队 client.dispatcher().enqueue(new AsyncCall(responseCallback)); } // Dispatcher.java void enqueue(AsyncCall call) { synchronized (this) { readyAsyncCalls.add(call); } // 调用promoteAndExecute执行发送请求 promoteAndExecute(); } /** * Promotes eligible calls from {@link #readyAsyncCalls} to {@link #runningAsyncCalls} and runs * them on the executor service. Must not be called with synchronization because executing calls * can call into user code. * * @return true if the dispatcher is currently running calls. */ private boolean promoteAndExecute() { assert (!Thread.holdsLock(this)); List\u0026lt;AsyncCall\u0026gt; executableCalls = new ArrayList\u0026lt;\u0026gt;(); boolean isRunning; synchronized (this) { // 将readyAsyncCalls中的Call加入到executableCalls中 for (Iterator\u0026lt;AsyncCall\u0026gt; i = readyAsyncCalls.iterator(); i.hasNext(); ) { AsyncCall asyncCall = i.next(); if (runningAsyncCalls.size() \u0026gt;= maxRequests) break; // Max capacity. if (runningCallsForHost(asyncCall) \u0026gt;= maxRequestsPerHost) continue; // Host max capacity. i.remove(); executableCalls.add(asyncCall); runningAsyncCalls.add(asyncCall); } isRunning = runningCallsCount() \u0026gt; 0; } for (int i = 0, size = executableCalls.size(); i \u0026lt; size; i++) { AsyncCall asyncCall = executableCalls.get(i); // 通过遍历executableCalls，调用每一个Call的executeOn方法，其中使用到了初始化过程中引入的线程池executorService asyncCall.executeOn(executorService()); } return isRunning; } public synchronized ExecutorService executorService() { if (executorService == null) { executorService = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60, TimeUnit.SECONDS, new SynchronousQueue\u0026lt;Runnable\u0026gt;(), Util.threadFactory(\u0026#34;OkHttp Dispatcher\u0026#34;, false)); } return executorService; } /** * Attempt to enqueue this async call on {@code executorService}. This will attempt to clean up * if the executor has been shut down by reporting the call as failed. */ void executeOn(ExecutorService executorService) { assert (!Thread.holdsLock(client.dispatcher())); boolean success = false; try { // 关键代码通过线程池executorService执行此Call，又因为AsyncCall继承自NamedRunnable，因此，调用 // AsyncCall的run方法时，执行的是NamedRunnable的run executorService.execute(this); success = true; } catch (RejectedExecutionException e) { InterruptedIOException ioException = new InterruptedIOException(\u0026#34;executor rejected\u0026#34;); ioException.initCause(e); eventListener.callFailed(RealCall.this, ioException); responseCallback.onFailure(RealCall.this, ioException); } finally { if (!success) { client.dispatcher().finished(this); // This call is no longer running! } } } /** * Runnable implementation which always sets its thread name. */ public abstract class NamedRunnable implements Runnable { protected final String name; public NamedRunnable(String format, Object... args) { this.name = Util.format(format, args); } @Override public final void run() { String oldName = Thread.currentThread().getName(); Thread.currentThread().setName(name); try { // 这里的execute由AsyncCall实现 execute(); } finally { Thread.currentThread().setName(oldName); } } protected abstract void execute(); } @Override protected void execute() { boolean signalledCallback = false; timeout.enter(); try { // 最终又回到了getResponseWithInterceptorChain方法，后面的不用多说 Response response = getResponseWithInterceptorChain(); if (retryAndFollowUpInterceptor.isCanceled()) { signalledCallback = true; // 与此同时我们通过responseCallback.onFailure将事件回调出去 responseCallback.onFailure(RealCall.this, new IOException(\u0026#34;Canceled\u0026#34;)); } else { signalledCallback = true; // 同上 responseCallback.onResponse(RealCall.this, response); } } catch (IOException e) { e = timeoutExit(e); if (signalledCallback) { // Do not signal the callback twice! Platform.get().log(INFO, \u0026#34;Callback failure for \u0026#34; + toLoggableString(), e); } else { eventListener.callFailed(RealCall.this, e); responseCallback.onFailure(RealCall.this, e); } } finally { client.dispatcher().finished(this); } } } 综上，OkHttp的源码中采用了非常多的有意思的设计模式，比如建造者模式，对于HTTP请求来说，我们需要一些公用的资源比如线程池、连接池等，将这些公共资源设置在OkHttpClient中，然后通过单例模式引用，节省了很多资源消耗；\n对于RequestBody以及Request这种参数设置非常多的实体，通过建造者模式保存其参数；\n在构建请求实体Call的时候采用了OkHttpClient工厂类，同时发送request的过程中利用了链式传递的方式，既增加了开发人员自定义的Interceptor，又可以利用原本定义好的Interceptor。\n3. Retrofit Retrofit也是一个网络请求框架，且Retrofit是基于OkHttp的，实际网络请求的功能由OkHttp来实现，但是Retrofit实现了额外的功能，比如利用Gson进行数据实体化、兼容RxJava等等，是一个比较流行的网络请求工具。\n3.1 Retrofit使用 需要implementation 'com.squareup.retrofit2:retrofit:2.6.0'\n以请求和风天气数据为例，通过GET请求，加上location参数和key参数，服务器返回json数据，我们将json数据实体化，首先看一下返回的json格式\n{ \u0026#34;HeWeather6\u0026#34;: [ { \u0026#34;basic\u0026#34;: { \u0026#34;cid\u0026#34;: \u0026#34;CN101010100\u0026#34;, \u0026#34;location\u0026#34;: \u0026#34;北京\u0026#34;, \u0026#34;parent_city\u0026#34;: \u0026#34;北京\u0026#34;, \u0026#34;admin_area\u0026#34;: \u0026#34;北京\u0026#34;, \u0026#34;cnty\u0026#34;: \u0026#34;中国\u0026#34;, \u0026#34;lat\u0026#34;: \u0026#34;39.90498734\u0026#34;, \u0026#34;lon\u0026#34;: \u0026#34;116.4052887\u0026#34;, \u0026#34;tz\u0026#34;: \u0026#34;+8.00\u0026#34; }, \u0026#34;update\u0026#34;: { \u0026#34;loc\u0026#34;: \u0026#34;2019-07-18 16:45\u0026#34;, \u0026#34;utc\u0026#34;: \u0026#34;2019-07-18 08:45\u0026#34; }, \u0026#34;status\u0026#34;: \u0026#34;ok\u0026#34;, \u0026#34;now\u0026#34;: { \u0026#34;cloud\u0026#34;: \u0026#34;10\u0026#34;, \u0026#34;cond_code\u0026#34;: \u0026#34;101\u0026#34;, \u0026#34;cond_txt\u0026#34;: \u0026#34;多云\u0026#34;, \u0026#34;fl\u0026#34;: \u0026#34;35\u0026#34;, \u0026#34;hum\u0026#34;: \u0026#34;54\u0026#34;, \u0026#34;pcpn\u0026#34;: \u0026#34;0.0\u0026#34;, \u0026#34;pres\u0026#34;: \u0026#34;1000\u0026#34;, \u0026#34;tmp\u0026#34;: \u0026#34;32\u0026#34;, \u0026#34;vis\u0026#34;: \u0026#34;6\u0026#34;, \u0026#34;wind_deg\u0026#34;: \u0026#34;279\u0026#34;, \u0026#34;wind_dir\u0026#34;: \u0026#34;西风\u0026#34;, \u0026#34;wind_sc\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;wind_spd\u0026#34;: \u0026#34;3\u0026#34; } } ] } 1.根据json数据构建我们的实体类WeatherEntity，这里使用的Android Studio的插件GsonFormat，可以直接根据json数据生成代码\npublic class WeatherEntity { private List\u0026lt;HeWeather6Bean\u0026gt; HeWeather6; public List\u0026lt;HeWeather6Bean\u0026gt; getHeWeather6() { return HeWeather6; } public void setHeWeather6(List\u0026lt;HeWeather6Bean\u0026gt; HeWeather6) { this.HeWeather6 = HeWeather6; } // 重写以下toString方法，便于后续观察数据传输是否正确 @NonNull @Override public String toString() { return HeWeather6.get(0).toString(); } public static class HeWeather6Bean { /** * basic : {\u0026#34;cid\u0026#34;:\u0026#34;CN101010100\u0026#34;,\u0026#34;location\u0026#34;:\u0026#34;北京\u0026#34;,\u0026#34;parent_city\u0026#34;:\u0026#34;北京\u0026#34;,\u0026#34;admin_area\u0026#34;:\u0026#34;北京\u0026#34;,\u0026#34;cnty\u0026#34;:\u0026#34;中国\u0026#34;,\u0026#34;lat\u0026#34;:\u0026#34;39.90498734\u0026#34;,\u0026#34;lon\u0026#34;:\u0026#34;116.4052887\u0026#34;,\u0026#34;tz\u0026#34;:\u0026#34;+8.00\u0026#34;} * update : {\u0026#34;loc\u0026#34;:\u0026#34;2019-07-18 16:45\u0026#34;,\u0026#34;utc\u0026#34;:\u0026#34;2019-07-18 08:45\u0026#34;} * status : ok * now : {\u0026#34;cloud\u0026#34;:\u0026#34;10\u0026#34;,\u0026#34;cond_code\u0026#34;:\u0026#34;101\u0026#34;,\u0026#34;cond_txt\u0026#34;:\u0026#34;多云\u0026#34;,\u0026#34;fl\u0026#34;:\u0026#34;35\u0026#34;,\u0026#34;hum\u0026#34;:\u0026#34;54\u0026#34;,\u0026#34;pcpn\u0026#34;:\u0026#34;0.0\u0026#34;,\u0026#34;pres\u0026#34;:\u0026#34;1000\u0026#34;,\u0026#34;tmp\u0026#34;:\u0026#34;32\u0026#34;,\u0026#34;vis\u0026#34;:\u0026#34;6\u0026#34;,\u0026#34;wind_deg\u0026#34;:\u0026#34;279\u0026#34;,\u0026#34;wind_dir\u0026#34;:\u0026#34;西风\u0026#34;,\u0026#34;wind_sc\u0026#34;:\u0026#34;1\u0026#34;,\u0026#34;wind_spd\u0026#34;:\u0026#34;3\u0026#34;} */ private BasicBean basic; private UpdateBean update; private String status; private NowBean now; @NonNull @Override public String toString() { return status + \u0026#34; \\n \u0026#34; + basic.toString() + \u0026#34; \\n \u0026#34; + update.toString() + \u0026#34; \\n \u0026#34; + now.toString(); } public BasicBean getBasic() { return basic; } public void setBasic(BasicBean basic) { this.basic = basic; } public UpdateBean getUpdate() { return update; } public void setUpdate(UpdateBean update) { this.update = update; } public String getStatus() { return status; } public void setStatus(String status) { this.status = status; } public NowBean getNow() { return now; } public void setNow(NowBean now) { this.now = now; } public static class BasicBean { /** * cid : CN101010100 * location : 北京 * parent_city : 北京 * admin_area : 北京 * cnty : 中国 * lat : 39.90498734 * lon : 116.4052887 * tz : +8.00 */ private String cid; private String location; private String parent_city; private String admin_area; private String cnty; private String lat; private String lon; private String tz; @NonNull @Override public String toString() { return \u0026#34;cid : \u0026#34; + cid + \u0026#34;\\n\u0026#34; + \u0026#34;location : \u0026#34; + location + \u0026#34;\\n\u0026#34; + \u0026#34;parent_city : \u0026#34; + parent_city + \u0026#34;\\n\u0026#34; + \u0026#34;admin_area : \u0026#34; + admin_area + \u0026#34;\\n\u0026#34; + \u0026#34;cnty : \u0026#34; + cnty + \u0026#34;\\n\u0026#34; + \u0026#34;lat : \u0026#34; + lat + \u0026#34;\\n\u0026#34; + \u0026#34;lon : \u0026#34; + lon + \u0026#34;\\n\u0026#34; + \u0026#34;tz : \u0026#34; + tz + \u0026#34;\\n\u0026#34;; } public String getCid() { return cid; } public void setCid(String cid) { this.cid = cid; } public String getLocation() { return location; } public void setLocation(String location) { this.location = location; } public String getParent_city() { return parent_city; } public void setParent_city(String parent_city) { this.parent_city = parent_city; } public String getAdmin_area() { return admin_area; } public void setAdmin_area(String admin_area) { this.admin_area = admin_area; } public String getCnty() { return cnty; } public void setCnty(String cnty) { this.cnty = cnty; } public String getLat() { return lat; } public void setLat(String lat) { this.lat = lat; } public String getLon() { return lon; } public void setLon(String lon) { this.lon = lon; } public String getTz() { return tz; } public void setTz(String tz) { this.tz = tz; } } public static class UpdateBean { /** * loc : 2019-07-18 16:45 * utc : 2019-07-18 08:45 */ private String loc; private String utc; @NonNull @Override public String toString() { return \u0026#34;loc : \u0026#34; + loc + \u0026#34;\\n\u0026#34; + \u0026#34;utc : \u0026#34; + utc + \u0026#34;\\n\u0026#34;; } public String getLoc() { return loc; } public void setLoc(String loc) { this.loc = loc; } public String getUtc() { return utc; } public void setUtc(String utc) { this.utc = utc; } } public static class NowBean { /** * cloud : 10 * cond_code : 101 * cond_txt : 多云 * fl : 35 * hum : 54 * pcpn : 0.0 * pres : 1000 * tmp : 32 * vis : 6 * wind_deg : 279 * wind_dir : 西风 * wind_sc : 1 * wind_spd : 3 */ private String cloud; private String cond_code; private String cond_txt; private String fl; private String hum; private String pcpn; private String pres; private String tmp; private String vis; private String wind_deg; private String wind_dir; private String wind_sc; private String wind_spd; @NonNull @Override public String toString() { return \u0026#34;cloud : \u0026#34; + cloud + \u0026#34;\\n\u0026#34; + \u0026#34;cond_code : \u0026#34; + cond_code + \u0026#34;\\n\u0026#34; + \u0026#34;cond_txt : \u0026#34; + cond_txt + \u0026#34;\\n\u0026#34; + \u0026#34;fl : \u0026#34; + fl + \u0026#34;\\n\u0026#34; + \u0026#34;hum : \u0026#34; + hum + \u0026#34;\\n\u0026#34; + \u0026#34;pcpn : \u0026#34; + pcpn + \u0026#34;\\n\u0026#34; + \u0026#34;pres : \u0026#34; + pres + \u0026#34;\\n\u0026#34; + \u0026#34;tmp : \u0026#34; + tmp + \u0026#34;\\n\u0026#34; + \u0026#34;vis : \u0026#34; + vis + \u0026#34;\\n\u0026#34; + \u0026#34;wind_deg : \u0026#34; + wind_deg + \u0026#34;\\n\u0026#34; + \u0026#34;wind_dir : \u0026#34; + wind_dir + \u0026#34;\\n\u0026#34; + \u0026#34;wind_sc : \u0026#34; + wind_sc + \u0026#34;\\n\u0026#34; + \u0026#34;wind_spd : \u0026#34; + wind_spd + \u0026#34;\\n\u0026#34;; } public String getCloud() { return cloud; } public void setCloud(String cloud) { this.cloud = cloud; } public String getCond_code() { return cond_code; } public void setCond_code(String cond_code) { this.cond_code = cond_code; } public String getCond_txt() { return cond_txt; } public void setCond_txt(String cond_txt) { this.cond_txt = cond_txt; } public String getFl() { return fl; } public void setFl(String fl) { this.fl = fl; } public String getHum() { return hum; } public void setHum(String hum) { this.hum = hum; } public String getPcpn() { return pcpn; } public void setPcpn(String pcpn) { this.pcpn = pcpn; } public String getPres() { return pres; } public void setPres(String pres) { this.pres = pres; } public String getTmp() { return tmp; } public void setTmp(String tmp) { this.tmp = tmp; } public String getVis() { return vis; } public void setVis(String vis) { this.vis = vis; } public String getWind_deg() { return wind_deg; } public void setWind_deg(String wind_deg) { this.wind_deg = wind_deg; } public String getWind_dir() { return wind_dir; } public void setWind_dir(String wind_dir) { this.wind_dir = wind_dir; } public String getWind_sc() { return wind_sc; } public void setWind_sc(String wind_sc) { this.wind_sc = wind_sc; } public String getWind_spd() { return wind_spd; } public void setWind_spd(String wind_spd) { this.wind_spd = wind_spd; } } } } 2.构建请求Api，请求url格式为https://free-api.heweather.net/s6/weather/now?location=beijing\u0026amp;key=xxx，因此将https://free-api.heweather.net/s6/weather/作为baseUrl（baseUrl必须以/结尾），now?作为请求url主体，后面的两个作为参数通过@Query加入\npublic interface Api { // 通过@Query(\u0026#34;location\u0026#34;)的方式可以自动将location=location连接到我们的请求url后面 @GET(\u0026#34;now?\u0026#34;) Call\u0026lt;WeatherEntity\u0026gt; getNowWeather(@Query(\u0026#34;location\u0026#34;) String location, @Query(\u0026#34;key\u0026#34;) String key); // 如果需要使用RxJava，需要修改返回类型为Observable // @GET(\u0026#34;now?\u0026#34;) // Observable\u0026lt;WeatherEntity\u0026gt; getNowWeather(@Query(\u0026#34;location\u0026#34;) String location, @Query(\u0026#34;key\u0026#34;) String key); } 3.构建Retrofit实体，需要implementation 'com.squareup.retrofit2:converter-gson:2.6.0'，这里的版本号和Retrofit相同即可，如果需要RxJava2，则添加implementation 'com.squareup.retrofit2:adapter-rxjava2:2.6.0'\nRetrofit retrofit = new Retrofit.Builder() .baseUrl(URL) // 设置网络请求的公共Url地址 .addConverterFactory(GsonConverterFactory.create()) // 设置数据解析器Gson // .addCallAdapterFactory(RxJava2CallAdapterFactory.create()) // 如果需要使用RxJava2 .build(); 4.构造接口实体\nApi api = retrofit.create(Api.class); 5.构造Call，这里的Call是retrofit2的Call，与okHttp的Call还是不一样的，如果是使用RxJava2，则为Observable\nretrofit2.Call\u0026lt;WeatherEntity\u0026gt; call = api.getNowWeather(\u0026#34;beijing\u0026#34;, KEY); // Observable\u0026lt;WeatherEntity\u0026gt; observable = api.getNowWeather(\u0026#34;beijing\u0026#34;, KEY); 6.调用call.enqueue发送请求\ncall.enqueue(new retrofit2.Callback\u0026lt;WeatherEntity\u0026gt;() { @Override public void onResponse(retrofit2.Call\u0026lt;WeatherEntity\u0026gt; call, retrofit2.Response\u0026lt;WeatherEntity\u0026gt; response) { WeatherEntity entity = response.body(); textView.setText(entity.toString()); } @Override public void onFailure(retrofit2.Call\u0026lt;WeatherEntity\u0026gt; call, Throwable t) { } }); // 如果是RxJava则按照设计在io线程请求数据，在mainThread主线程显示结果 // observable.subscribeOn(Schedulers.io()) // .observeOn(AndroidSchedulers.mainThread()) // .subscribe(new Consumer\u0026lt;WeatherEntity\u0026gt;() { // @Override // public void accept(WeatherEntity weatherEntity) throws Exception { // } // }, new Consumer\u0026lt;Throwable\u0026gt;() { // @Override // public void accept(Throwable throwable) throws Exception { // } // }); 3.2 Retrofit源码分析 Retrofit也采用了建造者模式，通过new Retrofit.Builder()初始化Retrofit对象\n// Retrofit.java 这里初始化Retrofit对象的时候需要参数Platform，看来是和平台相关 // 我们直到OkHttp是Java和Android相同都可以使用的，但是OkHttp没有做平台判断， // Retrofit需要平台判断应该是与后面一些功能相关 public Builder() { this(Platform.get()); } // -------------------------------------------------------------------------- // Platform.java private static final Platform PLATFORM = findPlatform(); static Platform get() { return PLATFORM; } // 通过findPlatform获取平台信息 private static Platform findPlatform() { try { // 判断的方式简单粗暴，直接通过Class.forName找系统的类，通过抛出异常终止，妙啊妙啊 Class.forName(\u0026#34;android.os.Build\u0026#34;); if (Build.VERSION.SDK_INT != 0) { // 这里只看Android类 return new Android(); } } catch (ClassNotFoundException ignored) { } try { // 同理对Java平台 Class.forName(\u0026#34;java.util.Optional\u0026#34;); return new Java8(); } catch (ClassNotFoundException ignored) { } return new Platform(); } // Android继承自Platform static class Android extends Platform { @IgnoreJRERequirement // Guarded by API check. @Override boolean isDefaultMethod(Method method) { if (Build.VERSION.SDK_INT \u0026lt; 24) { return false; } return method.isDefault(); } // defaultCallbackExecutor返回了MainThreadExecutor，Executor是一个接口， // 实现此接口的类需要完成execute方法，通过execute方法可以运行Runnable对象 @Override public Executor defaultCallbackExecutor() { return new MainThreadExecutor(); } // 两个关键的类CallAdapter和Converter，CallAdapter用于转换Call的类型，以RxJava2CallAdapterFactory为例， // 如果在构造Retrofit对象时加上了addCallAdapterFactory(RxJava2CallAdapterFactory.create())， // 则需要对Api类中的方法返回值类型进行修改，改为RxJava支持的Observable类型，然后就可以通过RxJava的方式发送请求； // Converter用于对Response的Body进行格式转换，以GsonConverterFactory为例，可以将Response的Body中的json数据实体化， // 直接转换为我们定义的对象。 @Override List\u0026lt;? extends CallAdapter.Factory\u0026gt; defaultCallAdapterFactories( @Nullable Executor callbackExecutor) { if (callbackExecutor == null) throw new AssertionError(); // 根据BuildSDKVersion决定用DefaultCallAdapterFactory还是CompletableFutureCallAdapterFactory // 暂时用不到，稍后再分析 DefaultCallAdapterFactory executorFactory = new DefaultCallAdapterFactory(callbackExecutor); return Build.VERSION.SDK_INT \u0026gt;= 24 ? asList(CompletableFutureCallAdapterFactory.INSTANCE, executorFactory) : singletonList(executorFactory); } @Override int defaultCallAdapterFactoriesSize() { return Build.VERSION.SDK_INT \u0026gt;= 24 ? 2 : 1; } @Override List\u0026lt;? extends Converter.Factory\u0026gt; defaultConverterFactories() { // 同CallAdapter return Build.VERSION.SDK_INT \u0026gt;= 24 ? singletonList(OptionalConverterFactory.INSTANCE) : Collections.\u0026lt;Converter.Factory\u0026gt;emptyList(); } @Override int defaultConverterFactoriesSize() { return Build.VERSION.SDK_INT \u0026gt;= 24 ? 1 : 0; } // MainThreadExecutor实现了Executor接口，通过主线程的Handler运行Runnable对象 static class MainThreadExecutor implements Executor { private final Handler handler = new Handler(Looper.getMainLooper()); @Override public void execute(Runnable r) { handler.post(r); } } } // -------------------------------------------------------------------------- // Retrofit.java Retrofit初始化仅保存了平台信息 Builder(Platform platform) { this.platform = platform; } // 然后是baseUrl方法 /** * Set the API base URL. * * @see #baseUrl(HttpUrl) */ public Builder baseUrl(String baseUrl) { checkNotNull(baseUrl, \u0026#34;baseUrl == null\u0026#34;); return baseUrl(HttpUrl.get(baseUrl)); } // 对baseUrl的格式进行判断，必须以 / 结尾，否则抛出异常 public Builder baseUrl(HttpUrl baseUrl) { checkNotNull(baseUrl, \u0026#34;baseUrl == null\u0026#34;); List\u0026lt;String\u0026gt; pathSegments = baseUrl.pathSegments(); if (!\u0026#34;\u0026#34;.equals(pathSegments.get(pathSegments.size() - 1))) { throw new IllegalArgumentException(\u0026#34;baseUrl must end in /: \u0026#34; + baseUrl); } this.baseUrl = baseUrl; return this; } // 接下来是addConverterFactory方法，看起没有什么复杂的功能，只是将Converter.Factory的实现加入了list中， // 我们稍后再看GsonConverterFactory的源码 private final List\u0026lt;Converter.Factory\u0026gt; converterFactories = new ArrayList\u0026lt;\u0026gt;(); /** Add converter factory for serialization and deserialization of objects. */ public Builder addConverterFactory(Converter.Factory factory) { converterFactories.add(checkNotNull(factory, \u0026#34;factory == null\u0026#34;)); return this; } // 最后是build方法 /** * Create the {@link Retrofit} instance using the configured values. * \u0026lt;p\u0026gt; * Note: If neither {@link #client} nor {@link #callFactory} is called a default {@link * OkHttpClient} will be created and used. */ public Retrofit build() { if (baseUrl == null) { throw new IllegalStateException(\u0026#34;Base URL required.\u0026#34;); } // 注意这里初始化了一个OkHttpClient对象 okhttp3.Call.Factory callFactory = this.callFactory; if (callFactory == null) { callFactory = new OkHttpClient(); } Executor callbackExecutor = this.callbackExecutor; if (callbackExecutor == null) { // 我们知道默认情况下，在Android平台，这个callbackExecutor是主线程的Executor callbackExecutor = platform.defaultCallbackExecutor(); } // Make a defensive copy of the adapters and add the default Call adapter. // callAdapterFactories包括通过Retrofit初始化调用addCallAdapterFactory加入的CallAdapter.Factory， // 还包括Android平台默认的platform.defaultCallAdapterFactories List\u0026lt;CallAdapter.Factory\u0026gt; callAdapterFactories = new ArrayList\u0026lt;\u0026gt;(this.callAdapterFactories); callAdapterFactories.addAll(platform.defaultCallAdapterFactories(callbackExecutor)); // Make a defensive copy of the converters. // converterFactories同理，但是多一个BuiltInConverters，暂时不去管不同的Converter的具体实现 List\u0026lt;Converter.Factory\u0026gt; converterFactories = new ArrayList\u0026lt;\u0026gt;( 1 + this.converterFactories.size() + platform.defaultConverterFactoriesSize()); // Add the built-in converter factory first. This prevents overriding its behavior but also // ensures correct behavior when using converters that consume all types. converterFactories.add(new BuiltInConverters()); converterFactories.addAll(this.converterFactories); converterFactories.addAll(platform.defaultConverterFactories()); // 最后完成了Retrofit对象的初始化，引入了几个参数，包括OkHttpClient对象，baseUrl，CallAdapter， // Converter以及Executor，validateEagerly默认为false return new Retrofit(callFactory, baseUrl, unmodifiableList(converterFactories), unmodifiableList(callAdapterFactories), callbackExecutor, validateEagerly); } 接下来是Api api = retrofit.create(Api.class);，Retrofit通过调用create方法将接口类实例化\n@SuppressWarnings(\u0026#34;unchecked\u0026#34;) // Single-interface proxy creation guarded by parameter safety. public \u0026lt;T\u0026gt; T create(final Class\u0026lt;T\u0026gt; service) { // validateServiceInterface主要判断service是否为接口且没有继承自其他接口 Utils.validateServiceInterface(service); // validateEagerly为false if (validateEagerly) { eagerlyValidateMethods(service); } // 通过代理的方式反射接口，将其实例化 return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class\u0026lt;?\u0026gt;[] { service }, new InvocationHandler() { // 这里不同的平台有不同的方式 private final Platform platform = Platform.get(); private final Object[] emptyArgs = new Object[0]; @Override public @Nullable Object invoke(Object proxy, Method method, @Nullable Object[] args) throws Throwable { // If the method is a method from Object then defer to normal invocation. // 这里的invoke，Object方法都走这里，比如equals、toString、hashCode什么的 if (method.getDeclaringClass() == Object.class) { return method.invoke(this, args); } // 如果是Java Web项目则通过platform.invokeDefaultMethod if (platform.isDefaultMethod(method)) { return platform.invokeDefaultMethod(method, service, proxy, args); } // 如果是Android则通过loadServiceMethod return loadServiceMethod(method).invoke(args != null ? args : emptyArgs); } }); } private void eagerlyValidateMethods(Class\u0026lt;?\u0026gt; service) { Platform platform = Platform.get(); for (Method method : service.getDeclaredMethods()) { if (!platform.isDefaultMethod(method) \u0026amp;\u0026amp; !Modifier.isStatic(method.getModifiers())) { loadServiceMethod(method); } } } ServiceMethod\u0026lt;?\u0026gt; loadServiceMethod(Method method) { ServiceMethod\u0026lt;?\u0026gt; result = serviceMethodCache.get(method); if (result != null) return result; // 默认result为空，通过单例模式取result，简而言之就是得到接口里面定义的方法 // 并且在方法被调用的时候将参数传入，从而得到结果 synchronized (serviceMethodCache) { result = serviceMethodCache.get(method); if (result == null) { // result = ServiceMethod.parseAnnotations(this, method); serviceMethodCache.put(method, result); } } return result; } // -------------------------------------------------------------------------- // ServiceMethod.java abstract class ServiceMethod\u0026lt;T\u0026gt; { // parseAnnotations还是通过RequestFactory解析接口的方法，因为我们定义的方法是包含注解的，所以必定需要通过 // 解析注解的值来控制方法的参数 static \u0026lt;T\u0026gt; ServiceMethod\u0026lt;T\u0026gt; parseAnnotations(Retrofit retrofit, Method method) { // RequestFactory看名字就知道应该和构建HTTP请求相关，应该是将retrofit定义的baseUrl等信息以及接口定义的方法， // 包括注解里的信息整合 RequestFactory requestFactory = RequestFactory.parseAnnotations(retrofit, method); Type returnType = method.getGenericReturnType(); if (Utils.hasUnresolvableType(returnType)) { throw methodError(method, \u0026#34;Method return type must not include a type variable or wildcard: %s\u0026#34;, returnType); } if (returnType == void.class) { throw methodError(method, \u0026#34;Service methods cannot return void.\u0026#34;); } // HttpServiceMethod继承自ServiceMethod，实现invoke方法，即最终我们调用接口中的方式时将参数传入 return HttpServiceMethod.parseAnnotations(retrofit, method, requestFactory); } abstract @Nullable T invoke(Object[] args); } // -------------------------------------------------------------------------- // RequestFactory.java static RequestFactory parseAnnotations(Retrofit retrofit, Method method) { return new Builder(retrofit, method).build(); } // build方法构建的实例 RequestFactory build() { for (Annotation annotation : methodAnnotations) { // 在parseMethodAnnotation中处理接口方法的注解，这里仅保存了请求方法以及 // 方法注解中的value parseMethodAnnotation(annotation); } if (httpMethod == null) { throw methodError(method, \u0026#34;HTTP method annotation is required (e.g., @GET, @POST, etc.).\u0026#34;); } if (!hasBody) { if (isMultipart) { throw methodError(method, \u0026#34;Multipart can only be specified on HTTP methods with request body (e.g., @POST).\u0026#34;); } if (isFormEncoded) { throw methodError(method, \u0026#34;FormUrlEncoded can only be specified on HTTP methods with \u0026#34; + \u0026#34;request body (e.g., @POST).\u0026#34;); } } // parameterAnnotationsArray是通过Method传过来的，简单来说就是方法的参数注解， // 即我们使用的@Query(\u0026#34;location\u0026#34;)和@Query(\u0026#34;key\u0026#34;) int parameterCount = parameterAnnotationsArray.length; parameterHandlers = new ParameterHandler\u0026lt;?\u0026gt;[parameterCount]; for (int p = 0, lastParameter = parameterCount - 1; p \u0026lt; parameterCount; p++) { // 通过parseParameter方法处理参数注解，并保存在parameterHandlers中 parameterHandlers[p] = parseParameter(p, parameterTypes[p], parameterAnnotationsArray[p], p == lastParameter); } if (relativeUrl == null \u0026amp;\u0026amp; !gotUrl) { throw methodError(method, \u0026#34;Missing either @%s URL or @Url parameter.\u0026#34;, httpMethod); } if (!isFormEncoded \u0026amp;\u0026amp; !isMultipart \u0026amp;\u0026amp; !hasBody \u0026amp;\u0026amp; gotBody) { throw methodError(method, \u0026#34;Non-body HTTP method cannot contain @Body.\u0026#34;); } if (isFormEncoded \u0026amp;\u0026amp; !gotField) { throw methodError(method, \u0026#34;Form-encoded method must contain at least one @Field.\u0026#34;); } if (isMultipart \u0026amp;\u0026amp; !gotPart) { throw methodError(method, \u0026#34;Multipart method must contain at least one @Part.\u0026#34;); } return new RequestFactory(this); } // parseMethodAnnotation处理的是方法注解即 @GET(\u0026#34;now?\u0026#34;) ，now?作为value // 根据不同的注解类型，构造不同的请求方法 private void parseMethodAnnotation(Annotation annotation) { if (annotation instanceof DELETE) { parseHttpMethodAndPath(\u0026#34;DELETE\u0026#34;, ((DELETE) annotation).value(), false); } else if (annotation instanceof GET) { parseHttpMethodAndPath(\u0026#34;GET\u0026#34;, ((GET) annotation).value(), false); } else if (annotation instanceof HEAD) { parseHttpMethodAndPath(\u0026#34;HEAD\u0026#34;, ((HEAD) annotation).value(), false); } else if (annotation instanceof PATCH) { parseHttpMethodAndPath(\u0026#34;PATCH\u0026#34;, ((PATCH) annotation).value(), true); } else if (annotation instanceof POST) { parseHttpMethodAndPath(\u0026#34;POST\u0026#34;, ((POST) annotation).value(), true); } else if (annotation instanceof PUT) { parseHttpMethodAndPath(\u0026#34;PUT\u0026#34;, ((PUT) annotation).value(), true); } else if (annotation instanceof OPTIONS) { parseHttpMethodAndPath(\u0026#34;OPTIONS\u0026#34;, ((OPTIONS) annotation).value(), false); } else if (annotation instanceof HTTP) { HTTP http = (HTTP) annotation; parseHttpMethodAndPath(http.method(), http.path(), http.hasBody()); } else if (annotation instanceof retrofit2.http.Headers) { String[] headersToParse = ((retrofit2.http.Headers) annotation).value(); if (headersToParse.length == 0) { throw methodError(method, \u0026#34;@Headers annotation is empty.\u0026#34;); } headers = parseHeaders(headersToParse); } else if (annotation instanceof Multipart) { if (isFormEncoded) { throw methodError(method, \u0026#34;Only one encoding annotation is allowed.\u0026#34;); } isMultipart = true; } else if (annotation instanceof FormUrlEncoded) { if (isMultipart) { throw methodError(method, \u0026#34;Only one encoding annotation is allowed.\u0026#34;); } isFormEncoded = true; } } private void parseHttpMethodAndPath(String httpMethod, String value, boolean hasBody) { if (this.httpMethod != null) { throw methodError(method, \u0026#34;Only one HTTP method is allowed. Found: %s and %s.\u0026#34;, this.httpMethod, httpMethod); } // 保存了请求方法 this.httpMethod = httpMethod; this.hasBody = hasBody; if (value.isEmpty()) { return; } // Get the relative URL path and existing query string, if present. // 这里的判断是确保@GET(\u0026#34;now?location={location}\u0026amp;key={key}\u0026#34;)其中的location={location}\u0026amp;key={key}不会出现， // 因为需要通过@Query注解构建，所以这里不允许使用 int question = value.indexOf(\u0026#39;?\u0026#39;); if (question != -1 \u0026amp;\u0026amp; question \u0026lt; value.length() - 1) { // Ensure the query string does not have any named parameters. String queryParams = value.substring(question + 1); Matcher queryParamMatcher = PARAM_URL_REGEX.matcher(queryParams); if (queryParamMatcher.find()) { throw methodError(method, \u0026#34;URL query string \\\u0026#34;%s\\\u0026#34; must not have replace block. \u0026#34; + \u0026#34;For dynamic query parameters use @Query.\u0026#34;, queryParams); } } this.relativeUrl = value; this.relativeUrlParamNames = parsePathParameters(value); } // parseParameter方法，对于同一个参数似乎可以使用多个参数注解Annotation[] annotations private @Nullable ParameterHandler\u0026lt;?\u0026gt; parseParameter( int p, Type parameterType, @Nullable Annotation[] annotations, boolean allowContinuation) { ParameterHandler\u0026lt;?\u0026gt; result = null; if (annotations != null) { for (Annotation annotation : annotations) { // 调用parseParameterAnnotation对参数注解进行处理，其中还包括传入的参数类型parameterType ParameterHandler\u0026lt;?\u0026gt; annotationAction = parseParameterAnnotation(p, parameterType, annotations, annotation); if (annotationAction == null) { continue; } if (result != null) { throw parameterError(method, p, \u0026#34;Multiple Retrofit annotations found, only one allowed.\u0026#34;); } result = annotationAction; } } if (result == null) { if (allowContinuation) { try { if (Utils.getRawType(parameterType) == Continuation.class) { isKotlinSuspendFunction = true; return null; } } catch (NoClassDefFoundError ignored) { } } throw parameterError(method, p, \u0026#34;No Retrofit annotation found.\u0026#34;); } return result; } // parseParameterAnnotation方法，这里判断参数注解的类型，我们只看@Query @Nullable private ParameterHandler\u0026lt;?\u0026gt; parseParameterAnnotation( int p, Type type, Annotation[] annotations, Annotation annotation) { if (annotation instanceof Url) { // ... } else if (annotation instanceof Path) { // ... } else if (annotation instanceof Query) { validateResolvableType(p, type); Query query = (Query) annotation; String name = query.value(); boolean encoded = query.encoded(); Class\u0026lt;?\u0026gt; rawParameterType = Utils.getRawType(type); gotQuery = true; // 判断参数类型是否为可迭代类或者Array类，目前我们的参数是String，所以直接到最后一个条件 if (Iterable.class.isAssignableFrom(rawParameterType)) { if (!(type instanceof ParameterizedType)) { throw parameterError(method, p, rawParameterType.getSimpleName() + \u0026#34; must include generic type (e.g., \u0026#34; + rawParameterType.getSimpleName() + \u0026#34;\u0026lt;String\u0026gt;)\u0026#34;); } ParameterizedType parameterizedType = (ParameterizedType) type; Type iterableType = Utils.getParameterUpperBound(0, parameterizedType); Converter\u0026lt;?, String\u0026gt; converter = retrofit.stringConverter(iterableType, annotations); return new ParameterHandler.Query\u0026lt;\u0026gt;(name, converter, encoded).iterable(); } else if (rawParameterType.isArray()) { Class\u0026lt;?\u0026gt; arrayComponentType = boxIfPrimitive(rawParameterType.getComponentType()); Converter\u0026lt;?, String\u0026gt; converter = retrofit.stringConverter(arrayComponentType, annotations); return new ParameterHandler.Query\u0026lt;\u0026gt;(name, converter, encoded).array(); } else { // 这里调用了retrofit.stringConverter方法，将参数类型和注解进行处理， // 这里ParameterHandler.Query\u0026lt;\u0026gt;保存了参数注解的value、Converter以及参数注解的编码方式 Converter\u0026lt;?, String\u0026gt; converter = retrofit.stringConverter(type, annotations); return new ParameterHandler.Query\u0026lt;\u0026gt;(name, converter, encoded); } } // ... return null; // Not a Retrofit annotation. } // -------------------------------------------------------------------------- // Retrofit.java stringConverter通过遍历converterFactories，调用它们的stringConverter方法， // 看谁能够处理并返回一个Converter\u0026lt;T, String\u0026gt;，如果都没有则调用BuiltInConverters， // 而Converter是用于构造HTTP请求 /** * Returns a {@link Converter} for {@code type} to {@link String} from the available * {@linkplain #converterFactories() factories}. */ public \u0026lt;T\u0026gt; Converter\u0026lt;T, String\u0026gt; stringConverter(Type type, Annotation[] annotations) { checkNotNull(type, \u0026#34;type == null\u0026#34;); checkNotNull(annotations, \u0026#34;annotations == null\u0026#34;); for (int i = 0, count = converterFactories.size(); i \u0026lt; count; i++) { Converter\u0026lt;?, String\u0026gt; converter = converterFactories.get(i).stringConverter(type, annotations, this); if (converter != null) { //noinspection unchecked return (Converter\u0026lt;T, String\u0026gt;) converter; } } // Nothing matched. Resort to default converter which just calls toString(). //noinspection unchecked return (Converter\u0026lt;T, String\u0026gt;) BuiltInConverters.ToStringConverter.INSTANCE; } 以上的代码完成了RequestFactory的构建，也就是说，这个RequestFactory包含了HTTP请求的部分信息，比如请求方法、请求url的参数、参数类型以及参数的位置，通过HttpServiceMethod.parseAnnotations(retrofit, method, requestFactory);对请求进行适配，包括通过Converter对返回的Response body数据处理以及通过CallAdapter修改Call类型\n// HttpServiceMethod.java HttpServiceMethod继承自ServiceMethod /** * Inspects the annotations on an interface method to construct a reusable service method that * speaks HTTP. This requires potentially-expensive reflection so it is best to build each service * method only once and reuse it. */ static \u0026lt;ResponseT, ReturnT\u0026gt; HttpServiceMethod\u0026lt;ResponseT, ReturnT\u0026gt; parseAnnotations( Retrofit retrofit, Method method, RequestFactory requestFactory) { boolean isKotlinSuspendFunction = requestFactory.isKotlinSuspendFunction; boolean continuationWantsResponse = false; boolean continuationBodyNullable = false; Annotation[] annotations = method.getAnnotations(); Type adapterType; if (isKotlinSuspendFunction) { Type[] parameterTypes = method.getGenericParameterTypes(); Type responseType = Utils.getParameterLowerBound(0, (ParameterizedType) parameterTypes[parameterTypes.length - 1]); if (getRawType(responseType) == Response.class \u0026amp;\u0026amp; responseType instanceof ParameterizedType) { // Unwrap the actual body type from Response\u0026lt;T\u0026gt;. responseType = Utils.getParameterUpperBound(0, (ParameterizedType) responseType); continuationWantsResponse = true; } else { // TODO figure out if type is nullable or not // Metadata metadata = method.getDeclaringClass().getAnnotation(Metadata.class) // Find the entry for method // Determine if return type is nullable or not } adapterType = new Utils.ParameterizedTypeImpl(null, Call.class, responseType); annotations = SkipCallbackExecutorImpl.ensurePresent(annotations); } else { adapterType = method.getGenericReturnType(); } CallAdapter\u0026lt;ResponseT, ReturnT\u0026gt; callAdapter = createCallAdapter(retrofit, method, adapterType, annotations); Type responseType = callAdapter.responseType(); if (responseType == okhttp3.Response.class) { throw methodError(method, \u0026#34;\u0026#39;\u0026#34; + getRawType(responseType).getName() + \u0026#34;\u0026#39; is not a valid response body type. Did you mean ResponseBody?\u0026#34;); } if (responseType == Response.class) { throw methodError(method, \u0026#34;Response must include generic type (e.g., Response\u0026lt;String\u0026gt;)\u0026#34;); } // TODO support Unit for Kotlin? if (requestFactory.httpMethod.equals(\u0026#34;HEAD\u0026#34;) \u0026amp;\u0026amp; !Void.class.equals(responseType)) { throw methodError(method, \u0026#34;HEAD method must use Void as response type.\u0026#34;); } Converter\u0026lt;ResponseBody, ResponseT\u0026gt; responseConverter = createResponseConverter(retrofit, method, responseType); okhttp3.Call.Factory callFactory = retrofit.callFactory; // isKotlinSuspendFunction和continuationWantsResponse默认为false，所以返回的是SuspendForBody if (!isKotlinSuspendFunction) { return new CallAdapted\u0026lt;\u0026gt;(requestFactory, callFactory, responseConverter, callAdapter); } else if (continuationWantsResponse) { //noinspection unchecked Kotlin compiler guarantees ReturnT to be Object. return (HttpServiceMethod\u0026lt;ResponseT, ReturnT\u0026gt;) new SuspendForResponse\u0026lt;\u0026gt;(requestFactory, callFactory, responseConverter, (CallAdapter\u0026lt;ResponseT, Call\u0026lt;ResponseT\u0026gt;\u0026gt;) callAdapter); } else { //noinspection unchecked Kotlin compiler guarantees ReturnT to be Object. return (HttpServiceMethod\u0026lt;ResponseT, ReturnT\u0026gt;) new SuspendForBody\u0026lt;\u0026gt;(requestFactory, callFactory, responseConverter, (CallAdapter\u0026lt;ResponseT, Call\u0026lt;ResponseT\u0026gt;\u0026gt;) callAdapter, continuationBodyNullable); } } // Retrofit的create方法调用了loadServiceMethod(method).invoke(args != null ? args : emptyArgs); // 此处的invoke即HttpServiceMethod的invoke方法，这里创建了OkHttpCall， // 此处的adapt即SuspendForBody的adapt方法，而SuspendForBody的adapt方法调用了callAdapter的adapt方法， // 最终回到了我们在Retrofit初始化时使用的DefaultCallAdapterFactory的adapt方法，如果我们使用其他callAdapter， // 比如RxJava2CallAdapterFactory，那么返回值就是RxJava2CallAdapterFactory的adapt方法的返回值 @Override final @Nullable ReturnT invoke(Object[] args) { Call\u0026lt;ResponseT\u0026gt; call = new OkHttpCall\u0026lt;\u0026gt;(requestFactory, args, callFactory, responseConverter); return adapt(call, args); } // DefaultCallAdapterFactory.java 返回了一个Call ExecutorCallbackCall @Override public Call\u0026lt;Object\u0026gt; adapt(Call\u0026lt;Object\u0026gt; call) { return executor == null ? call : new ExecutorCallbackCall\u0026lt;\u0026gt;(executor, call); } static final class ExecutorCallbackCall\u0026lt;T\u0026gt; implements Call\u0026lt;T\u0026gt; { final Executor callbackExecutor; final Call\u0026lt;T\u0026gt; delegate; ExecutorCallbackCall(Executor callbackExecutor, Call\u0026lt;T\u0026gt; delegate) { this.callbackExecutor = callbackExecutor; this.delegate = delegate; } // ExecutorCallbackCall是通过callbackExecutor执行Runnable，还记得在Platform类中的Android内部类的默认Executor吗， // MainThreadExecutor，所以后续调用call.enqueue时都是在这里处理的，而且delegate为OkHttpCall，OkHttpCall执行enqueue @Override public void enqueue(final Callback\u0026lt;T\u0026gt; callback) { checkNotNull(callback, \u0026#34;callback == null\u0026#34;); delegate.enqueue(new Callback\u0026lt;T\u0026gt;() { @Override public void onResponse(Call\u0026lt;T\u0026gt; call, final Response\u0026lt;T\u0026gt; response) { callbackExecutor.execute(new Runnable() { @Override public void run() { if (delegate.isCanceled()) { // Emulate OkHttp\u0026#39;s behavior of throwing/delivering an IOException on cancellation. callback.onFailure(ExecutorCallbackCall.this, new IOException(\u0026#34;Canceled\u0026#34;)); } else { callback.onResponse(ExecutorCallbackCall.this, response); } } }); } @Override public void onFailure(Call\u0026lt;T\u0026gt; call, final Throwable t) { callbackExecutor.execute(new Runnable() { @Override public void run() { callback.onFailure(ExecutorCallbackCall.this, t); } }); } }); } @Override public boolean isExecuted() { return delegate.isExecuted(); } @Override public Response\u0026lt;T\u0026gt; execute() throws IOException { return delegate.execute(); } @Override public void cancel() { delegate.cancel(); } @Override public boolean isCanceled() { return delegate.isCanceled(); } @SuppressWarnings(\u0026#34;CloneDoesntCallSuperClone\u0026#34;) // Performing deep clone. @Override public Call\u0026lt;T\u0026gt; clone() { return new ExecutorCallbackCall\u0026lt;\u0026gt;(callbackExecutor, delegate.clone()); } @Override public Request request() { return delegate.request(); } } 通过上述代码，Api api = retrofit.create(Api.class);主要还是通过代理反射创建了Api接口的实例，后续直接调用api.getNowWeather(\u0026quot;beijing\u0026quot;, KEY);就可以构造一个Call对象；在retrofit.create的过程中需要通过ServiceMethod以及初始化的Retrofit对象对Method的注解进行解析，转换为HttpServiceMethod对象进行请求适配，包括处理response body数据以及修改Call类型等等，然后构建OkHttpCall，返回ExecutorCallbackCall，所以后续OkHttpCall的enqueue方法可以进行回调。\n// OkHttpCall.java 继承自Call，这里执行的代码非常类似OkHttp的RealCall类 @Override public void enqueue(final Callback\u0026lt;T\u0026gt; callback) { checkNotNull(callback, \u0026#34;callback == null\u0026#34;); okhttp3.Call call; Throwable failure; synchronized (this) { if (executed) throw new IllegalStateException(\u0026#34;Already executed.\u0026#34;); executed = true; call = rawCall; failure = creationFailure; if (call == null \u0026amp;\u0026amp; failure == null) { try { // 我们需要把this，也就是OkHttpCall转换为OkHttpClient接受的Call，所以需要OkHttp的callFactory call = rawCall = createRawCall(); } catch (Throwable t) { throwIfFatal(t); failure = creationFailure = t; } } } if (failure != null) { callback.onFailure(this, failure); return; } if (canceled) { call.cancel(); } // 这里就直接使用了OkHttp的enqueue方法，然后再onResponse中处理rawResponse， // 通过parseResponse将返回的response body转为我们定义的数据，比如json-\u0026gt;WeatherEntity // 所以回调函数的结果包括Response\u0026lt;WeatherEntity\u0026gt; call.enqueue(new okhttp3.Callback() { @Override public void onResponse(okhttp3.Call call, okhttp3.Response rawResponse) { Response\u0026lt;T\u0026gt; response; try { response = parseResponse(rawResponse); } catch (Throwable e) { throwIfFatal(e); callFailure(e); return; } try { // 回调函数传出去 callback.onResponse(OkHttpCall.this, response); } catch (Throwable t) { throwIfFatal(t); t.printStackTrace(); // TODO this is not great } } @Override public void onFailure(okhttp3.Call call, IOException e) { callFailure(e); } private void callFailure(Throwable e) { try { callback.onFailure(OkHttpCall.this, e); } catch (Throwable t) { throwIfFatal(t); t.printStackTrace(); // TODO this is not great } } }); } // 将Call转换为OkHttp的Call，requestFactory.create(args)会构造RequestBuilder， // RequestBuilder就是将我们之前保存在各种对象中的参数拿出来组建出一个Http请求， // callFactory就是OkHttpClient对象 private okhttp3.Call createRawCall() throws IOException { okhttp3.Call call = callFactory.newCall(requestFactory.create(args)); if (call == null) { throw new NullPointerException(\u0026#34;Call.Factory returned null.\u0026#34;); } return call; } Response\u0026lt;T\u0026gt; parseResponse(okhttp3.Response rawResponse) throws IOException { ResponseBody rawBody = rawResponse.body(); // Remove the body\u0026#39;s source (the only stateful object) so we can pass the response along. rawResponse = rawResponse.newBuilder() .body(new NoContentResponseBody(rawBody.contentType(), rawBody.contentLength())) .build(); int code = rawResponse.code(); if (code \u0026lt; 200 || code \u0026gt;= 300) { try { // Buffer the entire body to avoid future I/O. ResponseBody bufferedBody = Utils.buffer(rawBody); return Response.error(bufferedBody, rawResponse); } finally { rawBody.close(); } } if (code == 204 || code == 205) { rawBody.close(); return Response.success(null, rawResponse); } // 一般来说数据请求正确，返回code为200，因此走这条路，注意responseConverter.convert，也就是我们使用的 // 再Retrofit初始化的converterFactories，包括我们加入的GsonConverterFactory，最终Response的body被转换为 // WeatherEntity ExceptionCatchingResponseBody catchingBody = new ExceptionCatchingResponseBody(rawBody); try { T body = responseConverter.convert(catchingBody); return Response.success(body, rawResponse); } catch (RuntimeException e) { // If the underlying source threw an exception, propagate that rather than indicating it was // a runtime exception. catchingBody.throwIfCaught(); throw e; } } // -------------------------------------------------------------------------- // GsonConverterFactory.java 提供GsonResponseBodyConverter给Retrofit对Response进行数据转换 public final class GsonConverterFactory extends Converter.Factory { /** * Create an instance using a default {@link Gson} instance for conversion. Encoding to JSON and * decoding from JSON (when no charset is specified by a header) will use UTF-8. */ public static GsonConverterFactory create() { return create(new Gson()); } /** * Create an instance using {@code gson} for conversion. Encoding to JSON and * decoding from JSON (when no charset is specified by a header) will use UTF-8. */ @SuppressWarnings(\u0026#34;ConstantConditions\u0026#34;) // Guarding public API nullability. public static GsonConverterFactory create(Gson gson) { if (gson == null) throw new NullPointerException(\u0026#34;gson == null\u0026#34;); return new GsonConverterFactory(gson); } private final Gson gson; private GsonConverterFactory(Gson gson) { this.gson = gson; } // responseBodyConverter被调用的位置是HttpServiceMethod的createResponseConverter @Override public Converter\u0026lt;ResponseBody, ?\u0026gt; responseBodyConverter(Type type, Annotation[] annotations, Retrofit retrofit) { TypeAdapter\u0026lt;?\u0026gt; adapter = gson.getAdapter(TypeToken.get(type)); return new GsonResponseBodyConverter\u0026lt;\u0026gt;(gson, adapter); } // requestBodyConverter被调用的位置在RequestFactory的parseParameterAnnotation @Override public Converter\u0026lt;?, RequestBody\u0026gt; requestBodyConverter(Type type, Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) { TypeAdapter\u0026lt;?\u0026gt; adapter = gson.getAdapter(TypeToken.get(type)); return new GsonRequestBodyConverter\u0026lt;\u0026gt;(gson, adapter); } } // GsonResponseBodyConverter.java final class GsonResponseBodyConverter\u0026lt;T\u0026gt; implements Converter\u0026lt;ResponseBody, T\u0026gt; { private final Gson gson; private final TypeAdapter\u0026lt;T\u0026gt; adapter; GsonResponseBodyConverter(Gson gson, TypeAdapter\u0026lt;T\u0026gt; adapter) { this.gson = gson; this.adapter = adapter; } // convert方法被执行的位置，也就是说通过TypeAdapter读取json数据并转换为java对象，这个具体实现需要分析Gson的源码 @Override public T convert(ResponseBody value) throws IOException { JsonReader jsonReader = gson.newJsonReader(value.charStream()); try { T result = adapter.read(jsonReader); if (jsonReader.peek() != JsonToken.END_DOCUMENT) { throw new JsonIOException(\u0026#34;JSON document was not fully consumed.\u0026#34;); } return result; } finally { value.close(); } } } 除了GsonConverterFactory，还可以分析一下RxJava2CallAdapterFactory，我们知道HttpServiceMethod的invoke返回的对象即为我们调用api.getNowWeather(\u0026quot;beijing\u0026quot;, KEY);得到的对象，而这个对象是通过callAdapter调用adapt方法返回的，默认情况下是DefaultCallAdapterFactory，如果我们在Retrofit初始化时通过addCallAdapterFactory增加了其他的CallAdapterFactory比如RxJava2CallAdapterFactory，那么会通过RxJava2CallAdapterFactory调用RxJava2CallAdapter的adapt方法\n// RxJava2CallAdapterFactory.java RxJava2CallAdapterFactory的get方法必定返回RxJava2CallAdapter对象 public static RxJava2CallAdapterFactory create() { return new RxJava2CallAdapterFactory(null, false); } private RxJava2CallAdapterFactory(@Nullable Scheduler scheduler, boolean isAsync) { this.scheduler = scheduler; this.isAsync = isAsync; } // RxJava2CallAdapter.java 所以具体的adapt方法由RxJava2CallAdapter实现 @Override public Object adapt(Call\u0026lt;R\u0026gt; call) { // 主要请求的完成过程在CallEnqueueObservable中，异步的 Observable\u0026lt;Response\u0026lt;R\u0026gt;\u0026gt; responseObservable = isAsync ? new CallEnqueueObservable\u0026lt;\u0026gt;(call) : new CallExecuteObservable\u0026lt;\u0026gt;(call); Observable\u0026lt;?\u0026gt; observable; // ResultObservable和BodyObservable都是继承自Observable，用于返回结果 if (isResult) { observable = new ResultObservable\u0026lt;\u0026gt;(responseObservable); } else if (isBody) { observable = new BodyObservable\u0026lt;\u0026gt;(responseObservable); } else { observable = responseObservable; } if (scheduler != null) { observable = observable.subscribeOn(scheduler); } if (isFlowable) { return observable.toFlowable(BackpressureStrategy.LATEST); } if (isSingle) { return observable.singleOrError(); } if (isMaybe) { return observable.singleElement(); } if (isCompletable) { return observable.ignoreElements(); } return RxJavaPlugins.onAssembly(observable); } // CallEnqueueObservable.java 当我们得到的observable执行subscribe方法时 // 实际调用了subscribeActual方法，对应上面的CallEnqueueObservable @Override protected void subscribeActual(Observer\u0026lt;? super Response\u0026lt;T\u0026gt;\u0026gt; observer) { // Since Call is a one-shot type, clone it for each new observer. Call\u0026lt;T\u0026gt; call = originalCall.clone(); CallCallback\u0026lt;T\u0026gt; callback = new CallCallback\u0026lt;\u0026gt;(call, observer); observer.onSubscribe(callback); if (!callback.isDisposed()) { // 这个call是在HttpServiceMethod中构建的OkHttpCall，OkHttpCall调用enqueue不必多说了吧 call.enqueue(callback); } } 综上所述，Retrofit是一个比较灵活的网络请求框架，从设计上就是为了便于增加其他组件而设计的，首先是Api接口的设计，为了更加方便控制请求参数，通过接口加注解设计请求的url，而同时我们又不必实现此接口，通过代理反射的方式对接口实体化，相当于解耦了请求url与Retrofit实例；\n其次是CallAdapter的设计，我们可以灵活的设计自己的CallAdapter用于同步或异步请求，因为在HttpServiceMethod被调用的时候是通过获取Retrofit初始化时设置的CallAdapter来实现返回，所以只需要自定义CallAdapter，我们就可以按照自己的需求处理请求的过程并拿到返回值；\n然后是与Gson的联动，在拿到返回Response的时候，对json数据进行转换，并且将实体通过回调传出来，都是为了灵活使用而设计的；\n最后是Retrofit与OkHttp的结合，Retrofit本质上还是调用OkHttp的请求，但是通过上述方式增加其灵活性，而且由于OkHttpCall的连接，我们一方面可以直接使用OkHttpClient，另一方面返回的Response可以直接处理，其中又包括非常多的泛型，这种设计思路真是妙啊妙啊。\n参考： HTTPS Tutorials HTTP 协议入门 Retrofit OkHttp OkHttp使用详解 Introduction to Retrofit Android Retrofit 2.5.0使用基础详解 Retrofit使用拦截器添加Cookie Factory Pattern ","permalink":"https://zhoutao822.github.io/posts/retrofit/","summary":"Http，超文本传输协议，Https，更加安全的超文本传输协议，目前大量用于客户端与服务端之间的信息交流，属于应用层协议，下面有传输层TCP协议、网络层IP协议以及数据链路层为其提供保障。以登录功能为例，每一次输入账户密码后点击登录按钮就做了一次对服务器的Http请求（POST），我们收到的结果比如账号密码错误或者登录成功等信息就是服务器对Http请求的回复。Http与Https的区别在于后者采用了SSL（Secure Socket Layer安全套接层），简而言之就是对传输的数据进行了加密。具体细节可以在\u003ca href=\"https://www.tutorialsteacher.com/https\"\u003eHTTPS Tutorials\u003c/a\u003e或者其他资料中找到。","title":"Android框架-Retrofit与OkHttp"},{"content":"Dagger2框架是一个依赖注入框架，它既可以用于Java Web项目也可以用于Android项目，依赖注入是什么意思呢\npublic class Dependent { private Dependency dependency; // 属性注入 public Dependent(Dependency dependency) { this.dependency = dependency; } // public Dependent(){ // this.dependency = new Dependency(); // } // 方法注入 // public void setDependency(Dependency dependency){ // this.dependency = dependency; // } private void doSomething(){ } } 看名字知含义，在上面的代码中Dependent类的构造始终需要Dependency类，那么我们就称Dependency为依赖，将其引入Dependent中的过程称为注入，上述代码在构造函数中引入，当然也可以通过set方法注入，无论是哪种方式都会面临一个问题就是当我们后续如果需要修改Dependency的构造函数时，需要在所有包含new Dependency()的代码中进行修改，显然这是非常痛苦的事情，而且不符合依赖倒置原则，本文所涉及到的是通过注解的方式进行依赖注入可以解决这种问题。\n1. Dagger2框架入门 Dagger2框架最终的概念是注解，注解有什么用呢，我觉得是一种标记，这是由于Dagger2框架最终是通过根据不同的注解自动生成代码来实现的依赖注入，因此不同的注解表示通过不同的逻辑生成代码以实现其功能。\n从最简单最基础的注解开始，一步一步深入，了解其生成的源码的作用。\n1.1 @Inject和@Component 比如我们需要一个Utils类\npublic class Utils { public Utils() { } public String showMessage() { return \u0026#34;This is Utils\u0026#34;; } } 然后在MainActivity中使用showMessage方法\npublic class MainActivity extends AppCompatActivity { private static final String TAG = MainActivity.class.getSimpleName(); private Utils utils; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); // 这里需要new一个对象出来才能调用showMessage方法 utils = new Utils(); Log.i(TAG, utils.showMessage()); } } 如果需要在其他Activity中继续使用Utils的showMessage方法，那么就需要重复在每一个Activity中new一个Utils对象，这时候产品经理来了跟你说在使用Utils的时候还需要使用ToastUtils，而且需要修改Utils的构造函数，将ToastUtils传进去\npublic class ToastUtils { public ToastUtils() { } public String showMessage() { return \u0026#34;This is ToastUtils\u0026#34;; } } public class Utils { private ToastUtils toastUtils; public Utils(ToastUtils toastUtils) { this.toastUtils = toastUtils; } public String showMessage() { return toastUtils.showMessage(); } } 此时，你是不是要疯了，需要在所有调用new Utils()的位置进行修改，也就意味着每一次修改构造函数都需要全部重新修改一次。\n通过dagger2框架是如何实现依赖注入的呢？\n首先是在依赖的构造函数上加上@Inject public class Utils { @Inject public Utils() { } public String showMessage() { return \u0026#34;This is Utils\u0026#34;; } } 然后新建一个接口MainActivityComponent，要加上@Component，声明inject方法，参数为依赖被注入的类，这个接口向dagger2框架表明了需要注入的目标，即依赖者dependent @Component public interface MainActivityComponent { void inject(MainActivity activity); } 最后在MainActivity中使用，直接在依赖上增加注解@Inject，在onCreate方法中调用DaggerMainActivityComponent.create().inject(this);，然后utils就被实例化了，可以直接使用，这里并没有看见new对象的操作 public class MainActivity extends AppCompatActivity { private static final String TAG = MainActivity.class.getSimpleName(); @Inject Utils utils; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); // 在调用DaggerMainActivityComponent.create().inject(this)方法前先build一下， // 会自动生成一些代码，其中包括DaggerMainActivityComponent类，否则无法使用 DaggerMainActivityComponent.create().inject(this); Log.i(TAG, utils.showMessage()); } } 我们来看一下生成代码实现了哪些功能吧，主要包括三个类DaggerMainActivityComponent.java、MainActivity_MembersInjector.java、Utils_Factory.java\n// DaggerMainActivityComponent.java // DaggerMainActivityComponent是根据MainActivityComponent生成的，按照执行顺序分析 public final class DaggerMainActivityComponent implements MainActivityComponent { // 3. DaggerMainActivityComponent构造函数 private DaggerMainActivityComponent() { } public static Builder builder() { return new Builder(); } // 1. create方法返回Builder().build()方法返回的对象 public static MainActivityComponent create() { return new Builder().build(); } // 4. 调用inject方法 @Override public void inject(MainActivity activity) { injectMainActivity(activity);} // 5. inject方法实际执行的方法injectMainActivity private MainActivity injectMainActivity(MainActivity instance) { // 6. 调用MainActivity_MembersInjector.injectUtils(instance, new Utils())，这里出现了new出来的实例 // 接下来看MainActivity_MembersInjector类做了些什么 MainActivity_MembersInjector.injectUtils(instance, new Utils()); return instance; } public static final class Builder { private Builder() { } // 2. Builder().build()返回的对象是DaggerMainActivityComponent public MainActivityComponent build() { return new DaggerMainActivityComponent(); } } } // MainActivity_MembersInjector.java public final class MainActivity_MembersInjector implements MembersInjector\u0026lt;MainActivity\u0026gt; { private final Provider\u0026lt;Utils\u0026gt; utilsProvider; public MainActivity_MembersInjector(Provider\u0026lt;Utils\u0026gt; utilsProvider) { this.utilsProvider = utilsProvider; } public static MembersInjector\u0026lt;MainActivity\u0026gt; create(Provider\u0026lt;Utils\u0026gt; utilsProvider) { return new MainActivity_MembersInjector(utilsProvider);} @Override public void injectMembers(MainActivity instance) { injectUtils(instance, utilsProvider.get()); } // 7. 接上面的执行，这就很明显了instance.utils = utils 等价于 MainActivity.utils = new Utils() // 也就是说到这里，其实依赖注入的功能就完成了，其他的代码并没有用到，但是不代表是无用的 public static void injectUtils(MainActivity instance, Utils utils) { instance.utils = utils; } } 按照增加ToastUtils的方式进行依赖注入是怎样的呢，需要修改如下代码\npublic class ToastUtils { // ToastUtils被Utils依赖，所以需要在构造函数上加上@Inject @Inject public ToastUtils(){ } public String showMessage(){ return \u0026#34;This is ToastUtils\u0026#34;; } } public class Utils { private ToastUtils toastUtils; // Utils的含参构造函数上加上@Inject @Inject public Utils(ToastUtils toastUtils) { this.toastUtils = toastUtils; } public String showMessage() { return toastUtils.showMessage(); } } MainActivityComponent.java和MainActivity.java不用修改任何代码，那不就意味着我们解决了前面注入产生的修改代码的问题吗，因为没有new对象的代码；而且ToastUtils在Utils中也不是通过new对象产生的，而是层层注解注入的。\n此时再次看一下生成的代码文件：\nDaggerMainActivityComponent.java\nMainActivity_MembersInjector.java\nUtils_Factory.java\nToastUtils_Factory.java：\npublic final class DaggerMainActivityComponent implements MainActivityComponent { private DaggerMainActivityComponent() { } public static Builder builder() { return new Builder(); } public static MainActivityComponent create() { return new Builder().build(); } // getUtils()即返回了我们需要的带参Utils对象 private Utils getUtils() { return new Utils(new ToastUtils());} @Override public void inject(MainActivity activity) { injectMainActivity(activity);} // 这次直接看核心代码，MainActivity_MembersInjector.injectUtils(instance, getUtils()) // MainActivity_MembersInjector.injectUtils方法也很熟悉了，效果同上文 private MainActivity injectMainActivity(MainActivity instance) { MainActivity_MembersInjector.injectUtils(instance, getUtils()); return instance; } public static final class Builder { private Builder() { } public MainActivityComponent build() { return new DaggerMainActivityComponent(); } } } 根据上文的分析，我们知道了我们需要的对象的实例其实是在生成的代码DaggerMainActivityComponent.java中new出来的，但是这个过程并不需要我们干预而是自动生成的，所以解决了部分依赖注入产生的问题。\n结合源码分析可知\n1.@Inject标注在构造器上的含义包括：\n告诉Dagger2可以使用这个构造器构建对象。如ToastUtils类 注入构造器所需要的参数的依赖。 如Utils类，构造上的ToastUtils会被注入。 构造器注入的局限：如果有多个构造器，我们只能标注其中一个，无法标注多个。\n2.@Component一般有两种方式定义方法\nvoid inject(目标类 obj);Dagger2会从目标类开始查找@Inject注解，自动生成依赖注入的代码，调用inject可完成依赖的注入。 Object getObj(); 如：Utils getUtils(); Dagger2会到Utils类中找被@Inject注解标注的构造器，自动生成提供Utils依赖的代码，这种方式一般为其他Component提供依赖。（一个Component可以依赖另一个Component，后面会说） Components所依赖的所有module里不能有重复的@Provides方法（重载，或者同返回类型的），这里还包括后面讲到的依赖的其他的Component也不能有重复的，因为Dagger无法判断你究竟想要那个作为依赖（也就是依赖迷失）\n使用接口定义，并且@Component注解。命名方式推荐为：目标类名+Component，在编译后Dagger2就会为我们生成DaggerXXXComponent这个类，它是我们定义的xxxComponent的实现，在目标类中使用它就可以实现依赖注入了。\n1.2 @Module和@Provides 使用@Inject标记构造器提供依赖是有局限性的，比如说我们需要注入的对象是第三方库提供的，我们无法在第三方库的构造器上加上@Inject注解。 或者，我们使用依赖倒置的时候，因为需要注入的对象是抽象的，@Inject也无法使用，因为抽象的类并不能实例化，比如：\npublic abstract class AbstractUtils { public abstract String showMessage(); } public class DBUtils extends AbstractUtils { @Inject DBUtils() {} @Override public String showMessage() { return \u0026#34;This is DBUtils\u0026#34;; } } public class ApiUtils extends AbstractUtils { @Inject ApiUtils() {} @Override public String showMessage() { return \u0026#34;This is ApiUtils\u0026#34;; } } public class DataUtils { private AbstractUtils abstractUtils; @Inject public DataUtils(AbstractUtils abstractUtils) { this.abstractUtils = abstractUtils; } public String show() { return abstractUtils.showMessage(); } } MainActivityComponent.java不变，如果在MainActivity中引入DataUtils会报错，此时需要修改代码\npublic class DBUtils extends AbstractUtils { @Override public String showMessage() { return \u0026#34;This is DBUtils\u0026#34;; } } public class ApiUtils extends AbstractUtils { @Override public String showMessage() { return \u0026#34;This is ApiUtils\u0026#34;; } } 需要新建一个Module类，用于提供需要的实例，这里返回的是DBUtils对象，@Provodes标记在方法上，表示可以通过这个方法获取依赖\n@Module public class AbstractUtilsModule { @Provides AbstractUtils provideDataUtils() { return new DBUtils(); } } 修改Component代码\n@Component(modules = AbstractUtilsModule.class) public interface MainActivityComponent { void inject(MainActivity activity); } 最后在MainActivity中引入\npublic class MainActivity extends AppCompatActivity { private static final String TAG = MainActivity.class.getSimpleName(); @Inject DataUtils dataUtils; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); DaggerMainActivityComponent.create().inject(this); // 很显然，这里引入的是DBUtils对象 Log.i(TAG, dataUtils.show()); } } 通过修改AbstractUtilsModule中provideDataUtils方法返回的对象，我们可以控制抽象类的具体子类是DBUtils还是ApiUtils，而主体代码不需要改动。\n生成代码分析包括：\nDaggerMainActivityComponent.java\nAbstractUtilsModule_ProvideDataUtilsFactory.java\nMainActivity_MembersInjector.java：\npublic final class DaggerMainActivityComponent implements MainActivityComponent { private final AbstractUtilsModule AbstractUtilsModule; private DaggerMainActivityComponent(AbstractUtilsModule abstractUtilsModuleParam) { this.AbstractUtilsModule = abstractUtilsModuleParam; } public static Builder builder() { return new Builder(); } public static MainActivityComponent create() { return new Builder().build(); } // 2. getDataUtils()返回的是 // new DataUtils(AbstractUtilsModule_ProvideDataUtilsFactory.provideDataUtils(AbstractUtilsModule)) // 构造函数的参数为AbstractUtilsModule_ProvideDataUtilsFactory.provideDataUtils(AbstractUtilsModule) // 接下来看这个方法provideDataUtils的返回值 private DataUtils getDataUtils() { return new DataUtils(AbstractUtilsModule_ProvideDataUtilsFactory.provideDataUtils(AbstractUtilsModule));} @Override public void inject(MainActivity activity) { injectMainActivity(activity);} // 1. 直接看核心代码，MainActivity_MembersInjector.injectDataUtils(instance, getDataUtils()) // 根据getDataUtils方法的返回值可知，其返回的是DataUtils实例 // MainActivity_MembersInjector.injectDataUtils方法也是很熟悉，同上 private MainActivity injectMainActivity(MainActivity instance) { MainActivity_MembersInjector.injectDataUtils(instance, getDataUtils()); return instance; } public static final class Builder { private AbstractUtilsModule AbstractUtilsModule; private Builder() { } public Builder AbstractUtilsModule(AbstractUtilsModule AbstractUtilsModule) { this.AbstractUtilsModule = Preconditions.checkNotNull(AbstractUtilsModule); return this; } public MainActivityComponent build() { if (AbstractUtilsModule == null) { this.AbstractUtilsModule = new AbstractUtilsModule(); } return new DaggerMainActivityComponent(AbstractUtilsModule); } } } public final class AbstractUtilsModule_ProvideDataUtilsFactory implements Factory\u0026lt;AbstractUtils\u0026gt; { private final AbstractUtilsModule module; public AbstractUtilsModule_ProvideDataUtilsFactory(AbstractUtilsModule module) { this.module = module; } @Override public AbstractUtils get() { return provideDataUtils(module); } public static AbstractUtilsModule_ProvideDataUtilsFactory create(AbstractUtilsModule module) { return new AbstractUtilsModule_ProvideDataUtilsFactory(module); } // 3. 上述代码直接调用的是下面这个方法，返回的是AbstractUtilsModule.provideDataUtils() // AbstractUtilsModule根据我们定义的时候可知，provideDataUtils返回的是new DBUtils()对象 public static AbstractUtils provideDataUtils(AbstractUtilsModule instance) { return Preconditions.checkNotNull(instance.provideDataUtils(), \u0026#34;Cannot return null from a non-@Nullable @Provides method\u0026#34;); } } @Module的含义是 通知Component，可以从我这里获取到构造好的对象；\n@Provide通常是在标记了@Module的类中用于标记返回实例的方法，根据我们的使用以及代码分析来看，实例的注入是根据类型自动判断的，也就是说，从MainActivity到Module的实例传递过程中，同一Module中同一类型的provide方法只能存在一个，否则就会报错，比如我们如果在AbstractUtilsModule中再加入一个provideDataUtils2方法，同样返回类型为AbstractUtils，那么MainActivity中的dataUtils就会遇到依赖迷失的问题，这两个方法返回一样，那该用哪一个，于是报错，此时可以通过限定符，也就是下文介绍的@Qualifier和@Named来区分。\n1.3 @Qualifier和@Named 直接上代码，首先是AbstractUtilsModule，通过添加@Named并指定一个字符来区别不同的实例，这里两个provide方法分别返回之前的两个AbstractUtils的子类DBUtils和ApiUtils。\n@Module public class AbstractUtilsModule { @Provides @Named(\u0026#34;DBUtils\u0026#34;) AbstractUtils provideDBUtils() { return new DBUtils(); } @Provides @Named(\u0026#34;ApiUtils\u0026#34;) AbstractUtils provideApiUtils() { return new ApiUtils(); } } 同时，需要修改DataUtils类，因为AbstractUtilsModule表示我们可以提供两种AbstractUtils，你到底要哪个的实例，此时需要在DataUtils构造函数的参数中加上@Named注解，与上面对应，表示我需要哪一种AbstractUtils\npublic class DataUtils { private AbstractUtils abstractUtils; @Inject public DataUtils(@Named(\u0026#34;ApiUtils\u0026#34;) AbstractUtils abstractUtils) { this.abstractUtils = abstractUtils; } public String show() { return abstractUtils.showMessage(); } } 其他代码不用修改，此时MainActivity中dataUtils.show()自然用的是ApiUtils。\n@Qualifier的作用与@Named的作用差不多，但是不需要自定义字符串，使用@Qualifier时不是直接用，而是通过@Qualifier自定义限定符\n@Qualifier @Retention(RetentionPolicy.RUNTIME) public @interface DBDataUtils { } @Qualifier @Retention(RetentionPolicy.RUNTIME) public @interface ApiDataUtils { } RetentionPolicy.RUNTIME代表注解会保存在.class文件，虚拟机会在运行时保留，具体有什么区别，暂时还不清楚。\n需要修改的地方有两处，一是AbstractUtilsModule，二是DataUtils，都是将@Named注解修改为自定义的限定符注解，此时Log结果变为DBUtils\n@Module public class AbstractUtilsModule { @Provides @DBDataUtils AbstractUtils provideDBUtils() { return new DBUtils(); } @Provides @ApiDataUtils AbstractUtils provideApiUtils() { return new ApiUtils(); } } public class DataUtils { private AbstractUtils abstractUtils; @Inject public DataUtils(@DBDataUtils AbstractUtils abstractUtils) { this.abstractUtils = abstractUtils; } public String show() { return abstractUtils.showMessage(); } } 在上面的代码中我们对DataUtils的构造方法进行Inject注解，这样的操作不是很合适，因为需要尽量少对实体类进行额外的修改，所以我们同样可以通过Module的方式provide一个DataUtils的对象，并在Module中对DataUtils的构造进行约束\n// 删掉Inject注解和限定符注解 public class DataUtils { private AbstractUtils abstractUtils; public DataUtils(AbstractUtils abstractUtils) { this.abstractUtils = abstractUtils; } public String show() { return abstractUtils.showMessage(); } } 新建一个DataUtilsModule用于提供DataUtils对象\n@Module public class DataUtilsModule { @Provides DataUtils provideDataUtils(@ApiDataUtils AbstractUtils abstractUtils) { return new DataUtils(abstractUtils); } } 修改MainActivityComponent的modules参数，增加DataUtilsModule.class\n@Component(modules = {AbstractUtilsModule.class, DataUtilsModule.class}) public interface MainActivityComponent { void inject(MainActivity activity); } 最后编译运行，log结果是ApiUtils，根据上述代码的运行，我们能够总结出一些运行的规则：\n首先当我们在MainActivity中调用inject方法时，其实是通过MainActivityComponent询问，可以去哪里找到我们需要的实例； MainActivityComponent定义了modules = {AbstractUtilsModule.class, DataUtilsModule.class}，告诉系统去这两个类中找； AbstractUtilsModule告诉系统我这里只能提供限定类型的AbstractUtils，DataUtilsModule告诉系统我这里可以提供DataUtils，这各类型恰好与MainActivity需要的实例类型相同，于是系统到DataUtilsModule的provide方法去找； 此时系统发现DataUtilsModule的provide方法是带参数AbstractUtils的，而且还有限定符，那么同样需要能够提供AbstractUtils的Module，这不是恰好与第3步的AbstractUtilsModule相同吗，那么就按照参数限定符找到AbstractUtilsModule的对应provide方法，结果发现它可以直接返回new ApiUtils()对象，正合我心，且不需要继续走下去，那么实例化完成。 在寻找实例的路线中需要用到的Module都必须加在Component中的modules参数中，否则这条路线走不通（DataUtilsModule -\u0026gt; AbstractUtilsModule），存在的问题是你需要知道所有路线上的Module并且将其加入到Component中，显然对于多级依赖产生的多个Module这是不合适的。\n1.4 @Component的dependence和@SubComponent Component除了可以提供inject方法以外还可以像Module一样提供实例，这样便于解决多级依赖导致的Module增加问题。\n首先创建提供ApiUtils和DBUtils实例的Component，其modules = AbstractUtilsModule.class，表明最终方法获取实例还是从Module拿到的，我Component只是交接一下，向外提供接口getDBUtils和getApiUtils\n// 同理这里的两个方法也需要限定符注解，表明需要从AbstractUtilsModule拿哪种实例，一般命名get+XXXEntity @Component(modules = AbstractUtilsModule.class) public interface AbstractUtilsComponent { @DBDataUtils AbstractUtils getDBUtils(); @ApiDataUtils AbstractUtils getApiUtils(); } 然后我们的MainActivity是需要DataUtils的实例，那么我们也需要提供DataUtils的Component\n// modules = DataUtilsModule.class表明实例来源于DataUtilsModule // dependencies = AbstractUtilsComponent.class表明我们可能需要AbstractUtilsComponent提供的实例 // 逻辑上也是对应的DataUtilsModule返回实例需要限定AbstractUtils，AbstractUtilsComponent恰好可以提供 // 根据1.3的最后部分我们知道这里的dependencies = AbstractUtilsComponent.class可以替换为AbstractUtilsModule， // 但是这样会失去依赖的层层分离的特点 @Component(modules = DataUtilsModule.class, dependencies = AbstractUtilsComponent.class) public interface DataUtilsComponent { DataUtils getDataUtils(); } 其次需要修改MainActivityComponent的参数，这里可以发现不再使用modules参数而是dependencies\n// dependencies = DataUtilsComponent.class表明可能需要DataUtilsComponent提供的实例， // 通过上面定义的getDataUtils方法得到 @Component(dependencies = DataUtilsComponent.class) public interface MainActivityComponent { void inject(MainActivity activity); } 最后需要修改MainActivity调用inject的流程，其他代码不变\npublic class MainActivity extends AppCompatActivity { private static final String TAG = MainActivity.class.getSimpleName(); @Inject DataUtils dataUtils; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); // 可以发现调用流程变复杂了，而且恰好在Component加入了dependencies的位置 // 需要调用dataUtilsComponent或者abstractUtilsComponent来进行初始化， // 有人会说了，这不是把流程变复杂了吗，之前都不需要额外的参数，现在需要将生成的Component带入 // 到初始化的过程，非也非也，此处可以使用DaggerDataUtilsComponent，那当然可以使用继承自DataUtilsComponent // 的其他Component，也就是说我们增加了注入的依赖范围，变为可以动态修改的了，注入过程更加灵活 DaggerMainActivityComponent .builder() .dataUtilsComponent(DaggerDataUtilsComponent .builder() .abstractUtilsComponent(DaggerAbstractUtilsComponent.create()) .build()) .build() .inject(this); // 很显然，这里引入的是ApiUtils对象 Log.i(TAG, dataUtils.show()); } } 下面展示一下为什么说注入的方式变得灵活了，产品经理突然告诉你需要新增一个Utils叫做ExtraUtils，在MainActivity中需要使用\npublic class ExtraUtils extends AbstractUtils { @Override public String showMessage() { return \u0026#34;This is ExtraUtils\u0026#34;; } } 在不修改上述的大部分代码的条件下，如何将ExtraUtils注入，首先新建一个ExtraDataUtilsModule用于提供通过ExtraUtils构造的DataUtils\n// 这里没有用带参的构造方法，也没有用抽象类，直接实例化，便于演示 @Module public class ExtraDataUtilsModule{ @Provides DataUtils provideDataUtils() { return new DataUtils(new ExtraUtils()); } } 然后新建一个ExtraDataUtilsComponent用于提供DataUtils实例，是不是和DataUtilsComponent功能很像，没错，这里可以用继承，并且由于MainActivityComponent的dependencies = DataUtilsComponent.class不变，我用继承来实现即可\n// 这里的modules = ExtraDataUtilsModule.class变成了我们自己新定义的Module，它是直接返回new DataUtils(new ExtraUtils())， // 所以实际上后面的dependencies = AbstractUtilsComponent.class不需要，但是这里保留是为了减少修改MainActivity的代码，当然也可以去掉 @Component(modules = ExtraDataUtilsModule.class, dependencies = AbstractUtilsComponent.class) public interface ExtraDataUtilsComponent extends DataUtilsComponent{ } 最后修改MainActivity中的inject流程\npublic class MainActivity extends AppCompatActivity { private static final String TAG = MainActivity.class.getSimpleName(); @Inject DataUtils dataUtils; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); // 注意这里是DaggerExtraDataUtilsComponent，即新创建的Component // 而且abstractUtilsComponent是可以去掉的，同理ExtraDataUtilsComponent的dependencies也需要去掉 DaggerMainActivityComponent .builder() .dataUtilsComponent(DaggerExtraDataUtilsComponent .builder() .abstractUtilsComponent(DaggerAbstractUtilsComponent.create()) .build()) .build() .inject(this); // 很显然，这里引入的是ExtraUtils对象 Log.i(TAG, dataUtils.show()); } } 通过这样的方式进行额外的依赖注入，就可以避免大部分代码的重构，而仅仅是增加代码，且注入的方式变得灵活\n从源码中也可以看到dependencies的作用，以MainActivityComponent为代表\npublic final class DaggerMainActivityComponent implements MainActivityComponent { private final DataUtilsComponent dataUtilsComponent; private DaggerMainActivityComponent(DataUtilsComponent dataUtilsComponentParam) { this.dataUtilsComponent = dataUtilsComponentParam; } public static Builder builder() { return new Builder(); } @Override public void inject(MainActivity activity) { injectMainActivity(activity); } // 我们可以调用DataUtilsComponent的getDataUtils()方法了 private MainActivity injectMainActivity(MainActivity instance) { MainActivity_MembersInjector.injectDataUtils( instance, Preconditions.checkNotNull( dataUtilsComponent.getDataUtils(), \u0026#34;Cannot return null from a non-@Nullable component method\u0026#34;)); return instance; } public static final class Builder { private DataUtilsComponent dataUtilsComponent; private Builder() {} // 此处为区别，初始化的过程中增加了dataUtilsComponent方法，用于引入DataUtilsComponent public Builder dataUtilsComponent(DataUtilsComponent dataUtilsComponent) { this.dataUtilsComponent = Preconditions.checkNotNull(dataUtilsComponent); return this; } public MainActivityComponent build() { Preconditions.checkBuilderRequirement(dataUtilsComponent, DataUtilsComponent.class); return new DaggerMainActivityComponent(dataUtilsComponent); } } } 以上就是@Component的部分使用，包括dependencies参数的意义，与之相似的有@Subcomponent注解，让我们回到加入ExtraUtils之前的场景，用@Subcomponent实现Componet的的层层依赖。\n首先修改AbstractUtilsComponent，增加它的上一级Component的plus方法，参数为上一级Component的Module\n@Component(modules = AbstractUtilsModule.class) public interface AbstractUtilsComponent { // @DBDataUtils // AbstractUtils getDBUtils(); // // @ApiDataUtils // AbstractUtils getApiUtils(); DataUtilsComponent plus(DataUtilsModule dataUtilsModule); } 然后修改DataUtilsComponent，同理，但是修改注解为@Subcomponent，且删除了dependencies参数\n@Subcomponent(modules = DataUtilsModule.class) public interface DataUtilsComponent { // DataUtils getDataUtils(); MainActivityComponent plus(); } 其次是MainActivityComponent，同理，修改注解为@Subcomponent，且删除了dependencies参数\n@Subcomponent public interface MainActivityComponent { void inject(MainActivity activity); } 最后修改MainActivity\npublic class MainActivity extends AppCompatActivity { private static final String TAG = MainActivity.class.getSimpleName(); @Inject DataUtils dataUtils; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); // 此处的注入调用的流程发生了很大的变化 // 之前是从MainActivityComponent -\u0026gt; DataUtilsComponent -\u0026gt; AbstractUtilsComponent // 现在是AbstractUtilsComponent -\u0026gt; DataUtilsComponent -\u0026gt; MainActivityComponent // 并且传入的参数变成了Module，这里也增加了注入的灵活性 DaggerAbstractUtilsComponent .create() .plus(new DataUtilsModule()) .plus() .inject(this); // 很显然，这里引入的是ApiUtils对象 Log.i(TAG, dataUtils.show()); } } 从生成的代码不难发现，这次只有一个Component生成文件DaggerAbstractUtilsComponent.java，我们看看为什么会这样\n// 还是按照执行顺序分析 public final class DaggerAbstractUtilsComponent implements AbstractUtilsComponent { private final AbstractUtilsModule abstractUtilsModule; // 3. 构造函数初始化完成 private DaggerAbstractUtilsComponent(AbstractUtilsModule abstractUtilsModuleParam) { this.abstractUtilsModule = abstractUtilsModuleParam; } public static Builder builder() { return new Builder(); } // 1. 返回Builder().build() public static AbstractUtilsComponent create() { return new Builder().build(); } // 4. 执行plus(new DataUtilsModule())方法，返回DataUtilsComponentImpl(dataUtilsModule) @Override public DataUtilsComponent plus(DataUtilsModule dataUtilsModule) { Preconditions.checkNotNull(dataUtilsModule); return new DataUtilsComponentImpl(dataUtilsModule); } public static final class Builder { private AbstractUtilsModule abstractUtilsModule; private Builder() {} public Builder abstractUtilsModule(AbstractUtilsModule abstractUtilsModule) { this.abstractUtilsModule = Preconditions.checkNotNull(abstractUtilsModule); return this; } // 2. 初始化了abstractUtilsModule为AbstractUtilsModule，这肯定是AbstractUtilsComponent指定了modules参数 // 导致，然后返回DaggerAbstractUtilsComponent的构造函数 public AbstractUtilsComponent build() { if (abstractUtilsModule == null) { this.abstractUtilsModule = new AbstractUtilsModule(); } return new DaggerAbstractUtilsComponent(abstractUtilsModule); } } private final class DataUtilsComponentImpl implements DataUtilsComponent { private final DataUtilsModule dataUtilsModule; // 5. 初始化DataUtilsComponentImpl private DataUtilsComponentImpl(DataUtilsModule dataUtilsModuleParam) { this.dataUtilsModule = dataUtilsModuleParam; } // 10. DataUtilsModule_ProvideDataUtilsFactory.provideDataUtils，接下来看DataUtilsModule_ProvideDataUtilsFactory // 和AbstractUtilsModule_ProvideApiUtilsFactory private DataUtils getDataUtils() { return DataUtilsModule_ProvideDataUtilsFactory.provideDataUtils( dataUtilsModule, AbstractUtilsModule_ProvideApiUtilsFactory.provideApiUtils( DaggerAbstractUtilsComponent.this.abstractUtilsModule)); } // 6. 调用plus()方法，返回的是MainActivityComponentImpl @Override public MainActivityComponent plus() { return new MainActivityComponentImpl(); } private final class MainActivityComponentImpl implements MainActivityComponent { // 7. MainActivityComponentImpl()构造 private MainActivityComponentImpl() {} // 8. 调用inject方法 @Override public void inject(MainActivity activity) { injectMainActivity(activity); } // 9. 最终调用的位置injectDataUtils，这个很熟悉了，instance.dataUtils = DataUtilsComponentImpl.this.getDataUtils() // getDataUtils返回值是什么呢，看10 private MainActivity injectMainActivity(MainActivity instance) { MainActivity_MembersInjector.injectDataUtils( instance, DataUtilsComponentImpl.this.getDataUtils()); return instance; } } } } public final class DataUtilsModule_ProvideDataUtilsFactory implements Factory\u0026lt;DataUtils\u0026gt; { private final DataUtilsModule module; private final Provider\u0026lt;AbstractUtils\u0026gt; abstractUtilsProvider; public DataUtilsModule_ProvideDataUtilsFactory( DataUtilsModule module, Provider\u0026lt;AbstractUtils\u0026gt; abstractUtilsProvider) { this.module = module; this.abstractUtilsProvider = abstractUtilsProvider; } @Override public DataUtils get() { return provideDataUtils(module, abstractUtilsProvider.get()); } public static DataUtilsModule_ProvideDataUtilsFactory create( DataUtilsModule module, Provider\u0026lt;AbstractUtils\u0026gt; abstractUtilsProvider) { return new DataUtilsModule_ProvideDataUtilsFactory(module, abstractUtilsProvider); } // 11-1. 接上文10，instance.provideDataUtils即我们定义的DataUtilsModule.provideDataUtils，返回DataUtils实例 public static DataUtils provideDataUtils(DataUtilsModule instance, AbstractUtils abstractUtils) { return Preconditions.checkNotNull( instance.provideDataUtils(abstractUtils), \u0026#34;Cannot return null from a non-@Nullable @Provides method\u0026#34;); } } public final class AbstractUtilsModule_ProvideApiUtilsFactory implements Factory\u0026lt;AbstractUtils\u0026gt; { private final AbstractUtilsModule module; public AbstractUtilsModule_ProvideApiUtilsFactory(AbstractUtilsModule module) { this.module = module; } @Override public AbstractUtils get() { return provideApiUtils(module); } public static AbstractUtilsModule_ProvideApiUtilsFactory create(AbstractUtilsModule module) { return new AbstractUtilsModule_ProvideApiUtilsFactory(module); } // 11-2. 接上文10，instance.provideApiUtils即我们定义的AbstractUtilsModule.provideApiUtils，返回ApiUtils实例 public static AbstractUtils provideApiUtils(AbstractUtilsModule instance) { return Preconditions.checkNotNull( instance.provideApiUtils(), \u0026#34;Cannot return null from a non-@Nullable @Provides method\u0026#34;); } } 分析两种调用方式的逻辑可以知道：\ndependencies方式从最上级的Component一级一级往下调用，获取需要的实例；Subcomponent方式最下级的Component通过一步一步构造出上级Component来调用，在每一步的plus方法中中加入Module提供需要的实例； dependencies方式适用于需要在某个类中注入非常多的其他实例，通过dependencies参数加深；Subcomponent方式适用于将某一个实例提供给其他实例注入，比如将Application context给其他例如ToastUtils、SharedpreferencesUtils使用，Application context作为Component，其他作为Subcomponent； Component dependencies 能单独使用，而Subcomponent必须由Component调用方法获取； Component dependencies 可以很清楚的得知他依赖哪个Component， 而Subcomponent不知道它自己的谁的孩子。 Component dependencies和Subcomponent使用上的总结\nComponent Dependencies：\n你想保留独立的想个组件（DataUtils可以单独使用注入，DBUtils也可以） 要明确的显示该组件所使用的其他依赖 Subcomponent：\n两个组件之间的关系紧密 你只关心Component，而Subcomponent只是作为Component的拓展，可以通过Component.xxx调用。 1.5 @Scope和@Singleton @Scope是用来管理依赖的生命周期的。它和@Qualifier一样是用来自定义注解的，而@Singleton则是@Scope的默认实现。\n在没有引入@Scope时，我们在MainActivity中初始化另一个DataUtils会是什么情况，这两个DataUtils会是相同的吗\npublic class MainActivity extends AppCompatActivity { private static final String TAG = MainActivity.class.getSimpleName(); // 这里直接inject第二个dataUtils2 @Inject DataUtils dataUtils; @Inject DataUtils dataUtils2; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); TextView textView = findViewById(R.id.text); DaggerMainActivityComponent .builder() .dataUtilsComponent(DaggerDataUtilsComponent .builder() .abstractUtilsComponent(DaggerAbstractUtilsComponent.create()) .build()) .build() .inject(this); // 然后在Log中打印这两个DataUtils对象，结果是这两个对象是不同的，相当于重新new一个 Log.i(TAG, dataUtils.toString() + dataUtils2.toString()); textView.setText(dataUtils.show()); } } 一般而言，我们希望这种工具类Utils是单例模式，比如读写数据库的时候，如果不是单例，那么可能存在“读后写”等问题导致数据不同步，那么单例模式，特别是全局单例就显得非常好用了。\n怎样在dagger框架中使用单例，很显然，必定是通过注解来实现@Singleton，在上面的代码中，我们需要的单例是DataUtils，那么从DataUtils的注入过程开始，首先是DataUtilsModule\n// 在provide方法上加上@Singleton @Module public class DataUtilsModule { @Provides @Singleton DataUtils provideDataUtils(@ApiDataUtils AbstractUtils abstractUtils) { return new DataUtils(abstractUtils); } } 以及需要使用此module的Component也需要加上\n@Singleton @Component(modules = DataUtilsModule.class, dependencies = AbstractUtilsComponent.class) public interface DataUtilsComponent { DataUtils getDataUtils(); } dagger2还有一项规定，如果一个Component被加上了@Scope注解，类似@Singleton，那么依赖这个Component的Component也需要加上@Scope注解，比如这里的MainActivityComponent，但是如果直接在MainActivityComponent上加上@Singleton会报错error: This @Singleton component cannot depend on scoped components: @Singleton com.example.daggerdemo.di.component.DataUtilsComponent，即单例不能依赖于单例，这是因为单例只能由自己产生，如果DataUtils在其他地方被注入了，那么MainActivityComponent将无法再进行注入，因为其依赖DataUtils是单例模式，显然这不是很符合面向对象的设计原则，因为我们可能并不知道MainActivityComponent会依赖哪些单例，所以MainActivityComponent的@Scope可以使用自定义的注解，自定义@Scope与@Singleton有说明区别呢，@Singleton相当于告诉系统，这个对象或者这个方法必定是全局单例，你看着办；而自定义@Scope相当于告诉系统在这个注解标注过的地方，我提供的对象是唯一的。\n因此代码如下，自定义ActivityScope表明我们需要在Activity生命周期内实现单例\n@Scope @Retention(RetentionPolicy.RUNTIME) public @interface ActivityScope {} MainActivityComponent注解加上@ActivityScope，其他地方的@Singleton不变\n@ActivityScope @Component(dependencies = DataUtilsComponent.class) public interface MainActivityComponent { void inject(MainActivity activity); } 最后运行代码可以发现MainActivity中的两个DataUtils对象是相同的，也就是在MainActivity中是单例的，但是它是不是全局单例呢，我们在创建一个SecondActivity，同样注入DataUtils\npublic class SecondActivity extends AppCompatActivity { private static final String TAG = MainActivity.class.getSimpleName(); @Inject DataUtils dataUtils3; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_second); TextView textView = findViewById(R.id.text); DaggerSecondActivityComponent .builder() .dataUtilsComponent(DaggerDataUtilsComponent .builder() .abstractUtilsComponent(DaggerAbstractUtilsComponent.create()) .build()) .build() .inject(this); // 此时dataUtils3与dataUtils并不相同，也就说dataUtils仅在MainActivity中是单例 Log.i(TAG, dataUtils3.toString()); textView.setText(dataUtils3.show()); } } // 同理需要一个SecondActivityComponent @ActivityScope @Component(dependencies = DataUtilsComponent.class) public interface SecondActivityComponent { void inject(SecondActivity activity); } @Scope是需要成对存在的，在Module的Provide方法中使用了@Scope，那么对应的Component中也必须使用@Scope注解，当两边的@Scope名字一样时（比如同为@Singleton）, 那么该Provide方法提供的依赖将会在Component中保持“局部单例”。 而在Component中标注@Scope，provide方法没有标注，那么这个@Scope就不会起作用，而Component上的@Scope的作用也只是为了能顺利通过编译，就像我刚刚定义的ActivityScope一样。\n@Singleton也是一个自定义@Scope，它的作用就像上面说的一样。但由于它是Dagger2中默认定义的，所以它比我们自定义Scope对了一个功能，就是编译检测，防止我们不规范的使用Scope注解，仅此而已。\n如何使用Dagger2实现单例呢：\n依赖在Component中是单例的（供该依赖的provide方法和对应的Component类使用同一个Scope注解。） 对应的Component在App中只初始化一次，每次注入依赖都使用这个Component对象。（在Application中创建该Component） 最直接的就是在自定义Application中将Component先初始化了，在通过这个Component去注入我们需要的对象，由于Component是单例的，因此通过它注入的对象也就是单例。\npublic class MyApp extends Application { // 注意我们之前定义的DataUtilsComponent有@Singleton注解，DataUtilsModule的provide方法有@Singleton注解 // 因此在Application中初始化的是DataUtilsComponent，这里简单使用DaggerDataUtilsComponent构造，当然也可以通过dagger注入 private DataUtilsComponent dataUtilsComponent; @Override public void onCreate() { super.onCreate(); dataUtilsComponent = DaggerDataUtilsComponent .builder() .abstractUtilsComponent(DaggerAbstractUtilsComponent.create()) .build(); } public DataUtilsComponent getDataUtilsComponent() { return dataUtilsComponent; } } 然后修改MainActivity和SecondActivity中inject的流程\n// MainActivity.java，dataUtilsComponent的参数是Application中初始化的 DaggerMainActivityComponent .builder() .dataUtilsComponent(((MyApp) getApplication()).getDataUtilsComponent()) .build() .inject(this); // SecondActivity.java DaggerSecondActivityComponent .builder() .dataUtilsComponent(((MyApp) getApplication()).getDataUtilsComponent()) .build() .inject(this); 然后我们看到在MainActivity和SecondActivity中的三个DataUtils都是相同的了。\n@Scope是用来给开发者管理依赖的生命周期的，它可以让某个依赖在Component中保持 “局部单例”（唯一），如果将Component保存在Application中复用，则可以让该依赖在app中保持单例。 我们可以通过自定义不同的Scope注解来标记这个依赖的生命周期，所以命名是需要慎重考虑的。\n@Singleton告诉我们这个依赖是单例的 @ActivityScope告诉我们这个依赖的生命周期和Activity相同 @FragmentScope告诉我们这个依赖的生命周期和Fragment相同 @xxxxScope …… 以上就是如何使用自定义@Scope实现单例的过程，那么如果在Application中使用注入会是什么情况呢，我们将DataUtilsComponent注入到MyApp中\n// 虽然这样的注入过程不是很合适，但是基本流程与在Activity中相同，首先是Module，提供对象实例 @Module public class DataUtilsComponentModule { @Provides DataUtilsComponent provideDataUtilsComponent(){ return DaggerDataUtilsComponent .builder() .abstractUtilsComponent(DaggerAbstractUtilsComponent.create()) .build(); } } // 然后是Component，提供注入的方法以及被注入的位置 @Component(modules = DataUtilsComponentModule.class) public interface ApplicationComponent { void inject(MyApp myApp); } public class MyApp extends Application { @Inject DataUtilsComponent dataUtilsComponent; // 最后是在Application的onCreate方法中注入 @Override public void onCreate() { super.onCreate(); DaggerApplicationComponent .create() .inject(this); } public DataUtilsComponent getDataUtilsComponent() { return dataUtilsComponent; } } 1.6 @MapKey和@Lazy @MapKey用于定义一些依赖集合（比如Map和Set），它的使用很简单，可以看代码注释\n首先需要定义key注解\n// UtilsMapKey作为后续使用的注解，String代表这个注解的接受的类型为String // unwrapValue如果为true，则此注解可接受的key类型有基本类型包装类、String、classes // unwrapValue如果为false，则此注解可接受的key类型为其本身，这个例子可以在源码注释中找到 @MapKey(unwrapValue = true) public @interface UtilsMapKey { String value(); } 然后是提供Map的value数据的module\n@Module public class UtilsMapModule { // 这里首先是Provides注解，然后是IntoMap注解，最后是前面定义的MapKey注解，同时传入了Map的key值为thisiskey @Provides @IntoMap @UtilsMapKey(\u0026#34;thisiskey\u0026#34;) Integer provideUtilsMapValue(){ // 返回值即为value，虽然返回值为value，但实际上注入时传入的是整个Map\u0026lt;String, Integer\u0026gt; return 11; } } 其次是MainActivityComponent加上我们定义的module\n@ActivityScope @Component(dependencies = DataUtilsComponent.class, modules = UtilsMapModule.class) public interface MainActivityComponent { void inject(MainActivity activity); } 最后直接在MainActivity中使用即可\npublic class MainActivity extends AppCompatActivity { private static final String TAG = MainActivity.class.getSimpleName(); @Inject DataUtils dataUtils; @Inject DataUtils dataUtils2; @Inject Map\u0026lt;String, Integer\u0026gt; map; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); TextView textView = findViewById(R.id.text); DaggerMainActivityComponent .builder() .dataUtilsComponent(((MyApp) getApplication()).getDataUtilsComponent()) .build() .inject(this); // 很显然，这里引入的是ApiUtils对象 Log.i(TAG, dataUtils.toString() + dataUtils2.toString()); Log.i(TAG, String.valueOf(dataUtils.equals(dataUtils2))); // 这里TextView中显示的就是 {thisiskey=11} textView.setText(map.toString()); textView.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { startActivity(new Intent(MainActivity.this, SecondActivity.class)); } }); } } @Lazy，这个并不是作为注解使用的，而是作为wrapper类型使用，比如下面这样\n@Inject Lazy\u0026lt;DataUtils\u0026gt; dataUtils; 使用Lazy修饰的类型不会在注入的时候初始化，只能通过get方法获取实例，下面的Log日志显示了未初始化的dataUtils是什么类型\npublic class MainActivity extends AppCompatActivity { private static final String TAG = MainActivity.class.getSimpleName(); @Inject Lazy\u0026lt;DataUtils\u0026gt; dataUtils; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); DaggerMainActivityComponent .builder() .dataUtilsComponent(((MyApp) getApplication()).getDataUtilsComponent()) .build() .inject(this); // dataUtils是dagger.internal.DoubleCheck@3050053 Log.i(TAG, dataUtils.toString()); DataUtils utils = dataUtils.get(); // utils是com.example.daggerdemo.di.model.DataUtils@26c9d90 Log.i(TAG, utils.toString()); } } 1.7 @Binds和@Multibinds @Binds注解与@Provides有异曲同工之妙，其修饰的方法都是为了提供实例，但是具体使用起来又有区别，@Binds只能在抽象类Module中使用，并且修饰抽象方法，为了使用@Binds注解，我们首先构造一个抽象类DBUtilsModule用于提供DBUtils，LocalDBUtils继承自DBUtils，我们希望不直接用到LocalDBUtils的构造方法而去生成它。\n// 首先这是一个Module，而且是抽象的，其次provideLocalDBUtils方法也是抽象的，用@Binds修饰，方法的参数即返回的实例 // 为了对比，加上了一个普通的Provides修饰的方法 @Module public abstract class DBUtilsModule { // provideLocalDBUtils看似返回的是DBUtils，但实际返回的是LocalDBUtils的实例 @Binds @LocalDBDataUtils abstract DBUtils provideLocalDBUtils(LocalDBUtils localDBUtils); @Provides static DBUtils provideDBUtils() { return new DBUtils(); } } // 因为使用provideLocalDBUtils方法，所以需要通过inject的方法提供LocalDBUtils实例，这里使用最简单的构造函数注入， // 当然也可以使用Module提供LocalDBUtils实例，这里仅作演示 public class LocalDBUtils extends DBUtils { @Inject public LocalDBUtils() { } @Override public String showMessage() { return \u0026#34;This is LocalDBDataUtils\u0026#34;; } } // 增加一个限定符注解，为了区分provideDBUtils和provideLocalDBUtils @Qualifier @Retention(RetentionPolicy.RUNTIME) public @interface LocalDBDataUtils { } // 同理需要定义一个Component来提供实例方法，也可以不用这个Component，具体区别稍后再点明 @Component(modules = DBUtilsModule.class) public interface DBUtilsComponent { @LocalDBDataUtils DBUtils getLocalDBUtils(); DBUtils getDBUtils(); } // 如果加了上面的DBUtilsComponent，则ActivityComponent需要用dependencies @Component(dependencies = DBUtilsComponent.class) public interface SecondActivityComponent { void inject(SecondActivity secondActivity); } // 如果不加上面的DBUtilsComponent，则ActivityComponent需要用modules @Component(modules = DBUtilsModule.class) public interface SecondActivityComponent { void inject(SecondActivity secondActivity); } 最后再SecondActivity中使用\npublic class SecondActivity extends AppCompatActivity { // 获取实例可以通过限定符注解的方法获取指定的实例 // 比如这里@LocalDBDataUtils表明需要provideLocalDBUtils方法返回的实例 // 如果这里不加@LocalDBDataUtils，则代表provideDBUtils返回的实例 @LocalDBDataUtils @Inject DBUtils dbUtils; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_second); // 如果加了上面的DBUtilsComponent DaggerSecondActivityComponent .builder() .dBUtilsComponent(DaggerDBUtilsComponent.create()) .build() .inject(this); // 如果不加上面的DBUtilsComponent DaggerSecondActivityComponent .create() .inject(this); Log.i(\u0026#34;MainActivity2\u0026#34;, dbUtils.showMessage()); } } 通过@Binds修饰抽象方法会有什么区别呢，我们在加了上面的DBUtilsComponent的情况下看一下源码DaggerDBUtilsComponent\npublic final class DaggerDBUtilsComponent implements DBUtilsComponent { private DaggerDBUtilsComponent() {} public static Builder builder() { return new Builder(); } public static DBUtilsComponent create() { return new Builder().build(); } // Binds修饰抽象方法会导致实例在DaggerDBUtilsComponent直接构造生成 @Override public DBUtils getLocalDBUtils() { return new LocalDBUtils(); } // 普通的Provides修饰是通过DBUtilsModule_ProvideDBUtilsFactory工厂类生成 @Override public DBUtils getDBUtils() { return DBUtilsModule_ProvideDBUtilsFactory.provideDBUtils(); } public static final class Builder { private Builder() {} public DBUtilsComponent build() { return new DaggerDBUtilsComponent(); } } } 简而言之，@Binds注解的作用还是修饰提供实例的方法，但是其修饰的方法的参数即返回的实例，我们不需要显示地调用需要地实例地构造函数，因为在生成地代码中为我们完成了这些工作，与此同时，它地效率可能会高一些，因为是直接在Component中生成的。\n@BindsInstance比较适合与@Component.Builder方法一起说明，直接看代码，我们这里需要注入Application的Context，虽然显得很奇怪\n首先是AppComponent，最后需要用这个调用inject方法注入到Application中\n// 单例模式，以及modules参数不解释 @Singleton @Component(modules = AppModule.class) public interface AppComponent { // 这里出现了@Component.Builder注解，它的作用是提供自定义的方式构造此Component，根据注释要求 // 1. 必须有一个返回此Component的build方法 AppComponent build(); // 2. 可以有抽象方法作为setter方法 // 3. setter方法必须有一个参数，并且返回void、builder、builder的父类 // 4. 必须有一个setter方法用于设置dependencies（如果有的话） // 5. 必须有setter方法用于设置modules里面有非抽象方法的非抽象module // 6. 可以有setter方法初始化modules // 7. 可以有@BindsInstance修饰的方法将绑定的实例传递给此Component // 8. 可以有非抽象方法，但是如果与builder生成相关则会被忽略 // 注释说的并不是很清楚，需要自行测试其功能，此处仅演示 @Component.Builder interface Builder { // 这里两个方法setApplication和setDBName暴露出去，在调用inject方法时初始化 // 且这两个方法的参数application和name会被传入到AppModule的provide方法的参数中 // 即我们实现了在外部对Component进行初始化参数设置的功能 @BindsInstance Builder setApplication(Application application); @BindsInstance Builder setDBName(String name); AppComponent build(); } void inject(MyApp app); } 接下来是AppModule，提供两个方法用于提供实例，注入的对象分别是Context和Integer（Context是上下文，后续会介绍；Integer是演示，没有意义）\n@Module public class AppModule { // 这里传入的两个参数application和name来自于AppComponent的Builder方法中的setApplication和setDBName @Provides @Singleton Context provideContext(Application application) { return application; } @Provides @Singleton Integer provideDBName(String name) { return name.hashCode(); } } 最后在自定义的Application中注入\npublic class MyApp extends Application { @Inject Context context; @Inject Integer dbName; @Override public void onCreate() { super.onCreate(); // 传入的参数包括this和hello.db // 这样就把传入的参数通过Component转换并注入到MyApp中了 // 虽然这种方式没有意义，但是后续有用，这里仅演示BindsInstance的功能 DaggerAppComponent .builder() .setApplication(this) .setDBName(\u0026#34;hello.db\u0026#34;) .build() .inject(this); Log.i(\u0026#34;MyApp\u0026#34;, context.toString()); Log.i(\u0026#34;MyApp\u0026#34;, dbName.toString()); } } @MultiBinds顾名思义，肯定与注入多个对象相关，假如我们需要在Module里提供了很多相同类型的 对象，如果我们不使用@Qualifer，就会导致同一类型重复绑定的错误。但是如果我们确实需要在一个Module里包含这些对象的创建，又不想创建N多的@Qualifer，我们就可以使用@MultiBind机制来达到我们的目的。\nMultiBind机制允许我们为这些对象创建一个集合，这个集合必须是Set或者Map，这样在Component中，我们就可以暴露这个集合，通过集合来获取不同的对象。这个集合的创建有三种方法\n1.使用@IntoSet或者@IntoMap\n// 还记得上面提到的@MapKey注解吗 @Module public class UtilsMapModule { // 这里首先是Provides注解，然后是IntoMap注解，最后是前面定义的MapKey注解，同时传入了Map的key值为thisiskey @Provides @IntoMap @UtilsMapKey(\u0026#34;thisiskey1\u0026#34;) Integer provideUtilsMapValue1(){ // 返回值即为value，虽然返回值为value，但实际上注入时传入的是整个Map return 11; } // 下面加的代码没有测试过，仅演示 @Provides @IntoMap @UtilsMapKey(\u0026#34;thisiskey2\u0026#34;) Integer provideUtilsMapValue2(){ return 12; } @Provides @IntoSet Integer provideUtilsSetValue1(){ return 111; } @Provides @IntoSet Integer provideUtilsSetValue2(){ return 222; } } 2.直接提供Set或者Map类型\n@Module public class UtilsMapModule { @Provides Set\u0026lt;String\u0026gt; provideUtilsSet(){ Set\u0026lt;String\u0026gt; utils = new HashSet\u0026lt;\u0026gt;(); utils.add(\u0026#34;utils1\u0026#34;); utils.add(\u0026#34;utils2\u0026#34;); return utils; } @Provides Map\u0026lt;String, Integer\u0026gt; provideUtilsMap(){ Map\u0026lt;String, Integer\u0026gt; utils = new HashMap\u0026lt;\u0026gt;(); utils.put(\u0026#34;utils-key1\u0026#34;, 111); utils.put(\u0026#34;utils-key2\u0026#34;, 222); return utils; } } 3.使用@MultiBinds注解\n@Module public abstract class UtilsBindModule { @Multibinds abstract Set\u0026lt;String\u0026gt; utilsSet(); @Multibinds abstract Map\u0026lt;String, Integer\u0026gt; utilsMap(); } MultiBinds只能用于标注抽象方法，它仅仅是告诉Component我有这么一种提供类型，让我们Component可以在Component中暴露Set或者Map类型的接口，但是不能包含具体的元素。Multibinds注解是可以和第一种集合定义混用的。\n如果将UtilsBindModule单独加在某个Component的modules参数时，它并不能提供实例，而是提供一个空的实例，如果将它和另一个可以提供具体实例的Module一起加在某个Component的modules参数时，会自动获取非空实例，此时UtilsBindModule没有作用。\n2. dagger.android进阶 dagger框架可以用于Java Web项目同时也可以用于Android项目，但是在Android项目中，最重要最常用的几个组件比如Activity，如果需要进行依赖注入，那会是一个什么样的情形呢。\npublic class XXXActivity extends AppCompatActivity { @Inject XXXEntity entity; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); DaggerXXXActivityComponent.create().inject(this); } } @Component(module = XXXEntityModule.class) public interface XXXActivityComponent { void inject(XXXActivity activity); } @Module public class XXXEntityModule { @Provides XXXEntity provideXXXEntity() { return new XXXEntity(); } } 以最简单的单个对象XXXEntity注入，我们需要在每一个Activity中加上DaggerXXXActivityComponent.create().inject(this);，每一个XXXActivityComponent又需要指定其module，这样就会产生很多重复的代码，且会引起结构混乱；\n有人可能会说，那直接用一个ActivityComponent不行吗，把所有的Activity需要的XXXEntity的module都加进去，那就会产生一个module参数非常长的ActivityComponent，显然这也是不合理的；\n还有人说，将那些需要相同XXXEntity的Activity使用相同的XXXActivityComponent，不就可以减少很多代码了，显然，项目的复杂度决定了这样的操作依然会产生很多重复代码。\n所以我们的目的是在Activity中使用inject方法时不需要知道是哪个XXXActivityComponent，也就是说用一个通用方法AndroidInjection.inject(this)替换DaggerXXXActivityComponent.create().inject(this)，这样就可以在BaseActivity中加入这个方法，那么继承自BaseActivity的Activity就不需要再重复写了。\n与此同时，如果XXXActivityComponent也能简化或者集成，那就非常完美了，最终我们需要的是自定义XXXEntityModule，用于提供不同Activity需要的注入对象。\n那么首先需要回顾一下DaggerXXXActivityComponent.create().inject(this)，详情请往上翻，本质上相当于调用this.XXXEntity = new XXXEntity()，但是初始化过程Avtivity并不需要知道，都是通过dagger生成的代码执行的结果。\n2.1 Injecting Activity objects 官网给出了在Activity中进行依赖注入的步骤，首先过一遍流程，然后再根据代码分析原理：\n1.实现一个Component在自定义Application中注入\n// AppComponent.java // 这里的module参数必须添加AndroidInjectionModule.class，后面的MainActivityModule.class和AppModule.class有其他作用 @Singleton @Component(modules = {AndroidInjectionModule.class, MainActivityModule.class, AppModule.class}) public interface AppComponent { // 这里inject的参数是自定义MyApplication，也说明了这个需要在MyApplication中调用 void inject(MyApplication application); } 2.实现一个Subcomponent与需要注入的Activity关联\n// MainActivitySubComponent.java // 这里接口继承自AndroidInjector\u0026lt;YourActivity\u0026gt;， // 同时需要一个Subcomponent.Factory工厂类继承自AndroidInjector.Factory\u0026lt;YourActivity\u0026gt; // 现在你可能一脸懵逼，这是啥，为什么要这么写，但是没关系，后面肯定会用到 @Subcomponent public interface MainActivitySubComponent extends AndroidInjector\u0026lt;MainActivity\u0026gt; { @Subcomponent.Factory public interface Factory extends AndroidInjector.Factory\u0026lt;MainActivity\u0026gt; {} } 3.实现module为你的XXXActivity提供其需要的对象，这一步还有优化的可能，后面介绍\n// MainActivityModule.java // 这里的subcomponents需要上一步定义的MainActivitySubComponent.class，而且这是一个抽象类 @Module(subcomponents = MainActivitySubComponent.class) public abstract class MainActivityModule { // 还记得上面提到的@Binds注解吗，这里表示MainActivityModule可以提供MainActivitySubComponent.Factory对象 // 前提是key为MainActivity.class @Binds @IntoMap @ClassKey(MainActivity.class) abstract AndroidInjector.Factory\u0026lt;?\u0026gt; bindMainActivityAndroidInjectorFactory(MainActivitySubComponent.Factory factory); // 然后需要一个提供对象的provide方法，这个Entity也就是最终我们需要在MainActivity中用到的对象 // Singleton注解会导致局部单例而不是全局单例，因为只能在MainActivity中使用 @Provides @Singleton static Entity provideEntity() { return new Entity(); } } 4.自定义Application实现HasAndroidInjector接口，并且进行注入\n// MyApplication.java // extends Application implements HasActivityInjector public class MyApplication extends Application implements HasActivityInjector { // 需要DispatchingAndroidInjector对象，并且在activityInjector()方法中返回 @Inject DispatchingAndroidInjector\u0026lt;Activity\u0026gt; dispatchingActivityInjector; @Override public void onCreate() { super.onCreate(); // 使用第一步定义的Component进行注入 DaggerAppComponent.create() .inject(this); } @Override public AndroidInjector\u0026lt;Activity\u0026gt; activityInjector() { return dispatchingActivityInjector; } } 5.最终在Activity中的onCreate方法中调用AndroidInjection.inject(this)，在super.onCreate()之前\n// MainActivity.java public class MainActivity extends AppCompatActivity { // 首先是Entity对象，它是在MainActivityModule中引入的 @Inject Entity entity; // 其次是String对象，它是在AppModule中引入的 @Inject String info; @Override protected void onCreate(Bundle savedInstanceState) { AndroidInjection.inject(this); super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); TextView textView = findViewById(R.id.text); // 这里就可以直接使用entity的方法showMessage()，以及info对象的值 String text = entity.showMessage() + \u0026#34; - \u0026#34; + info; textView.setText(text); } } // Entity.java // MainActivity中需要的对象，仅作演示 public class Entity { private String msg = \u0026#34;Dagger inject\u0026#34;; public Entity() { } public String showMessage() { return msg; } } // AppModule.java // AppModule用于提供全局需要的对象，比如Context，或者一些全局设置比如SharedPreferences、数据库名称等等 @Module public class AppModule { // 这里增加了一个String字符，仅作演示 @Provides @Singleton String provideGlobalInfo(){ return \u0026#34;This is global info\u0026#34;; } } 2.2 Injecting Activity objects源码分析 需要分析源码才能知道问什么上面我们需要定义各种Factory接口以及为什么要在Application中进行注入\n那么首先从Activity中开始，这是使用dagger依赖注入的终点，MainActivity中仅有一处与dagger相关AndroidInjection.inject(this);\n// AndroidInjection.java /** * Injects {@code activity} if an associated {@link AndroidInjector} implementation can be found, * otherwise throws an {@link IllegalArgumentException}. * * @throws RuntimeException if the {@link Application} doesn\u0026#39;t implement {@link * HasActivityInjector}. */ public static void inject(Activity activity) { checkNotNull(activity, \u0026#34;activity\u0026#34;); Application application = activity.getApplication(); // 这里对application进行了判断，如果没有实现HasActivityInjector，那么会报错 // 这也是为什么我们自定义的Application需要实现HasActivityInjector接口 if (!(application instanceof HasActivityInjector)) { throw new RuntimeException( String.format( \u0026#34;%s does not implement %s\u0026#34;, application.getClass().getCanonicalName(), HasActivityInjector.class.getCanonicalName())); } // 这里调用了application的activityInjector()方法，得到了一个AndroidInjector\u0026lt;Activity\u0026gt;对象 AndroidInjector\u0026lt;Activity\u0026gt; activityInjector = ((HasActivityInjector) application).activityInjector(); checkNotNull(activityInjector, \u0026#34;%s.activityInjector() returned null\u0026#34;, application.getClass()); // 然后通过AndroidInjector\u0026lt;Activity\u0026gt;对象，调用其inject方法对当前的activity进行注入 activityInjector.inject(activity); } 与MainActivity中的AndroidInjection.inject(this);相关联的是自定义的MyApplication，且调用了它的activityInjector()方法，这也是为什么我们需要在自定义Application中实现activityInjector()方法，且返回了一个DispatchingAndroidInjector对象\n// MyApplication.java public class MyApplication extends Application implements HasActivityInjector { // 根据上文的分析，我们知道了在MainActivity中调用的inject方法其实是调用了dispatchingActivityInjector的inject方法 // 而这个DispatchingAndroidInjector\u0026lt;Activity\u0026gt;对象竟然也是通过注入的方式获取的，它的来源DaggerAppComponent.create().inject(this); // 因此我们需要到AppComponent中找到DispatchingAndroidInjector\u0026lt;Activity\u0026gt;是怎么来的 @Inject DispatchingAndroidInjector\u0026lt;Activity\u0026gt; dispatchingActivityInjector; @Override public void onCreate() { super.onCreate(); DaggerAppComponent.create().inject(this); } @Override public AndroidInjector\u0026lt;Activity\u0026gt; activityInjector() { return dispatchingActivityInjector; } } 在分析AppComponent先看看DaggerAppComponent.create().inject(this);做了些什么工作，这里代码都比较多，关联了很多其他类， 这里可以按照记号按顺序分析DaggerAppComponent.create().inject(this)的调用过程，显然这里有建造者模式\npublic final class DaggerAppComponent implements AppComponent { private Provider\u0026lt;MainActivitySubComponent.Factory\u0026gt; mainActivitySubComponentFactoryProvider; private Provider\u0026lt;Entity\u0026gt; provideEntityProvider; private Provider\u0026lt;String\u0026gt; provideGlobalInfoProvider; // 3. Builder().build()返回了DaggerAppComponent对象 private DaggerAppComponent(AppModule appModuleParam) { initialize(appModuleParam); } public static Builder builder() { return new Builder(); } // 1. 调用静态方法create，返回了Builder().build() public static AppComponent create() { return new Builder().build(); } // 11. getMapOfClassOfAndProviderOfAndroidInjectorFactoryOf方法返回的是SingletonMap，key是MainActivity.class // value是mainActivitySubComponentFactoryProvider，简而言之还是一个map，然后需要看10中DispatchingAndroidInjector_Factory // 的实例是如何构造的 private Map\u0026lt;Class\u0026lt;?\u0026gt;, Provider\u0026lt;AndroidInjector.Factory\u0026lt;?\u0026gt;\u0026gt;\u0026gt; getMapOfClassOfAndProviderOfAndroidInjectorFactoryOf() { return Collections.\u0026lt;Class\u0026lt;?\u0026gt;, Provider\u0026lt;AndroidInjector.Factory\u0026lt;?\u0026gt;\u0026gt;\u0026gt;singletonMap( MainActivity.class, (Provider) mainActivitySubComponentFactoryProvider); } // 10. getDispatchingAndroidInjectorOfActivity返回的是DispatchingAndroidInjector_Factory的实例 // 带入了参数getMapOfClassOfAndProviderOfAndroidInjectorFactoryOf()以及一个emptyMap，对的就是空map，仅包含了key和value的类型 private DispatchingAndroidInjector\u0026lt;Activity\u0026gt; getDispatchingAndroidInjectorOfActivity() { return DispatchingAndroidInjector_Factory.newInstance( getMapOfClassOfAndProviderOfAndroidInjectorFactoryOf(), Collections.\u0026lt;String, Provider\u0026lt;AndroidInjector.Factory\u0026lt;?\u0026gt;\u0026gt;\u0026gt;emptyMap()); } // 4. DaggerAppComponent构造方法里执行了initialize方法，这个initialize对DaggerAppComponent类里面的私有变量进行了初始化 @SuppressWarnings(\u0026#34;unchecked\u0026#34;) private void initialize(final AppModule appModuleParam) { // 4.1 首先是mainActivitySubComponentFactoryProvider，返回了一个Provider对象， // 根据注释可以知道Provider用于提供一个已经构造好的用于注入的对象实例，如果调用这个Provider的get方法， // 我们就可以得到MainActivitySubComponentFactory对象 this.mainActivitySubComponentFactoryProvider = new Provider\u0026lt;MainActivitySubComponent.Factory\u0026gt;() { @Override public MainActivitySubComponent.Factory get() { return new MainActivitySubComponentFactory(); } }; // 4.2 provideEntityProvider被赋值为MainActivityModule_ProvideEntityFactory.create() // 使用DoubleCheck是因为Entity在provide方法中标注了Singleton， // MainActivityModule_ProvideEntityFactory的作用将在下面继续介绍 this.provideEntityProvider = DoubleCheck.provider(MainActivityModule_ProvideEntityFactory.create()); // 4.3 provideGlobalInfoProvider同理，但是AppModule_ProvideGlobalInfoFactory.create(appModuleParam) // 多了一个参数，AppModule_ProvideGlobalInfoFactory的作用将在下面继续介绍 this.provideGlobalInfoProvider = DoubleCheck.provider(AppModule_ProvideGlobalInfoFactory.create(appModuleParam)); } // 8. DaggerAppComponent.create().inject(this)的最后一步，实际调用injectMyApplication @Override public void inject(MyApplication application) { injectMyApplication(application); } // 9. 两个关键，MyApplication_MembersInjector类以及本地的getDispatchingAndroidInjectorOfActivity()方法 // MyApplication_MembersInjector类后续再介绍，但是本质上injectDispatchingActivityInjector方法等价于 // instance.DispatchingActivityInjector = getDispatchingAndroidInjectorOfActivity() // 先看getDispatchingAndroidInjectorOfActivity()方法 private MyApplication injectMyApplication(MyApplication instance) { MyApplication_MembersInjector.injectDispatchingActivityInjector( instance, getDispatchingAndroidInjectorOfActivity()); return instance; } public static final class Builder { private AppModule appModule; private Builder() {} public Builder appModule(AppModule appModule) { this.appModule = Preconditions.checkNotNull(appModule); return this; } // 2. Builder().build() new了一个AppModule对象，然后返回了DaggerAppComponent(appModule)的对象， // 还记得AppModule类的功能吗，提供全局对象，其中有一个String provideGlobalInfo()方法 public AppComponent build() { if (appModule == null) { this.appModule = new AppModule(); } return new DaggerAppComponent(appModule); } } // 5. MainActivitySubComponentFactory类实现了MainActivitySubComponent.Factory接口的create方法， // 最终还是返回了MainActivitySubComponentImpl对象 private final class MainActivitySubComponentFactory implements MainActivitySubComponent.Factory { @Override public MainActivitySubComponent create(MainActivity arg0) { Preconditions.checkNotNull(arg0); return new MainActivitySubComponentImpl(arg0); } } // 6. MainActivitySubComponentImpl对象实现了MainActivitySubComponent接口的inject方法， // 这是由于MainActivitySubComponent继承自AndroidInjector\u0026lt;MainActivity\u0026gt; private final class MainActivitySubComponentImpl implements MainActivitySubComponent { private MainActivitySubComponentImpl(MainActivity arg0) {} @Override public void inject(MainActivity arg0) { injectMainActivity(arg0); } // 7. 最终调用inject方法时，我们看到了inject(MainActivity arg0)参数为MainActivity， // 想必此时你应该猜到了在MainActivity中的一句话AndroidInjection.inject(this)竟然能在异国他乡被实现 private MainActivity injectMainActivity(MainActivity instance) { // 这里的两个方法injectEntity和injectInfo分别对应了我们在MainActivity中注入的两个对象，instance是MainActivity， // provideEntityProvider.get()和provideGlobalInfoProvider.get()方法对应上面initialize方法初始化的私有变量， // 看这个方法的样子就知道这是对MainActivity进行注入的实际方法，MainActivity_MembersInjector的作用将在下面继续介绍 MainActivity_MembersInjector.injectEntity( instance, DaggerAppComponent.this.provideEntityProvider.get()); MainActivity_MembersInjector.injectInfo( instance, DaggerAppComponent.this.provideGlobalInfoProvider.get()); return instance; } } } // MainActivityModule_ProvideEntityFactory.java // 接上文4.2 // Factory\u0026lt;Entity\u0026gt;继承自Provider，Provider之前提到过用于提供构造好的实例，通过get方法返回 public final class MainActivityModule_ProvideEntityFactory implements Factory\u0026lt;Entity\u0026gt; { private static final MainActivityModule_ProvideEntityFactory INSTANCE = new MainActivityModule_ProvideEntityFactory(); @Override public Entity get() { return provideEntity(); } // 4.2-1 首先是create方法返回实例，这是饿汉式单例模式，在类初始化时，已经自行实例化 public static MainActivityModule_ProvideEntityFactory create() { return INSTANCE; } // 接上文7-1，provideEntity方法返回的是MainActivityModule.provideEntity()，而MainActivityModule // 是我们定义的，MainActivityModule.provideEntity()返回new Entity()，所以我们最终得到了new出来的对象 public static Entity provideEntity() { return Preconditions.checkNotNull( MainActivityModule.provideEntity(), \u0026#34;Cannot return null from a non-@Nullable @Provides method\u0026#34;); } } // AppModule_ProvideGlobalInfoFactory.java // 接上文4.3 public final class AppModule_ProvideGlobalInfoFactory implements Factory\u0026lt;String\u0026gt; { private final AppModule module; public AppModule_ProvideGlobalInfoFactory(AppModule module) { this.module = module; } @Override public String get() { return provideGlobalInfo(module); } // 4.3-1 首先也是create方法，观察一下与MainActivityModule_ProvideEntityFactory的create方法的不同之处 // 这里通过构造方法返回了实例，而不是单例模式，要知道AppModule和MainActivityModule中都是加入了Singleton注解 // todo 这可能是因为需要传入参数create(AppModule module)的原因，而且AppModule是一个类而MainActivityModule // 是一个抽象类 public static AppModule_ProvideGlobalInfoFactory create(AppModule module) { return new AppModule_ProvideGlobalInfoFactory(module); } // 接上文7-1，provideGlobalInfo返回的就是我们在AppModule定义的String \u0026#34;This is global info\u0026#34; public static String provideGlobalInfo(AppModule instance) { return Preconditions.checkNotNull( instance.provideGlobalInfo(), \u0026#34;Cannot return null from a non-@Nullable @Provides method\u0026#34;); } } // DispatchingAndroidInjector_Factory.java // 接上文10，我们传入的参数是两个map，一个为空，另一个与MainActivity相关 public final class DispatchingAndroidInjector_Factory\u0026lt;T\u0026gt; implements Factory\u0026lt;DispatchingAndroidInjector\u0026lt;T\u0026gt;\u0026gt; { private final Provider\u0026lt;Map\u0026lt;Class\u0026lt;?\u0026gt;, Provider\u0026lt;AndroidInjector.Factory\u0026lt;?\u0026gt;\u0026gt;\u0026gt;\u0026gt; injectorFactoriesWithClassKeysProvider; private final Provider\u0026lt;Map\u0026lt;String, Provider\u0026lt;AndroidInjector.Factory\u0026lt;?\u0026gt;\u0026gt;\u0026gt;\u0026gt; injectorFactoriesWithStringKeysProvider; public DispatchingAndroidInjector_Factory( Provider\u0026lt;Map\u0026lt;Class\u0026lt;?\u0026gt;, Provider\u0026lt;AndroidInjector.Factory\u0026lt;?\u0026gt;\u0026gt;\u0026gt;\u0026gt; injectorFactoriesWithClassKeysProvider, Provider\u0026lt;Map\u0026lt;String, Provider\u0026lt;AndroidInjector.Factory\u0026lt;?\u0026gt;\u0026gt;\u0026gt;\u0026gt; injectorFactoriesWithStringKeysProvider) { this.injectorFactoriesWithClassKeysProvider = injectorFactoriesWithClassKeysProvider; this.injectorFactoriesWithStringKeysProvider = injectorFactoriesWithStringKeysProvider; } @Override public DispatchingAndroidInjector\u0026lt;T\u0026gt; get() { return new DispatchingAndroidInjector\u0026lt;T\u0026gt;( injectorFactoriesWithClassKeysProvider.get(), injectorFactoriesWithStringKeysProvider.get()); } public static \u0026lt;T\u0026gt; DispatchingAndroidInjector_Factory\u0026lt;T\u0026gt; create( Provider\u0026lt;Map\u0026lt;Class\u0026lt;?\u0026gt;, Provider\u0026lt;AndroidInjector.Factory\u0026lt;?\u0026gt;\u0026gt;\u0026gt;\u0026gt; injectorFactoriesWithClassKeysProvider, Provider\u0026lt;Map\u0026lt;String, Provider\u0026lt;AndroidInjector.Factory\u0026lt;?\u0026gt;\u0026gt;\u0026gt;\u0026gt; injectorFactoriesWithStringKeysProvider) { return new DispatchingAndroidInjector_Factory\u0026lt;T\u0026gt;( injectorFactoriesWithClassKeysProvider, injectorFactoriesWithStringKeysProvider); } // 10-1 newInstance返回的是DispatchingAndroidInjector，先简单说明一下这个类的作用 // DispatchingAndroidInjector类是一个完成对Activity或Fragment进行依赖注入的类，因为传入的参数包括 // injectorFactoriesWithClassKeys，这个Map根据前面的分析可知它的key就是Activity.class或者Fragment.class // 即依赖注入的位置，它的value是一个Provider，这个Provider提供inject方法，专门用于将依赖实例注入到 // key对应的Activity或Fragment中 public static \u0026lt;T\u0026gt; DispatchingAndroidInjector\u0026lt;T\u0026gt; newInstance( Map\u0026lt;Class\u0026lt;?\u0026gt;, Provider\u0026lt;AndroidInjector.Factory\u0026lt;?\u0026gt;\u0026gt;\u0026gt; injectorFactoriesWithClassKeys, Map\u0026lt;String, Provider\u0026lt;AndroidInjector.Factory\u0026lt;?\u0026gt;\u0026gt;\u0026gt; injectorFactoriesWithStringKeys) { return new DispatchingAndroidInjector\u0026lt;T\u0026gt;( injectorFactoriesWithClassKeys, injectorFactoriesWithStringKeys); } } 详细分析DispatchingAndroidInjector类的功能\n// 注释已经说的很清楚了，DispatchingAndroidInjector类是一个完成对Activity或Fragment进行依赖注入的类 /** * Performs members-injection on instances of core Android types (e.g. {@link Activity}, {@link * Fragment}) that are constructed by the Android framework and not by Dagger. This class relies on * an injected mapping from each concrete class to an {@link AndroidInjector.Factory} for an {@link * AndroidInjector} of that class. Each concrete class must have its own entry in the map, even if * it extends another class which is already present in the map. Calls {@link Object#getClass()} on * the instance in order to find the appropriate {@link AndroidInjector.Factory}. * * @param \u0026lt;T\u0026gt; the core Android type to be injected */ @Beta public final class DispatchingAndroidInjector\u0026lt;T\u0026gt; implements AndroidInjector\u0026lt;T\u0026gt; { private static final String NO_SUPERTYPES_BOUND_FORMAT = \u0026#34;No injector factory bound for Class\u0026lt;%s\u0026gt;\u0026#34;; private static final String SUPERTYPES_BOUND_FORMAT = \u0026#34;No injector factory bound for Class\u0026lt;%1$s\u0026gt;. Injector factories were bound for supertypes \u0026#34; + \u0026#34;of %1$s: %2$s. Did you mean to bind an injector factory for the subtype?\u0026#34;; private final Map\u0026lt;String, Provider\u0026lt;AndroidInjector.Factory\u0026lt;?\u0026gt;\u0026gt;\u0026gt; injectorFactories; // 接上文10-1，这里就是初始化的位置，调用了merge方法 @Inject DispatchingAndroidInjector( Map\u0026lt;Class\u0026lt;?\u0026gt;, Provider\u0026lt;AndroidInjector.Factory\u0026lt;?\u0026gt;\u0026gt;\u0026gt; injectorFactoriesWithClassKeys, Map\u0026lt;String, Provider\u0026lt;AndroidInjector.Factory\u0026lt;?\u0026gt;\u0026gt;\u0026gt; injectorFactoriesWithStringKeys) { this.injectorFactories = merge(injectorFactoriesWithClassKeys, injectorFactoriesWithStringKeys); } // merge方法注释也说明了，就是将classKeyedMap的key从Class改为Class.getName的形式 /** * Merges the two maps into one by transforming the values of the {@code classKeyedMap} with * {@link Class#getName()}. * * \u0026lt;p\u0026gt;An SPI plugin verifies the logical uniqueness of the keysets of these two maps so we\u0026#39;re * assured there\u0026#39;s no overlap. * * \u0026lt;p\u0026gt;Ideally we could achieve this with a generic {@code @Provides} method, but we\u0026#39;d need to have * \u0026lt;i\u0026gt;N\u0026lt;/i\u0026gt; modules that each extend one base module. */ private static \u0026lt;C, V\u0026gt; Map\u0026lt;String, Provider\u0026lt;AndroidInjector.Factory\u0026lt;?\u0026gt;\u0026gt;\u0026gt; merge( Map\u0026lt;Class\u0026lt;? extends C\u0026gt;, V\u0026gt; classKeyedMap, Map\u0026lt;String, V\u0026gt; stringKeyedMap) { if (classKeyedMap.isEmpty()) { @SuppressWarnings({\u0026#34;unchecked\u0026#34;, \u0026#34;rawtypes\u0026#34;}) Map\u0026lt;String, Provider\u0026lt;AndroidInjector.Factory\u0026lt;?\u0026gt;\u0026gt;\u0026gt; safeCast = (Map) stringKeyedMap; return safeCast; } Map\u0026lt;String, V\u0026gt; merged = newLinkedHashMapWithExpectedSize(classKeyedMap.size() + stringKeyedMap.size()); merged.putAll(stringKeyedMap); for (Entry\u0026lt;Class\u0026lt;? extends C\u0026gt;, V\u0026gt; entry : classKeyedMap.entrySet()) { // put的位置，key是entry.getKey().getName()即Class.getName()，value为entry.getValue() // 即与classKeyedMap的value相同 merged.put(entry.getKey().getName(), entry.getValue()); } @SuppressWarnings({\u0026#34;unchecked\u0026#34;, \u0026#34;rawtypes\u0026#34;}) Map\u0026lt;String, Provider\u0026lt;AndroidInjector.Factory\u0026lt;?\u0026gt;\u0026gt;\u0026gt; safeCast = (Map) merged; return Collections.unmodifiableMap(safeCast); } // maybeInject方法即最终调用的位置，instance可以是Activity或者Fragment，如果对应我们之前的代码 // 此处应该是instance为MainActivity /** * Attempts to perform members-injection on {@code instance}, returning {@code true} if * successful, {@code false} otherwise. * * @throws InvalidInjectorBindingException if the injector factory bound for a class does not * inject instances of that class */ @CanIgnoreReturnValue public boolean maybeInject(T instance) { // injectorFactories为merge方法初始化得到的map，通过get(instance.getClass().getName()) // 得到Provider，那么对应我们的代码，这个factoryProvider是DaggerAppComponent.java中的mainActivitySubComponentFactoryProvider， // 如果调用mainActivitySubComponentFactoryProvider.inject(instance)即完成依赖注入 Provider\u0026lt;AndroidInjector.Factory\u0026lt;?\u0026gt;\u0026gt; factoryProvider = injectorFactories.get(instance.getClass().getName()); if (factoryProvider == null) { return false; } // factory = factoryProvider.get()，这里获取到了mainActivitySubComponentFactoryProvider @SuppressWarnings(\u0026#34;unchecked\u0026#34;) AndroidInjector.Factory\u0026lt;T\u0026gt; factory = (AndroidInjector.Factory\u0026lt;T\u0026gt;) factoryProvider.get(); try { // injector = factory.create(instance)，即返回了DaggerAppComponent.java中的MainActivitySubComponentImpl实例 AndroidInjector\u0026lt;T\u0026gt; injector = checkNotNull( factory.create(instance), \u0026#34;%s.create(I) should not return null.\u0026#34;, factory.getClass()); // injector.inject(instance)，熟悉的味道，这里就是调用MainActivitySubComponentImpl.inject方法的最终位置 // 在这里完成了实际的依赖注入，前提是需要调用DispatchingAndroidInjector的inject方法(此处预留伏笔) injector.inject(instance); return true; } catch (ClassCastException e) { throw new InvalidInjectorBindingException( String.format( \u0026#34;%s does not implement AndroidInjector.Factory\u0026lt;%s\u0026gt;\u0026#34;, factory.getClass().getCanonicalName(), instance.getClass().getCanonicalName()), e); } } // 倘若我们需要调用DispatchingAndroidInjector.inject方法，那么就执行了对instance的注入 // 实际调用的是maybeInject方法 /** * Performs members-injection on {@code instance}. * * @throws InvalidInjectorBindingException if the injector factory bound for a class does not * inject instances of that class * @throws IllegalArgumentException if no {@link AndroidInjector.Factory} is bound for {@code * instance} */ @Override public void inject(T instance) { boolean wasInjected = maybeInject(instance); if (!wasInjected) { throw new IllegalArgumentException(errorMessageSuggestions(instance)); } } /** * Exception thrown if an incorrect binding is made for a {@link AndroidInjector.Factory}. If you * see this exception, make sure the value in your {@code @ActivityKey(YourActivity.class)} or * {@code @FragmentKey(YourFragment.class)} matches the type argument of the injector factory. */ @Beta public static final class InvalidInjectorBindingException extends RuntimeException { InvalidInjectorBindingException(String message, ClassCastException cause) { super(message, cause); } } /** Returns an error message with the class names that are supertypes of {@code instance}. */ private String errorMessageSuggestions(T instance) { List\u0026lt;String\u0026gt; suggestions = new ArrayList\u0026lt;\u0026gt;(); for (Class\u0026lt;?\u0026gt; clazz = instance.getClass(); clazz != null; clazz = clazz.getSuperclass()) { if (injectorFactories.containsKey(clazz.getCanonicalName())) { suggestions.add(clazz.getCanonicalName()); } } return suggestions.isEmpty() ? String.format(NO_SUPERTYPES_BOUND_FORMAT, instance.getClass().getCanonicalName()) : String.format( SUPERTYPES_BOUND_FORMAT, instance.getClass().getCanonicalName(), suggestions); } } // 接上文9 public final class MyApplication_MembersInjector implements MembersInjector\u0026lt;MyApplication\u0026gt; { private final Provider\u0026lt;DispatchingAndroidInjector\u0026lt;Activity\u0026gt;\u0026gt; dispatchingActivityInjectorProvider; public MyApplication_MembersInjector( Provider\u0026lt;DispatchingAndroidInjector\u0026lt;Activity\u0026gt;\u0026gt; dispatchingActivityInjectorProvider) { this.dispatchingActivityInjectorProvider = dispatchingActivityInjectorProvider; } public static MembersInjector\u0026lt;MyApplication\u0026gt; create( Provider\u0026lt;DispatchingAndroidInjector\u0026lt;Activity\u0026gt;\u0026gt; dispatchingActivityInjectorProvider) { return new MyApplication_MembersInjector(dispatchingActivityInjectorProvider); } @Override public void injectMembers(MyApplication instance) { injectDispatchingActivityInjector(instance, dispatchingActivityInjectorProvider.get()); } // 9-1 调用injectDispatchingActivityInjector将DispatchingAndroidInjector注入到MyApplication中 // 然后需要找到DispatchingAndroidInjector的inject方法是在哪里在什么时候被执行的，还记得最初的起点吗 // MainActivity中的AndroidInjection.inject(this)，没错，我们回来了 public static void injectDispatchingActivityInjector( MyApplication instance, DispatchingAndroidInjector\u0026lt;Activity\u0026gt; dispatchingActivityInjector) { instance.dispatchingActivityInjector = dispatchingActivityInjector; } } // AndroidInjection.java public static void inject(Activity activity) { checkNotNull(activity, \u0026#34;activity\u0026#34;); Application application = activity.getApplication(); if (!(application instanceof HasActivityInjector)) { throw new RuntimeException( String.format( \u0026#34;%s does not implement %s\u0026#34;, application.getClass().getCanonicalName(), HasActivityInjector.class.getCanonicalName())); } AndroidInjector\u0026lt;Activity\u0026gt; activityInjector = ((HasActivityInjector) application).activityInjector(); checkNotNull(activityInjector, \u0026#34;%s.activityInjector() returned null\u0026#34;, application.getClass()); // 之前我们一直没有明白为什么有AndroidInjector类，为什么要调用activityInjector.inject(activity)方法 // 以及为什么需要HasActivityInjector接口,现在一切都清楚了 // activityInjector即DispatchingAndroidInjector_Factory.newInstance方法返回的DispatchingAndroidInjector实例 // 调用DispatchingAndroidInjector.inject会将DispatchingAndroidInjector_Factory.newInstance传入的Map的value中的 // 实例注入到activity中 activityInjector.inject(activity); } 上述代码过程比较长，下面重新整理一下inject的流程：\n将DispatchingAndroidInjector\u0026lt;Activity\u0026gt;注入到Application中，注入的时候会将AppComponent中的各个module所能提供的实例用Provider初始化，与此同时也会根据带有subcomponent和抽象方法的module生成MainActivitySubComponent.Factory的Provider，为注入到指定Activity提供接口； 在MainActivity中执行AndroidInjection.inject(this);即可获取@Inject修饰的实例，这是由于AndroidInjection.inject(this);实际上调用的是Application中的DispatchingAndroidInjector\u0026lt;Activity\u0026gt;.inject方法，DispatchingAndroidInjector\u0026lt;Activity\u0026gt;可以获取到在DaggerAppComponent初始化的实例的Provider以及对应MainActivity的MainActivitySubComponent.Factory的Provider，这个MainActivitySubComponent.Factory可以提供将实例注入到MainActivity中的inject方法，所以DispatchingAndroidInjector\u0026lt;Activity\u0026gt;.inject方法实际上是执行MainActivitySubComponent.Factory提供的inject方法，也就完成了注入。 至此，与依赖注入相关的自动生成的代码已经分析完毕了，整个注入的流程也明白了，但是还遗留了几个问题：\n为什么要在自定义Application进行注入，以及为什么要实现接口HasActivityInjector？ AppComponent的module为什么必须包含AndroidInjectionModule.class？ MainActivitySubComponent为什么要继承AndroidInjector，为什么要定义Factory继承AndroidInjector.Factory？ MainActivityModule的subcomponents为什么是MainActivitySubComponent.class，以及为什么要定义抽象方法bindMainActivityAndroidInjectorFactory？ 1.为什么要在自定义Application进行注入，以及为什么要实现接口HasActivityInjector？\n仔细看AndroidInjection.inject(this)的源码不难知道，activityInjector是来自于application的，为什么要依靠application， 因为当我们获取activityInjector时需要一个全局的类，其他Activity或者Fragment也能访问到，而且必须先于Activity或者Fragment被实例化， 在整个应用启动过程中只有application符合。\n为什么需要实现HasActivityInjector，这是因为application目前只负责Activity的注入，需要DispatchingAndroidInjector实例， 而activityInjector方法可以返回这个实例，DaggerAppComponent.create().inject(this);会将DispatchingAndroidInjector实例注入到application中。\n2.AppComponent的module为什么必须包含AndroidInjectionModule.class？\n首先看看AndroidInjectionModule的内容，抽象类加上@Multibinds标注的抽象方法，但是看classKeyedInjectorFactories和stringKeyedInjectorFactories两个名字就知道了，在上面的代码DispatchingAndroidInjector.java中出现过。\n/** * Contains bindings to ensure the usability of {@code dagger.android} framework classes. This * module should be installed in the component that is used to inject the {@link * android.app.Application} class. */ @Beta @Module public abstract class AndroidInjectionModule { @Multibinds abstract Map\u0026lt;Class\u0026lt;?\u0026gt;, AndroidInjector.Factory\u0026lt;?\u0026gt;\u0026gt; classKeyedInjectorFactories(); @Multibinds abstract Map\u0026lt;String, AndroidInjector.Factory\u0026lt;?\u0026gt;\u0026gt; stringKeyedInjectorFactories(); private AndroidInjectionModule() {} } MultiBinds只能用于标注抽象方法，它仅仅是告诉Component我有这么一种提供类型，让我们Component可以在Component中暴露Set或者Map类型的接口，但是不能包含具体的元素。\n再看DispatchingAndroidInjector的构造方法\n@Inject DispatchingAndroidInjector( Map\u0026lt;Class\u0026lt;?\u0026gt;, Provider\u0026lt;AndroidInjector.Factory\u0026lt;?\u0026gt;\u0026gt;\u0026gt; injectorFactoriesWithClassKeys, Map\u0026lt;String, Provider\u0026lt;AndroidInjector.Factory\u0026lt;?\u0026gt;\u0026gt;\u0026gt; injectorFactoriesWithStringKeys) { this.injectorFactories = merge(injectorFactoriesWithClassKeys, injectorFactoriesWithStringKeys); } DispatchingAndroidInjector的构造方法也是通过Inject方式，所以它的参数也必须由Component中的Module来提供，而且其参数是后续初始化过程确定的，所以需要用抽象类来实现，通过抽象类占位保证编译成功。\n3.MainActivitySubComponent为什么要继承AndroidInjector，为什么要定义Factory继承AndroidInjector.Factory？\n我们需要在DaggerAppComponent提供能将实例注入到指定Activity的Provider\u0026mdash;比如mainActivitySubComponentFactoryProvider，这个Provider需要能够提供Factory实现create方法，create方法能够返回MainActivitySubComponentImpl实现inject方法，这两个方法都是与MainActivity关联的，所以需要自定义MainActivitySubComponent，其继承的接口AndroidInjector包括create方法，而且内部接口AndroidInjector.Factory包括inject方法。\n4.MainActivityModule的subcomponents为什么是MainActivitySubComponent.class，以及为什么要定义抽象方法bindMainActivityAndroidInjectorFactory？\n抽象方法bindMainActivityAndroidInjectorFactory被@Binds修饰，提供的是这个方法的参数实例； AppComponent依赖MainActivityModule，作为父Component；MainActivitySubComponent作为子Component，用@Subcomponent标注；在父Component依赖的MainActivityModule的subcomponents参数加上MainActivitySubComponent，然后就可以在父ComponentAppComponent中请求SubComponent.Factory。此时SubComponent编译时不会生成 DaggerXXComponent，需要通过 父Component 的获取 SubComponent.Factory 方法获取 SubComponent 实例。\n以上过程中，如果要增加SecondActivity，那么同样需要增加SecondActivityModule和SecondActivitySubComponent，并且加在AppComponent的modules参数中，显然AppComponent的参数会很多，解决方法是\n如果您的subcomponent 及其构建器没有第2步中提到的其他方法或超类型，您可以使用@ContributesAndroidInjector为您生成它们。我们就不需要步骤2和3，取而代之的是添加一个抽象模块方法，该方法返回您的activity，使用@ContributesAndroidInjector对其进行注解，并指定要安装到子组件中的模块。 如果子组件需要scopes，则也可以用@scopes注解到该方法。\n代码如下\n@ActivityScope @ContributesAndroidInjector(modules = { /* modules to install into the subcomponent */ }) abstract YourActivity contributeYourActivityInjector(); 1.首先将Activity依赖的module都集中在一个module中ActivityBuilder\n@Module public abstract class ActivityBuilder { @ContributesAndroidInjector(modules = { MainActivityModule.class}) abstract MainActivity bindMainActivity(); @ContributesAndroidInjector(modules = { SecondActivityModule.class}) abstract SecondActivity bindSecondActivity(); } 2.修改AppComponent的modules参数，删掉之前对应Activity的module，增加ActivityBuilder，增加内部接口实现将Application context传出\n@Singleton @Component(modules = {AndroidInjectionModule.class, ActivityBuilder.class, AppModule.class}) public interface AppComponent { @Component.Builder interface Builder { @BindsInstance Builder application(Application application); AppComponent build(); } void inject(MyApplication application); } 3.修改MainActivityModule，非抽象类，删掉抽象方法，删掉subcomponents参数，同理对SecondActivityModule；修改AppModule，增加Context的provide方法\n@Module public class MainActivityModule { @Provides Entity provideEntity() { return new Entity(); } } @Module public class SecondActivityModule { @Provides Integer provideInteger() { return 123; } } @Module public class AppModule { @Provides @Singleton String provideGlobalInfo() { return \u0026#34;This is global info\u0026#34;; } @Provides @Singleton Context provideContext(Application application) { return application; } } 4.在Activity中注入，Application不变\npublic class MainActivity extends AppCompatActivity { @Inject Entity entity; @Inject String info; @Inject Context context; @Override protected void onCreate(Bundle savedInstanceState) { AndroidInjection.inject(this); super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); String text = entity.showMessage() + \u0026#34; - \u0026#34; + info; Log.i(\u0026#34;aaaa\u0026#34;, text); Log.i(\u0026#34;aaaa\u0026#34;, context.toString()); startActivity(new Intent(MainActivity.this, SecondActivity.class)); } } public class SecondActivity extends AppCompatActivity { @Inject String info; @Inject Integer num; @Inject Context context; @Override protected void onCreate(Bundle savedInstanceState) { AndroidInjection.inject(this); super.onCreate(savedInstanceState); setContentView(R.layout.activity_second); Log.i(\u0026#34;aaaa\u0026#34;, info + num); Log.i(\u0026#34;aaaa\u0026#34;, context.toString()); } } public class MyApplication extends Application implements HasActivityInjector { @Inject DispatchingAndroidInjector\u0026lt;Activity\u0026gt; dispatchingActivityInjector; @Override public void onCreate() { super.onCreate(); DaggerAppComponent .builder() .application(this) .build() .inject(this); } @Override public AndroidInjector\u0026lt;Activity\u0026gt; activityInjector() { return dispatchingActivityInjector; } } 这样我们就可以通过依赖注入的方式将全局Context注入到所有的Activity中，看log也可以发现两个context是相同的。\n2.3 Injecting Fragment objects 为Fragment注入对象，需要在Fragment的onAttach()方法中执行AndroidSupportInjection.inject(this);\n提供Fragment实例的Component可以是其他Fragment的Component的Subcomponent，也可以是Activity的Component的Subcomponent，同样也可以是Application的Component的Subcomponent，具体情况具体分析，看你的Fragment生命周期要求。比如这里我们在SecondActivity中增加一个Fragment，Fragment显示的内容是Entity的列表\n以基于Activity为例，首先需要对宿主Activity进行处理\npublic class SecondActivity extends AppCompatActivity implements HasSupportFragmentInjector { // 以基于SecondActivity的方式对从SecondActivity启动的Fragment进行注入，则需要实现HasSupportFragmentInjector接口 // 这个接口的方法非常类似Application中的，功能基本相同，不过此处说明生命周期与SecondActivity相同，如果SecondActivity不存在 // 那么EntityFragment也无法注入 @Inject DispatchingAndroidInjector\u0026lt;Fragment\u0026gt; fragmentDispatchingAndroidInjector; @Inject String info; @Inject Integer num; @Override protected void onCreate(Bundle savedInstanceState) { AndroidInjection.inject(this); super.onCreate(savedInstanceState); setContentView(R.layout.activity_second); Log.i(\u0026#34;aaaa\u0026#34;, info + num); // 加载EntityFragment getSupportFragmentManager() .beginTransaction() .disallowAddToBackStack() .add(R.id.container, EntityFragment.newInstance(), EntityFragment.TAG) .commit(); } @Override public AndroidInjector\u0026lt;Fragment\u0026gt; supportFragmentInjector() { return fragmentDispatchingAndroidInjector; } } 然后是定义的EntityFragment\npublic class EntityFragment extends Fragment { public static final String TAG = EntityFragment.class.getSimpleName(); // 仔细思考Fragment+RecyclerView需要注入哪些对象，很显然常见的是LinearLayoutManager和RecyclerView.Adapter @Inject LinearLayoutManager mLayoutManager; @Inject EntityListAdapter mEntityListAdapter; private RecyclerView recyclerView; public static EntityFragment newInstance() { Bundle args = new Bundle(); EntityFragment fragment = new EntityFragment(); fragment.setArguments(args); return fragment; } // 在onAttach中注入 @Override public void onAttach(Context context) { AndroidSupportInjection.inject(this); super.onAttach(context); } @Nullable @Override public View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) { View view = inflater.inflate(R.layout.fragment_item_list, container, false); List\u0026lt;Entity\u0026gt; data = new ArrayList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; 10; i++) { data.add(new Entity()); } // 这里就可以直接用 mEntityListAdapter.addItems(data); recyclerView = view.findViewById(R.id.list); recyclerView.setLayoutManager(mLayoutManager); recyclerView.setAdapter(mEntityListAdapter); return view; } } 与EntityFragment相关的注入的对象有LinearLayoutManager和EntityListAdapter，因此需要module提供这两者的实例\n// EntityFragment依赖EntityFragmentModule提供的实例 @Module public class EntityFragmentModule { @Provides LinearLayoutManager provideLinearLayoutManager(EntityFragment fragment) { return new LinearLayoutManager(fragment.getActivity()); } @Provides EntityListAdapter provideEntityListAdapter() { return new EntityListAdapter(); } } 根据2.2最后一部分的内容做一个优化，将module绑定到另一个集成module中\n@Module public abstract class EntityFragmentProvider { @ContributesAndroidInjector(modules = EntityFragmentModule.class) abstract EntityFragment provideEntityFragmentFactory(); } 修改ActivityBuilder，将EntityFragmentProvider加入\n@Module public abstract class ActivityBuilder { @ContributesAndroidInjector(modules = { MainActivityModule.class}) abstract MainActivity bindMainActivity(); @ContributesAndroidInjector(modules = { SecondActivityModule.class, EntityFragmentProvider.class}) abstract SecondActivity bindSecondActivity(); } 最后看一下EntityListAdapter的实现\npublic class EntityListAdapter extends RecyclerView.Adapter\u0026lt;EntityListAdapter.MyViewHolder\u0026gt; { private List\u0026lt;Entity\u0026gt; data; public EntityListAdapter() { this.data = new ArrayList\u0026lt;\u0026gt;(); } public void addItems(List\u0026lt;Entity\u0026gt; list) { data.addAll(list); notifyDataSetChanged(); } @NonNull @Override public MyViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) { View view = LayoutInflater.from(parent.getContext()).inflate(R.layout.fragment_item, parent, false); MyViewHolder viewHolder = new MyViewHolder(view); return viewHolder; } @Override public void onBindViewHolder(@NonNull MyViewHolder holder, int position) { Entity entity = data.get(position); holder.number.setText(String.valueOf(position)); holder.content.setText(entity.showMessage()); } @Override public int getItemCount() { return data.size(); } class MyViewHolder extends RecyclerView.ViewHolder { TextView number; TextView content; MyViewHolder(@NonNull View itemView) { super(itemView); number = itemView.findViewById(R.id.item_number); content = itemView.findViewById(R.id.content); } } } 参考： Android开发之dagger.android\u0026ndash;Activity Dagger Dagger2 最清晰的使用教程 The New Dagger2 Dagger 2 完全解析 ","permalink":"https://zhoutao822.github.io/posts/dagger2/","summary":"Dagger2框架是一个依赖注入框架，它既可以用于Java Web项目也可以用于Android项目","title":"Android框架-Dagger2"},{"content":"Menu，不同于Button、TextView之类的控件，它不需要在布局文件中指定位置，它是用于提供给用户额外的操作选择，因此不必局限于某一个固定位置，它可以搭配任何控件。\n常见的Menu可以分为三种：\nToolBar上的选项菜单，这是固定的设计，配合ToolBar实现很简单； 上下文菜单ContextMenu，与某一个控件关联，可以实现在点击（长按）的位置出现菜单选项的效果； 弹出菜单PopupMenu，动态生成，作为一个点击事件触发，出现的位置与被点击的控件位置绑定（上方或下方），与上下文菜单不同。 1. 菜单选项数据来源 如上图所示，展开的就是菜单Menu，菜单中包含一个一个的MenuItem，前面已经说了Menu不同于Button之类的控件，它的使用也是非常不同，最重要的部分其实是如何定义这些MenuItem，推荐的做法是使用xml资源文件定义MenuItem的文字内容以及Icon等等，然后在activity或fragment中处理点击事件；当然还有动态添加的方式可以使用。\n1.1 使用xml定义菜单 这里先不必考虑如何使用Menu，只是定义菜单选项，需要在res/menu/目录下建一个xml文件\n\u0026lt;!-- menu_main.xml --\u0026gt; \u0026lt;menu xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; xmlns:app=\u0026#34;http://schemas.android.com/apk/res-auto\u0026#34;\u0026gt; \u0026lt;item android:id=\u0026#34;@+id/action_add_a_contact\u0026#34; android:icon=\u0026#34;@drawable/ic_add_black_24dp\u0026#34; android:title=\u0026#34;Add a Contact\u0026#34; app:showAsAction=\u0026#34;always\u0026#34; /\u0026gt; \u0026lt;item android:id=\u0026#34;@+id/action_create_a_contact_group\u0026#34; android:icon=\u0026#34;@drawable/ic_create_black_24dp\u0026#34; android:title=\u0026#34;Create a Contact Group\u0026#34; app:showAsAction=\u0026#34;never\u0026#34; /\u0026gt; \u0026lt;item android:id=\u0026#34;@+id/action_add_a_app\u0026#34; android:title=\u0026#34;Add a App\u0026#34; app:showAsAction=\u0026#34;always\u0026#34; /\u0026gt; \u0026lt;item android:id=\u0026#34;@+id/submenu\u0026#34; android:title=\u0026#34;Submenu\u0026#34;\u0026gt; \u0026lt;menu\u0026gt; \u0026lt;item android:id=\u0026#34;@+id/action_create_a_channel\u0026#34; android:icon=\u0026#34;@drawable/ic_create_new_folder_black_24dp\u0026#34; android:title=\u0026#34;Create a Channel\u0026#34; app:showAsAction=\u0026#34;never\u0026#34; /\u0026gt; \u0026lt;item android:id=\u0026#34;@+id/action_join_a_channel\u0026#34; android:icon=\u0026#34;@drawable/ic_adjust_black_24dp\u0026#34; android:title=\u0026#34;Join a Channel\u0026#34; app:showAsAction=\u0026#34;never\u0026#34; /\u0026gt; \u0026lt;/menu\u0026gt; \u0026lt;/item\u0026gt; \u0026lt;/menu\u0026gt; 上面的布局文件产生的效果如下图所示\n有几个特点：\n如果Item设置了Icon，那么如果出现在ToolBar上就是Icon，如果没有设置Icon，则显示大写文字； Icon在折叠的Menu中不显示，但是在二级菜单中可以显示； Item的顺序会被showAsAction参数影响。 1.2 在Activity中使用Menu 只需要在activity中重写onCreateOptionsMenu()方法即可，将上面定义的xml资源文件加载，前提是有ToolBar\n@Override public boolean onCreateOptionsMenu(Menu menu) { super.onCreateOptionsMenu(menu); getMenuInflater().inflate(R.menu.menu_main, menu); return true; } 点击事件处理，只需要在activity中重写onOptionsItemSelected()方法即可\n@Override public boolean onOptionsItemSelected(MenuItem item) { switch (item.getItemId()) { case R.id.action_add_a_contact: Toast.makeText(this, \u0026#34;action_add_a_contact\u0026#34;, Toast.LENGTH_SHORT).show(); return true; case R.id.action_create_a_channel: Toast.makeText(this, \u0026#34;action_create_a_channel\u0026#34;, Toast.LENGTH_SHORT).show(); return true; case R.id.action_create_a_contact_group: Toast.makeText(this, \u0026#34;action_create_a_contact_group\u0026#34;, Toast.LENGTH_SHORT).show(); return true; case R.id.action_add_a_app: Toast.makeText(this, \u0026#34;action_add_a_app\u0026#34;, Toast.LENGTH_SHORT).show(); return true; case R.id.action_join_a_channel: Toast.makeText(this, \u0026#34;action_join_a_channel\u0026#34;, Toast.LENGTH_SHORT).show(); return true; default: return super.onOptionsItemSelected(item); } } 如果需要在运行时修改MenuItem的状态，可以重写onPrepareOptionsMenu()方法（每点击一次都会执行一次），比如可以在这里进行状态判断以禁用某些选项\n// 首先需要一个flag控制 private Boolean flag = false; // 其次在需要动态修改Menu状态的位置修改flag值，然后调用invalidateOptionsMenu()， // 这个方法会调用onPrepareOptionsMenu()方法，从而实现Menu的状态变化 button.setOnClickListener(v -\u0026gt; { flag = true; invalidateOptionsMenu(); // Android 3.0 及更高版本中必须调用invalidateOptionsMenu }); @Override public boolean onPrepareOptionsMenu(Menu menu) { if (flag) { menu.findItem(R.id.action_create_a_contact_group).setVisible(false); menu.findItem(R.id.action_join_a_channel).setVisible(false); } return super.onPrepareOptionsMenu(menu); } 1.3 修改默认的ToolBar Menu图标以及点击背景色 默认为三个点，可以在styles.xml中进行修改\n比如ToolBar在布局文件中如下\n\u0026lt;androidx.appcompat.widget.Toolbar android:id=\u0026#34;@+id/my_toolbar\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;?attr/actionBarSize\u0026#34; android:elevation=\u0026#34;4dp\u0026#34; android:theme=\u0026#34;@style/ToolbarBase\u0026#34; app:popupTheme=\u0026#34;@style/OverflowMenu\u0026#34;\u0026gt; \u0026lt;/androidx.appcompat.widget.Toolbar\u0026gt; 两个参数\ntheme：为整个ToolBar的主题，actionOverflowButtonStyle可以修改默认图标 popupTheme：为弹出的Menu的主题，colorControlHighlight可以修改点击背景色 \u0026lt;style name=\u0026#34;ToolbarBase\u0026#34; parent=\u0026#34;ThemeOverlay.AppCompat.ActionBar\u0026#34;\u0026gt; \u0026lt;item name=\u0026#34;actionOverflowButtonStyle\u0026#34;\u0026gt;@style/OverflowButtonStyle\u0026lt;/item\u0026gt; \u0026lt;!--\u0026lt;item name=\u0026#34;actionOverflowMenuStyle\u0026#34;\u0026gt;@style/OverflowMenu\u0026lt;/item\u0026gt;--\u0026gt; \u0026lt;/style\u0026gt; \u0026lt;style name=\u0026#34;OverflowButtonStyle\u0026#34; parent=\u0026#34;@android:style/Widget.ActionButton.Overflow\u0026#34;\u0026gt; \u0026lt;item name=\u0026#34;android:src\u0026#34;\u0026gt;@drawable/ic_add_circle_outline_black_24dp\u0026lt;/item\u0026gt; \u0026lt;item name=\u0026#34;overlapAnchor\u0026#34;\u0026gt;false\u0026lt;/item\u0026gt; \u0026lt;/style\u0026gt; \u0026lt;style name=\u0026#34;OverflowMenu\u0026#34; parent=\u0026#34;ThemeOverlay.AppCompat.Light\u0026#34;\u0026gt; \u0026lt;!--遮挡属性--\u0026gt; \u0026lt;item name=\u0026#34;overlapAnchor\u0026#34;\u0026gt;false\u0026lt;/item\u0026gt; \u0026lt;!--MenuItem选中背景颜色--\u0026gt; \u0026lt;item name=\u0026#34;colorControlHighlight\u0026#34;\u0026gt;@color/holo_blue_light\u0026lt;/item\u0026gt; \u0026lt;/style\u0026gt; 2. 上下文菜单 ContextMenu可以用在非常多的控件上，这里仅简单使用Button和RecyclerView，通常来说，触发ContextMenu的方式是长按，因此与该控件的OnLongClick事件冲突， 如果在onLongClick()方法中返回true，则代表点击事件被消耗，不再继续传递，那么ContextMenu不会触发；反之返回false，则ContextMenu被触发。由此可知，onLongClick()的优先级在ContextMenu之上，具体会在Android事件传递中分析。\nContextMenu可以在一个Activity中有多个，甚至可以在RecyclerView中使用，但是仅需要重写两个方法即可判断ContextMenu的来源。\n如上图所示，Upload后面跟的是该控件的ItemId，三个Menu各不相同，所以显然我们可以根据控件的不同生成不同的ContextMenu，点击事件同理。\n使用ContextMenu的三个步骤：\n1.注册，更确切的说法是关联，即指定需要生成ContextMenu的控件，一句话解决\nregisterForContextMenu(recyclerView); // 对RecyclerView也是一样，但是这里我用的是自定义RecyclerView，稍后解释 registerForContextMenu(button); // 直接在onCreate中注册即可，有几个控件就注册几次 registerForContextMenu(button1); 2.重写onCreateContextMenu方法，生成Menu\n@Override public void onCreateContextMenu(ContextMenu menu, View v, ContextMenu.ContextMenuInfo menuInfo) { super.onCreateContextMenu(menu, v, menuInfo); // 这里实现了根据Id不同生成不同的Menu switch (v.getId()) { case R.id.first_button: addMenu(menu, v); break; case R.id.second_button: addMenu(menu, v); break; case R.id.recycler_view: addMenu(menu, v); default: break; } } private void addMenu(ContextMenu menu, View v) { menu.setHeaderTitle(\u0026#34;Context Menu\u0026#34;); menu.add(0, v.getId(), 0, \u0026#34;Upload\u0026#34; + v.getId()); menu.add(0, v.getId(), 0, \u0026#34;Search\u0026#34;); menu.add(1, v.getId(), 0, \u0026#34;Share\u0026#34;); menu.add(1, v.getId(), 0, \u0026#34;Bookmark\u0026#34;); // 同时可以通过groupId来禁用某些选项，这是额外的功能 menu.setGroupEnabled(1, false); } 3.重写onContextItemSelected方法，点击事件响应\n@Override public boolean onContextItemSelected(MenuItem item) { // 这里需要注意，因为RecyclerView需要传入Item的Position属性，所以需要自定义RecyclerView RecyclerViewWithContextMenu.RecyclerViewContextInfo info = (RecyclerViewWithContextMenu.RecyclerViewContextInfo) item.getMenuInfo(); Log.d(TAG, \u0026#34;onCreateContextMenu position = \u0026#34; + (info != null ? info.getPosition() : \u0026#34;-1\u0026#34;)); // 通过判断点击的Item是否存在getMenuInfo获得的值，可以判断点击事件的来源，RecyclerView还是Button if (info != null \u0026amp;\u0026amp; info.getPosition() != -1) { Toast.makeText(this, \u0026#34;Selected Item: \u0026#34; + item.getTitle() + \u0026#34; data: \u0026#34; + data.get(info.getPosition()), Toast.LENGTH_SHORT).show(); } else { Toast.makeText(this, \u0026#34;Selected Item: \u0026#34; + item.getTitle(), Toast.LENGTH_SHORT).show(); } return true; } 自定义的RecyclerViewWithContextMenu public class RecyclerViewWithContextMenu extends RecyclerView { private static final String TAG = RecyclerViewWithContextMenu.class.getSimpleName(); private RecyclerViewContextInfo mContextInfo = new RecyclerViewContextInfo(); public RecyclerViewWithContextMenu(@NonNull Context context) { super(context); } public RecyclerViewWithContextMenu(@NonNull Context context, @Nullable AttributeSet attrs) { super(context, attrs); } public RecyclerViewWithContextMenu(@NonNull Context context, @Nullable AttributeSet attrs, int defStyle) { super(context, attrs, defStyle); } // 关键方法，重写showContextMenuForChild，将position属性传出去 @Override public boolean showContextMenuForChild(View originalView) { final int longPressPosition = getChildAdapterPosition(originalView); if (longPressPosition \u0026gt;= 0) { mContextInfo.mPosition = longPressPosition; return super.showContextMenuForChild(originalView); } return false; } @Override protected ContextMenu.ContextMenuInfo getContextMenuInfo() { return mContextInfo; } // 通过自定义的ContextMenuInfo保存position的值，并提供调用的方法 public static class RecyclerViewContextInfo implements ContextMenu.ContextMenuInfo { private int mPosition = -1; public int getPosition() { return mPosition; } } } 3. 弹出菜单 PopupMenu是使用上最简单的，它的效果与ContextMenu类似但不完全相同，主要是位置是相对固定的，但是PopupMenu可以动态调用，与整体的布局无关\npublic class MainActivity extends AppCompatActivity implements PopupMenu.OnMenuItemClickListener { private static final String TAG = MainActivity.class.getSimpleName(); // ... @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); // ... // PopupMenu通过onClick事件创建 findViewById(R.id.pop_button).setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { showPopupMenu(v); } }); // ... } // ... public void showPopupMenu(View v) { // new一个对象，同样可以使用xml加载选项 PopupMenu popup = new PopupMenu(this, v); popup.inflate(R.menu.menu_main); popup.show(); // 这里需要继承PopupMenu.OnMenuItemClickListener接口 popup.setOnMenuItemClickListener(this); } @Override public boolean onMenuItemClick(MenuItem item) { // 点击事件响应 switch (item.getItemId()) { case R.id.action_add_a_contact: Toast.makeText(this, \u0026#34;action_add_a_contact\u0026#34;, Toast.LENGTH_SHORT).show(); return true; case R.id.action_create_a_channel: Toast.makeText(this, \u0026#34;action_create_a_channel\u0026#34;, Toast.LENGTH_SHORT).show(); return true; case R.id.action_create_a_contact_group: Toast.makeText(this, \u0026#34;action_create_a_contact_group\u0026#34;, Toast.LENGTH_SHORT).show(); return true; case R.id.action_add_a_app: Toast.makeText(this, \u0026#34;action_add_a_app\u0026#34;, Toast.LENGTH_SHORT).show(); return true; case R.id.action_join_a_channel: Toast.makeText(this, \u0026#34;action_join_a_channel\u0026#34;, Toast.LENGTH_SHORT).show(); return true; default: return super.onOptionsItemSelected(item); } } } 4. Android事件分发机制 之所以会想到Android事件分发机制，主要是在ContextMenu的使用上发现长按事件的处理以及冲突，从而对长按事件优先级有一点思考，结合一些参考的文章，写一下自己的理解。\n在使用ContextMenu中会产生以下几个问题，根据这些问题，可以尝试在源码里找结果。\n为什么ContextMenu只需要注册就可以使用，而不是new一个对象出来，类似于PopupMenu？ 首先看与ContextMenu相关的几个方法：\nregisterForContextMenu\nonCreateContextMenu\nonContextItemSelected\n// Activity.java registerForContextMenu这个方法仅仅是对view进行了注册listener /** * Registers a context menu to be shown for the given view (multiple views * can show the context menu). This method will set the * {@link OnCreateContextMenuListener} on the view to this activity, so * {@link #onCreateContextMenu(ContextMenu, View, ContextMenuInfo)} will be * called when it is time to show the context menu. * * @see #unregisterForContextMenu(View) * @param view The view that should show a context menu. */ public void registerForContextMenu(View view) { view.setOnCreateContextMenuListener(this); } // -------------------------------------------------------------------------------- // View.java 注册的过程中通过setLongClickable强制让此控件可以被long click，同时传递listener /** * Register a callback to be invoked when the context menu for this view is * being built. If this view is not long clickable, it becomes long clickable. * * @param l The callback that will run * */ public void setOnCreateContextMenuListener(OnCreateContextMenuListener l) { if (!isLongClickable()) { setLongClickable(true); } getListenerInfo().mOnCreateContextMenuListener = l; } /** * Listener used to build the context menu. * This field should be made private, so it is hidden from the SDK. * {@hide} */ protected OnCreateContextMenuListener mOnCreateContextMenuListener; // 这个listener的作用就是通过li.mOnCreateContextMenuListener.onCreateContextMenu(menu, this, menuInfo) // 将menu和menuInfo传出去，也就是说，我们在调用super.onCreateContextMenu(menu, v, menuInfo)后即可得到menu的实例， // 然后对menu实例进行处理，比如menu.add增加选项、menu.setGroupEnabled设置可点击的选项等等， // 此处暂不讨论createContextMenu是在哪里调用的，因为涉及到PhoneWindow和DecorView。 /** * Show the context menu for this view. It is not safe to hold on to the * menu after returning from this method. * * You should normally not overload this method. Overload * {@link #onCreateContextMenu(ContextMenu)} or define an * {@link OnCreateContextMenuListener} to add items to the context menu. * * @param menu The context menu to populate */ public void createContextMenu(ContextMenu menu) { ContextMenuInfo menuInfo = getContextMenuInfo(); // Sets the current menu info so all items added to menu will have // my extra info set. ((MenuBuilder)menu).setCurrentMenuInfo(menuInfo); onCreateContextMenu(menu); ListenerInfo li = mListenerInfo; if (li != null \u0026amp;\u0026amp; li.mOnCreateContextMenuListener != null) { li.mOnCreateContextMenuListener.onCreateContextMenu(menu, this, menuInfo); } // Clear the extra information so subsequent items that aren\u0026#39;t mine don\u0026#39;t // have my extra info. ((MenuBuilder)menu).setCurrentMenuInfo(null); if (mParent != null) { mParent.createContextMenu(menu); } } // -------------------------------------------------------------------------------- // Activity.java Item点击事件响应，除了ContextMenu，可以发现普通的ToolBar上的Menu的点击（onOptionsItemSelected） // 也是在这里响应的。 /** * Default implementation of * {@link android.view.Window.Callback#onMenuItemSelected} * for activities. This calls through to the new * {@link #onOptionsItemSelected} method for the * {@link android.view.Window#FEATURE_OPTIONS_PANEL} * panel, so that subclasses of * Activity don\u0026#39;t need to deal with feature codes. */ public boolean onMenuItemSelected(int featureId, MenuItem item) { CharSequence titleCondensed = item.getTitleCondensed(); // 通过featureId参数判断是来自ToolBar的Menu还是ContextMenu，显然这个参数来自于onMenuItemSelected方法被调用的地方 // 可以在ToolbarWidgetWrapper.java和PhoneWindow.java中找到 switch (featureId) { case Window.FEATURE_OPTIONS_PANEL: // Put event logging here so it gets called even if subclass // doesn\u0026#39;t call through to superclass\u0026#39;s implmeentation of each // of these methods below if(titleCondensed != null) { EventLog.writeEvent(50000, 0, titleCondensed.toString()); } // 在这里可以看到如果onOptionsItemSelected返回false，点击事件会继续传递下去，所以我们在重写onOptionsItemSelected // 方法时会在执行对应选项的点击事件后返回true以消耗点击事件 if (onOptionsItemSelected(item)) { return true; } if (mFragments.dispatchOptionsItemSelected(item)) { return true; } if (item.getItemId() == android.R.id.home \u0026amp;\u0026amp; mActionBar != null \u0026amp;\u0026amp; (mActionBar.getDisplayOptions() \u0026amp; ActionBar.DISPLAY_HOME_AS_UP) != 0) { if (mParent == null) { return onNavigateUp(); } else { return mParent.onNavigateUpFromChild(this); } } return false; case Window.FEATURE_CONTEXT_MENU: if(titleCondensed != null) { EventLog.writeEvent(50000, 1, titleCondensed.toString()); } // 同上 if (onContextItemSelected(item)) { return true; } return mFragments.dispatchContextItemSelected(item); default: return false; } } 综上所述，ContextMenu其实是一个比较深层次的控件，它的创建过程被更复杂的PhoneWindow以及DecorView等控制，对开发者来说，Menu是一个直接使用就行的控件，底层不希望开发者对Menu进行指定布局选项之外的操作，因此我们不需要new一个对象出来。至于它是如何在PhoneWindow以及DecorView中创建的，我可能在接下来的博客中写一下自己的理解。\nContextMenu的触发与该控件的onLongClick方法的冲突是如何产生的？ 在上面ContextMenu的使用过程中，会发现ContextMenu默认是长按触发，而且源码里也说明了，控件会被强制赋予长按属性，那么如果同时设置该控件的onLongClick方法会产生怎样的效果，代码很简单，这里有一个疑问了，为什么要返回true？如果返回false会怎样？为什么onClick方法不用返回值？\nbutton.setOnLongClickListener(new View.OnLongClickListener() { @Override public boolean onLongClick(View v) { Toast.makeText(MainActivity.this, \u0026#34;button long click\u0026#34;, Toast.LENGTH_SHORT).show(); return true; } }); 结果也是很明显的，测试一下就知道这里返回true，那么button的ContextMenu无法触发，Toast会正常产生；返回false，那么button的Toast会产生，而且ContextMenu也会产生，onLongClick方法在onCreateContextMenu方法之前执行。\n由此产生了另一个问题，onLongClick方法是如何产生的，解决了这个问题，那么所有的问题都将迎刃而解。\n// View.java 最直接的调用onLongClick方法的位置 /** * Calls this view\u0026#39;s OnLongClickListener, if it is defined. Invokes the * context menu if the OnLongClickListener did not consume the event, * optionally anchoring it to an (x,y) coordinate. * * @param x x coordinate of the anchoring touch event, or {@link Float#NaN} * to disable anchoring * @param y y coordinate of the anchoring touch event, or {@link Float#NaN} * to disable anchoring * @return {@code true} if one of the above receivers consumed the event, * {@code false} otherwise */ private boolean performLongClickInternal(float x, float y) { sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_LONG_CLICKED); boolean handled = false; final ListenerInfo li = mListenerInfo; if (li != null \u0026amp;\u0026amp; li.mOnLongClickListener != null) { // listener调用onLongClick方法的位置，返回值为handled handled = li.mOnLongClickListener.onLongClick(View.this); } // 如果handled为true，则不会执行下面整个方法showContextMenu，看名字也知道这是ContextMenu显示的方法了， // 所以如果onLongClick返回true，则不会显示ContextMenu；反之同理。所以上面关于执行先后顺序的疑问解决了 if (!handled) { final boolean isAnchored = !Float.isNaN(x) \u0026amp;\u0026amp; !Float.isNaN(y); handled = isAnchored ? showContextMenu(x, y) : showContextMenu(); } if ((mViewFlags \u0026amp; TOOLTIP) == TOOLTIP) { // 如果handled为true，则不会执行下面整个方法showLongClickTooltip，这个Tooltip是另一个控件， // 其触发也是与长按事件相关，暂且不表 if (!handled) { handled = showLongClickTooltip((int) x, (int) y); } } if (handled) { performHapticFeedback(HapticFeedbackConstants.LONG_PRESS); } // 最后还是返回handled的值 return handled; } // 再看看onClick方法的调用，很明显单击事件没有其他控件与其冲突，所以它的返回值为空 /** * Call this view\u0026#39;s OnClickListener, if it is defined. Performs all normal * actions associated with clicking: reporting accessibility event, playing * a sound, etc. * * @return True there was an assigned OnClickListener that was called, false * otherwise is returned. */ // NOTE: other methods on View should not call this method directly, but performClickInternal() // instead, to guarantee that the autofill manager is notified when necessary (as subclasses // could extend this method without calling super.performClick()). public boolean performClick() { // We still need to call this method to handle the cases where performClick() was called // externally, instead of through performClickInternal() notifyAutofillManagerOnClick(); final boolean result; final ListenerInfo li = mListenerInfo; if (li != null \u0026amp;\u0026amp; li.mOnClickListener != null) { playSoundEffect(SoundEffectConstants.CLICK); // 无返回值，没有冲突，result直接设置为true即可 li.mOnClickListener.onClick(this); result = true; } else { result = false; } sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED); notifyEnterOrExitForAutoFillIfNeeded(true); return result; } // 然后就是点击事件与长按事件是如何产生的，这里牵涉到onTouchEvent方法，这里把无关代码略过，仅保留重要代码 /** * Implement this method to handle touch screen motion events. * \u0026lt;p\u0026gt; * If this method is used to detect click actions, it is recommended that * the actions be performed by implementing and calling * {@link #performClick()}. This will ensure consistent system behavior, * including: * \u0026lt;ul\u0026gt; * \u0026lt;li\u0026gt;obeying click sound preferences * \u0026lt;li\u0026gt;dispatching OnClickListener calls * \u0026lt;li\u0026gt;handling {@link AccessibilityNodeInfo#ACTION_CLICK ACTION_CLICK} when * accessibility features are enabled * \u0026lt;/ul\u0026gt; * * @param event The motion event. * @return True if the event was handled, false otherwise. */ public boolean onTouchEvent(MotionEvent event) { // ... if (clickable || (viewFlags \u0026amp; TOOLTIP) == TOOLTIP) { switch (action) { // MotionEvent分为四种ACTION_UP、ACTION_DOWN、ACTION_CANCEL、ACTION_MOVE // 分别对应手指在屏幕的状态：抬起、按下、（例外，暂且不解释）、滑动 // 通过对这些MotionEvent的监听可以实现各种点击效果，比如多连击、定时点击等等效果， // 也可以控制事件的冲突，我们仅需要在自定义控件中重写onTouchEvent方法即可。 case MotionEvent.ACTION_UP: // ... // 为什么要在抬起的时候触发点击事件performClick，因为长按与点击是有冲突的， // 长按会在ACTION_DOWN里触发，这是由时间控制的，因此ACTION_UP中与长按事件其实关系就不大了 // 所以在这里处理点击事件是一个较为合理的设计 if ((mPrivateFlags \u0026amp; PFLAG_PRESSED) != 0 || prepressed) { // take focus if we don\u0026#39;t have it already and we should in // touch mode. boolean focusTaken = false; if (isFocusable() \u0026amp;\u0026amp; isFocusableInTouchMode() \u0026amp;\u0026amp; !isFocused()) { focusTaken = requestFocus(); } if (prepressed) { // The button is being released before we actually // showed it as pressed. Make it show the pressed // state now (before scheduling the click) to ensure // the user sees it. setPressed(true, x, y); } if (!mHasPerformedLongPress \u0026amp;\u0026amp; !mIgnoreNextUpEvent) { // This is a tap, so remove the longpress check removeLongPressCallback(); // Only perform take click actions if we were in the pressed state if (!focusTaken) { // Use a Runnable and post this rather than calling // performClick directly. This lets other visual state // of the view update before click actions start. if (mPerformClick == null) { // 点击事件的关键，这里的PerformClick是一个Runnable，为什么要用Runnable，之后再解释 mPerformClick = new PerformClick(); } // 通过handler调用performClick方法，点击事件就完成了 if (!post(mPerformClick)) { performClickInternal(); } } } // ... } mIgnoreNextUpEvent = false; break; case MotionEvent.ACTION_DOWN: if (event.getSource() == InputDevice.SOURCE_TOUCHSCREEN) { mPrivateFlags3 |= PFLAG3_FINGER_DOWN; } // mHasPerformedLongPress用于解决长按与点击的事件冲突，具体可以看源码 mHasPerformedLongPress = false; // clickable表示该控件是否可以点击（包括点击、长按等） if (!clickable) { // 如果控件不可点击，那么会判断是否需要显示Tooltip或者什么都不干，然后break， // 具体可以看checkForLongClick方法 checkForLongClick(0, x, y); break; } // performButtonActionOnTouchDown与外设有关，暂时不用考虑 if (performButtonActionOnTouchDown(event)) { break; } // Walk up the hierarchy to determine if we\u0026#39;re inside a scrolling container. boolean isInScrollingContainer = isInScrollingContainer(); // For views inside a scrolling container, delay the pressed feedback for // a short period in case this is a scroll. // 该控件在一个可以滑动的container内，则会增加一个反应延时，但是最终都是调用checkForLongClick if (isInScrollingContainer) { mPrivateFlags |= PFLAG_PREPRESSED; if (mPendingCheckForTap == null) { mPendingCheckForTap = new CheckForTap(); } mPendingCheckForTap.x = event.getX(); mPendingCheckForTap.y = event.getY(); postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout()); } else { // Not inside a scrolling container, so show the feedback right away setPressed(true, x, y); // checkForLongClick也是一个Runnable，最终调用还是performLongClickInternal checkForLongClick(0, x, y); } break; // ACTION_CANCEL状态比较难触发，举个例子，在MIUI中开启“传送门”功能，就可以触发 case MotionEvent.ACTION_CANCEL: if (clickable) { setPressed(false); } removeTapCallback(); removeLongPressCallback(); mInContextButtonPress = false; mHasPerformedLongPress = false; mIgnoreNextUpEvent = false; mPrivateFlags3 \u0026amp;= ~PFLAG3_FINGER_DOWN; break; // ACTION_MOVE状态下removeTapCallback方法和removeLongPressCallback可以取消点击事件， // 这也就是为什么我们在按住某个按钮然后滑动出去就可以避免触发点击事件 case MotionEvent.ACTION_MOVE: if (clickable) { drawableHotspotChanged(x, y); } // Be lenient about moving outside of buttons if (!pointInView(x, y, mTouchSlop)) { // Outside button // Remove any future long press/tap checks removeTapCallback(); removeLongPressCallback(); if ((mPrivateFlags \u0026amp; PFLAG_PRESSED) != 0) { setPressed(false); } mPrivateFlags3 \u0026amp;= ~PFLAG3_FINGER_DOWN; } break; } return true; } return false; } 根据上述源码，我们知道了ContextMenu与长按事件冲突的原因，点击事件与长按事件是如何产生的，但是随之而来有了新的问题。\n为什么要使用Runnable来调用以及如果父容器有点击事件的同时子控件也有点击事件，那么事件传递的过程以及中间冲突是如何解决的？ // View.java 从源码中可以看到，这是一个专门用于UI线程的Handler，通过这个Handler发送的Runnable都会在UI线程中运行 /** * \u0026lt;p\u0026gt;Causes the Runnable to be added to the message queue. * The runnable will be run on the user interface thread.\u0026lt;/p\u0026gt; * * @param action The Runnable that will be executed. * * @return Returns true if the Runnable was successfully placed in to the * message queue. Returns false on failure, usually because the * looper processing the message queue is exiting. * * @see #postDelayed * @see #removeCallbacks */ public boolean post(Runnable action) { final AttachInfo attachInfo = mAttachInfo; if (attachInfo != null) { return attachInfo.mHandler.post(action); } // Postpone the runnable until we know on which thread it needs to run. // Assume that the runnable will be successfully placed after attach. getRunQueue().post(action); return true; } 结合上面的部分注释，说明一个原理，所有的点击事件以及屏幕绘制都要在UI线程中处理，这是为了方便点击触发时重绘UI\n// Use a Runnable and post this rather than calling // performClick directly. This lets other visual state // of the view update before click actions start. 从上面的源码部分我们知道了点击或者长按事件是通过onTouchEvent触发的，那么再看看onTouchEvent是在哪里调用的\n// View.java onTouchEvent是在dispatchTouchEvent方法中被调用，看注释就知道这个方法它是要将MotionEvent传递给target view /** * Pass the touch screen motion event down to the target view, or this * view if it is the target. * * @param event The motion event to be dispatched. * @return True if the event was handled by the view, false otherwise. */ public boolean dispatchTouchEvent(MotionEvent event) { // If the event should be handled by accessibility focus first. if (event.isTargetAccessibilityFocus()) { // We don\u0026#39;t have focus or no virtual descendant has it, do not handle the event. if (!isAccessibilityFocusedViewOrHost()) { return false; } // We have focus and got the event, then use normal event dispatch. event.setTargetAccessibilityFocus(false); } // result表示这个MotionEvent是否会被消耗 boolean result = false; if (mInputEventConsistencyVerifier != null) { mInputEventConsistencyVerifier.onTouchEvent(event, 0); } final int actionMasked = event.getActionMasked(); if (actionMasked == MotionEvent.ACTION_DOWN) { // Defensive cleanup for new gesture stopNestedScroll(); } if (onFilterTouchEventForSecurity(event)) { if ((mViewFlags \u0026amp; ENABLED_MASK) == ENABLED \u0026amp;\u0026amp; handleScrollBarDragging(event)) { result = true; } //noinspection SimplifiableIfStatement ListenerInfo li = mListenerInfo; // 如果调用了onTouch方法，那么当前result被置为true，则后面onTouchEvent不会执行，那么事件在onTouch中处理 if (li != null \u0026amp;\u0026amp; li.mOnTouchListener != null \u0026amp;\u0026amp; (mViewFlags \u0026amp; ENABLED_MASK) == ENABLED \u0026amp;\u0026amp; li.mOnTouchListener.onTouch(this, event)) { result = true; } // onTouchEvent调用的位置 if (!result \u0026amp;\u0026amp; onTouchEvent(event)) { result = true; } } if (!result \u0026amp;\u0026amp; mInputEventConsistencyVerifier != null) { mInputEventConsistencyVerifier.onUnhandledEvent(event, 0); } // Clean up after nested scrolls if this is the end of a gesture; // also cancel it if we tried an ACTION_DOWN but we didn\u0026#39;t want the rest // of the gesture. if (actionMasked == MotionEvent.ACTION_UP || actionMasked == MotionEvent.ACTION_CANCEL || (actionMasked == MotionEvent.ACTION_DOWN \u0026amp;\u0026amp; !result)) { stopNestedScroll(); } return result; } 再往上看，View的dispatchTouchEvent是在哪里调用的，可以往上追溯到ViewGroup的dispatchTransformedTouchEvent方法\n// ViewGroup.java ViewGroup继承自View，但是可以把它当做一个容器，比如LinearLayout就是继承自ViewGroup， // ViewGroup的dispatchTransformedTouchEvent将MotionEvent传给指定的子view，如果子view为空，那么这个ViewGroup // 自己就处理MotionEvent，而我们知道ViewGroup继承自View，所以可以调用super.dispatchTouchEvent(event) /** * Transforms a motion event into the coordinate space of a particular child view, * filters out irrelevant pointer ids, and overrides its action if necessary. * If child is null, assumes the MotionEvent will be sent to this ViewGroup instead. */ private boolean dispatchTransformedTouchEvent(MotionEvent event, boolean cancel, View child, int desiredPointerIdBits) { // handled标志事件是否被消耗 final boolean handled; // Canceling motions is a special case. We don\u0026#39;t need to perform any transformations // or filtering. The important part is the action, not the contents. final int oldAction = event.getAction(); // ACTION_CANCEL也要传递出去 if (cancel || oldAction == MotionEvent.ACTION_CANCEL) { event.setAction(MotionEvent.ACTION_CANCEL); // 通过判断传入的child值决定在子view中处理事件还是在当前ViewGroup中处理 if (child == null) { handled = super.dispatchTouchEvent(event); } else { handled = child.dispatchTouchEvent(event); } event.setAction(oldAction); return handled; } // Calculate the number of pointers to deliver. // 这里出现了一个新的概念pointers，这是由于许多设备支持多点触控，那么同一时间可以传递多个事件，我们把这些事件成为pointers final int oldPointerIdBits = event.getPointerIdBits(); final int newPointerIdBits = oldPointerIdBits \u0026amp; desiredPointerIdBits; // If for some reason we ended up in an inconsistent state where it looks like we // might produce a motion event with no pointers in it, then drop the event. if (newPointerIdBits == 0) { return false; } // If the number of pointers is the same and we don\u0026#39;t need to perform any fancy // irreversible transformations, then we can reuse the motion event for this // dispatch as long as we are careful to revert any changes we make. // Otherwise we need to make a copy. final MotionEvent transformedEvent; // 当事件传递过程中pointers数量保持不变时，我们可以以一个相对安全的方式将事件传递下去 if (newPointerIdBits == oldPointerIdBits) { if (child == null || child.hasIdentityMatrix()) { // 判断方式同上 if (child == null) { handled = super.dispatchTouchEvent(event); } else { // 同时可以将一些偏移量参数传入event中，这也是为什么ContextMenu可以获取到点击事件的位置的原因 final float offsetX = mScrollX - child.mLeft; final float offsetY = mScrollY - child.mTop; event.offsetLocation(offsetX, offsetY); handled = child.dispatchTouchEvent(event); event.offsetLocation(-offsetX, -offsetY); } return handled; } transformedEvent = MotionEvent.obtain(event); } else { // split方法主要是根据pointers数量变化决定event的类型，具体代码可以在MotionEvent.java中找到 transformedEvent = event.split(newPointerIdBits); } // Perform any necessary transformations and dispatch. // 同理需要将transformedEvent传出去 if (child == null) { handled = super.dispatchTouchEvent(transformedEvent); } else { final float offsetX = mScrollX - child.mLeft; final float offsetY = mScrollY - child.mTop; transformedEvent.offsetLocation(offsetX, offsetY); if (! child.hasIdentityMatrix()) { transformedEvent.transform(child.getInverseMatrix()); } handled = child.dispatchTouchEvent(transformedEvent); } // Done. transformedEvent.recycle(); return handled; } 再看一下dispatchTransformedTouchEvent被调用的位置\n// ViewGroup.java 这是ViewGroup的dispatchTouchEvent方法，很明显了，应该功能类似View的dispatchTouchEvent // 都是对MotionEvent进行传递，这里代码很长，仅仅保留最重要的部分 @Override public boolean dispatchTouchEvent(MotionEvent ev) { // ... boolean handled = false; if (onFilterTouchEventForSecurity(ev)) { final int action = ev.getAction(); final int actionMasked = action \u0026amp; MotionEvent.ACTION_MASK; // Handle an initial down. if (actionMasked == MotionEvent.ACTION_DOWN) { // Throw away all previous state when starting a new touch gesture. // The framework may have dropped the up or cancel event for the previous gesture // due to an app switch, ANR, or some other state change. cancelAndClearTouchTargets(ev); resetTouchState(); } // Check for interception. // 这里多了一个参数intercepted，很重要，用于截断事件的传递 final boolean intercepted; if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) { final boolean disallowIntercept = (mGroupFlags \u0026amp; FLAG_DISALLOW_INTERCEPT) != 0; if (!disallowIntercept) { // intercepted的值通过onInterceptTouchEvent方法得到，重写此方法可以截断事件的传递 intercepted = onInterceptTouchEvent(ev); ev.setAction(action); // restore action in case it was changed } else { intercepted = false; } } else { // There are no touch targets and this action is not an initial down // so this view group continues to intercept touches. intercepted = true; } // ... // 如果intercepted为true，则事件不会被传递下去，如果为false，则会将事件传递下去 if (!canceled \u0026amp;\u0026amp; !intercepted) { // If the event is targeting accessibility focus we give it to the // view that has accessibility focus and if it does not handle it // we clear the flag and dispatch the event to all children as usual. // We are looking up the accessibility focused host to avoid keeping // state since these events are very rare. // 循环遍历ViewGroup的所有子view，将事件传递下去 View childWithAccessibilityFocus = ev.isTargetAccessibilityFocus() ? findChildWithAccessibilityFocus() : null; if (actionMasked == MotionEvent.ACTION_DOWN || (split \u0026amp;\u0026amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN) || actionMasked == MotionEvent.ACTION_HOVER_MOVE) { final int actionIndex = ev.getActionIndex(); // always 0 for down final int idBitsToAssign = split ? 1 \u0026lt;\u0026lt; ev.getPointerId(actionIndex) : TouchTarget.ALL_POINTER_IDS; // Clean up earlier touch targets for this pointer id in case they // have become out of sync. removePointersFromTouchTargets(idBitsToAssign); final int childrenCount = mChildrenCount; if (newTouchTarget == null \u0026amp;\u0026amp; childrenCount != 0) { final float x = ev.getX(actionIndex); final float y = ev.getY(actionIndex); // Find a child that can receive the event. // Scan children from front to back. final ArrayList\u0026lt;View\u0026gt; preorderedList = buildTouchDispatchChildList(); final boolean customOrder = preorderedList == null \u0026amp;\u0026amp; isChildrenDrawingOrderEnabled(); final View[] children = mChildren; // 循环开始的位置 for (int i = childrenCount - 1; i \u0026gt;= 0; i--) { final int childIndex = getAndVerifyPreorderedIndex( childrenCount, i, customOrder); final View child = getAndVerifyPreorderedView( preorderedList, children, childIndex); // If there is a view that has accessibility focus we want it // to get the event first and if not handled we will perform a // normal dispatch. We may do a double iteration but this is // safer given the timeframe. if (childWithAccessibilityFocus != null) { if (childWithAccessibilityFocus != child) { continue; } childWithAccessibilityFocus = null; i = childrenCount - 1; } if (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x, y, child, null)) { ev.setTargetAccessibilityFocus(false); continue; } newTouchTarget = getTouchTarget(child); if (newTouchTarget != null) { // Child is already receiving touch within its bounds. // Give it the new pointer in addition to the ones it is handling. newTouchTarget.pointerIdBits |= idBitsToAssign; break; } resetCancelNextUpFlag(child); // 调用dispatchTransformedTouchEvent的位置 if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) { // Child wants to receive touch within its bounds. mLastTouchDownTime = ev.getDownTime(); if (preorderedList != null) { // childIndex points into presorted list, find original index for (int j = 0; j \u0026lt; childrenCount; j++) { if (children[childIndex] == mChildren[j]) { mLastTouchDownIndex = j; break; } } } else { mLastTouchDownIndex = childIndex; } mLastTouchDownX = ev.getX(); mLastTouchDownY = ev.getY(); newTouchTarget = addTouchTarget(child, idBitsToAssign); alreadyDispatchedToNewTouchTarget = true; break; } // The accessibility focus didn\u0026#39;t handle the event, so clear // the flag and do a normal dispatch to all children. ev.setTargetAccessibilityFocus(false); } if (preorderedList != null) preorderedList.clear(); } if (newTouchTarget == null \u0026amp;\u0026amp; mFirstTouchTarget != null) { // Did not find a child to receive the event. // Assign the pointer to the least recently added target. newTouchTarget = mFirstTouchTarget; while (newTouchTarget.next != null) { newTouchTarget = newTouchTarget.next; } newTouchTarget.pointerIdBits |= idBitsToAssign; } } } // 如果intercepted为true，则在这里调用dispatchTransformedTouchEvent // 调用dispatchTransformedTouchEvent即调用本身的onTouchEvent方法 // 只看核心代码就可以知道事件传递的规则 // Dispatch to touch targets. if (mFirstTouchTarget == null) { // No touch targets so treat this as an ordinary view. handled = dispatchTransformedTouchEvent(ev, canceled, null, TouchTarget.ALL_POINTER_IDS); } else { // Dispatch to touch targets, excluding the new touch target if we already // dispatched to it. Cancel touch targets if necessary. TouchTarget predecessor = null; TouchTarget target = mFirstTouchTarget; while (target != null) { final TouchTarget next = target.next; if (alreadyDispatchedToNewTouchTarget \u0026amp;\u0026amp; target == newTouchTarget) { handled = true; } else { final boolean cancelChild = resetCancelNextUpFlag(target.child) || intercepted; if (dispatchTransformedTouchEvent(ev, cancelChild, target.child, target.pointerIdBits)) { handled = true; } if (cancelChild) { if (predecessor == null) { mFirstTouchTarget = next; } else { predecessor.next = next; } target.recycle(); target = next; continue; } } predecessor = target; target = next; } } // Update list of touch targets for pointer up or cancel, if needed. if (canceled || actionMasked == MotionEvent.ACTION_UP || actionMasked == MotionEvent.ACTION_HOVER_MOVE) { resetTouchState(); } else if (split \u0026amp;\u0026amp; actionMasked == MotionEvent.ACTION_POINTER_UP) { final int actionIndex = ev.getActionIndex(); final int idBitsToRemove = 1 \u0026lt;\u0026lt; ev.getPointerId(actionIndex); removePointersFromTouchTargets(idBitsToRemove); } } if (!handled \u0026amp;\u0026amp; mInputEventConsistencyVerifier != null) { mInputEventConsistencyVerifier.onUnhandledEvent(ev, 1); } return handled; } 继续往上看，我们就能发现ViewGroup的dispatchTouchEvent方法由DecorView的superDispatchTouchEvent调用，而DecorView又是由PhoneWindow或者Window的superDispatchTouchEvent调用，PhoneWindow的superDispatchTouchEvent方法又是由activity的dispatchTouchEvent方法调用，具体代码如下\n// Activity.java /** * Called to process touch screen events. You can override this to * intercept all touch screen events before they are dispatched to the * window. Be sure to call this implementation for touch screen events * that should be handled normally. * * @param ev The touch screen event. * * @return boolean Return true if this event was consumed. */ public boolean dispatchTouchEvent(MotionEvent ev) { if (ev.getAction() == MotionEvent.ACTION_DOWN) { onUserInteraction(); } // 核心代码getWindow().superDispatchTouchEvent(ev) if (getWindow().superDispatchTouchEvent(ev)) { return true; } return onTouchEvent(ev); } // ----------------------------------------------------------------------- // Window.java /** * Used by custom windows, such as Dialog, to pass the touch screen event * further down the view hierarchy. Application developers should * not need to implement or call this. * */ // 抽象方法，具体由PhoneWindow实现 public abstract boolean superDispatchTouchEvent(MotionEvent event); // ----------------------------------------------------------------------- // DecorView.java // PhoneWindow的superDispatchTouchEvent方法交由DecorView实现，DecorView继承自ViewGroup，最终调用的还是ViewGroup的dispatchTouchEvent方法 public boolean superDispatchTouchEvent(MotionEvent event) { return super.dispatchTouchEvent(event); } 结合前半部分自底向上和后半部分自顶向下的分析，我们知道了dispatchTouchEvent传递事件的流程：\n从activity -\u0026gt; PhoneWindow/DecorView -\u0026gt; ViewGroup(如果布局中有的话) -\u0026gt; View\ndispatchTouchEvent是一种层层递归式的调用，只有在递归到View中被执行时才会返回，一般来说返回true代表事件被消耗了，而事件的处理在OnTouchEvent中； ViewGroup中有onInterceptTouchEvent方法可以中断事件的传递，重写此方法让它返回true，那么事件不会传递到子view中，onInterceptTouchEvent默认返回false； 在OnTouchEvent中返回true，则父容器不会执行OnTouchEvent方法，在OnTouchEvent中返回false，则父容器会执行OnTouchEvent方法，且后续的所有事件都会在父容器中处理，不再向下传递。 举两个例子说明如何通过onInterceptTouchEvent方法中断事件的传递\n第一个例子，一个LinearLayout中包含一个Button，LinearLayout和Button都设置onClick方法，很显然当我们点击Button时Button的onClick方法执行，当我们点击LinearLayout时LinearLayout的onClick方法执行；如果设置了log打印diapatchTouchEvent方法的执行顺序，那么可以发现：\n点击Button： activity dispatchTouchEvent -\u0026gt; linearlayout dispatchTouchEvent -\u0026gt; button dispatchTouchEvent\n点击LinearLayout： activity dispatchTouchEvent -\u0026gt; linearlayout dispatchTouchEvent\n如果我们希望LinearLayout拦截传给Button的事件，那么就需要用到onInterceptTouchEvent方法\n直接在自定义LinearLayout中重写onInterceptTouchEvent方法，让它返回true，则该LinearLayout下的所有子view都无法接收到事件\n@Override public boolean onInterceptTouchEvent(MotionEvent ev) { return true; } 第二个例子，禁止ViewPager左右滑动，首先需要明白一个问题，为什么ViewPager可以使页面左右滑动，如果ViewPager中的Fragment中也包含一个控件CustomTextView，那么滑动会产生冲突吗？\n首先看一下log日志，这是在自定义的CustomViewPager和CustomTextView中与TouchEvent相关的代码执行顺序\nCustomViewPager: dispatchTouchEvent - ACTION_DOWN CustomViewPager: onInterceptTouchEvent - ACTION_DOWN CustomTextView: dispatchTouchEvent - ACTION_DOWN CustomTextView: onTouchEvent - ACTION_DOWN CustomViewPager: onTouchEvent - ACTION_DOWN CustomViewPager: dispatchTouchEvent - ACTION_MOVE CustomViewPager: onTouchEvent - ACTION_MOVE CustomViewPager: dispatchTouchEvent - ACTION_UP CustomViewPager: onTouchEvent - ACTION_UP 下面是两个自定义的代码\npublic class CustomViewPager extends ViewPager { private static final String TAG = \u0026#34;aaaa-CustomViewPager\u0026#34;; private boolean enabled; public CustomViewPager(@NonNull Context context) { super(context); this.enabled = true; } public CustomViewPager(Context context, AttributeSet attrs) { super(context, attrs); this.enabled = true; } @Override public boolean dispatchTouchEvent(MotionEvent ev) { Log.i(TAG, \u0026#34;dispatchTouchEvent - \u0026#34; + \u0026#34; - \u0026#34; + ev.toString()); return super.dispatchTouchEvent(ev); } @Override public boolean onTouchEvent(MotionEvent event) { if (this.enabled) { Log.i(TAG, \u0026#34;onTouchEvent - \u0026#34; + \u0026#34; - \u0026#34; + event.toString()); return super.onTouchEvent(event); } return false; } // 根据后面的分析可知，对于ACTION_DOWN事件来说，super.onInterceptTouchEvent(event)默认返回false // 这段代码看似都是返回false，对结果没有影响，但是实际上将onInterceptTouchEvent的调用从ViewGroup转到ViewPager中 @Override public boolean onInterceptTouchEvent(MotionEvent event) { if (this.enabled) { Log.i(TAG, \u0026#34;onInterceptTouchEvent - \u0026#34; + \u0026#34; - \u0026#34; + event.toString()); return super.onInterceptTouchEvent(event); } return false; } public void setPagingEnabled(boolean enabled) { this.enabled = enabled; } } public class CustomTextView extends AppCompatTextView { private static final String TAG = \u0026#34;aaaa-CustomTextView\u0026#34;; public CustomTextView(Context context) { super(context); } public CustomTextView(Context context, AttributeSet attrs) { super(context, attrs); } public CustomTextView(Context context, AttributeSet attrs, int defStyleAttr) { super(context, attrs, defStyleAttr); } @Override public boolean dispatchTouchEvent(MotionEvent event) { Log.i(TAG, \u0026#34;dispatchTouchEvent - \u0026#34; + \u0026#34; - \u0026#34; + event.toString()); return super.dispatchTouchEvent(event); } @Override public boolean onTouchEvent(MotionEvent event) { Log.i(TAG, \u0026#34;onTouchEvent - \u0026#34; + \u0026#34; - \u0026#34; + event.toString()); return super.onTouchEvent(event); } } 对于ACTION_DOWN事件来说，事件传递流程为：\nCustomViewPager的dispatchTouchEvent（应该是来自于PhoneWindow/DecorView），调用super.dispatchTouchEvent(ev)，即ViewGroup的dispatchTouchEvent方法； 在上面ViewGroup的源码中我们知道，ViewGroup的dispatchTouchEvent方法中调用了onInterceptTouchEvent方法intercepted = onInterceptTouchEvent(ev);，由于我们在CustomViewPager中重写了onInterceptTouchEvent方法，所以会回到CustomViewPager的onInterceptTouchEvent方法； 默认情况下this.enabled为true，所以我们开始调用super.onInterceptTouchEvent(event)，此时super是ViewPager的onInterceptTouchEvent方法； 再看ViewPager的源码，对于ACTION_DOWN事件来说，onInterceptTouchEvent返回false，所以CustomViewPager的onInterceptTouchEvent方法直接返回false，又回到ViewGroup的dispatchTouchEvent方法中； 当intercepted = onInterceptTouchEvent(ev);中intercepted为false时，会执行子view的dispatchTouchEvent方法，子view即CustomTextView的dispatchTouchEvent方法； CustomTextView的dispatchTouchEvent方法默认调用super.dispatchTouchEvent(event)，即View的dispatchTouchEvent方法，而从View的源码中可知其调用onTouchEvent方法，而我们的CustomTextView重写了onTouchEvent方法，但是此方法又返回到TextView的onTouchEvent方法中，最终还是回到View的onTouchEvent方法，对于ACTION_DOWN事件来说，最终CustomTextView的onTouchEvent方法返回false，则CustomTextView的super以及CustomTextView的dispatchTouchEvent方法返回false，对应5中，如果子view的dispatchTouchEvent方法返回false，则第5步中ViewGroup会执行super.dispatchTouchEvent(event)，即ViewGroup的父类View的dispatchTouchEvent方法，此处的View不再是子view，而是作为CustomViewPager，因为CustomViewPager重写了onTouchEvent方法，所以View的dispatchTouchEvent方法中调用的onTouchEvent方法为CustomViewPager的onTouchEvent方法，而CustomViewPager的onTouchEvent方法调用super.onTouchEvent(event)，即ViewPager的onTouchEvent方法； ViewPager的onTouchEvent方法即最终实现滑动效果的地方，根据代码可知，只有在没有adapter或者滑动到最边缘的页面才会返回false，其他情况返回true； ViewPager的onTouchEvent方法返回true即处理了ACTION_DOWN事件，那么依次CustomViewPager的onTouchEvent方法返回true，CustomViewPager的dispatchTouchEvent方法返回true，至此ACTION_DOWN事件的处理结束了。 对于ACTION_MOVE和ACTION_UP事件来说（这两个事件分发流程基本相同），事件传递流程为：\nCustomViewPager的dispatchTouchEvent（应该是来自于PhoneWindow/DecorView），调用super.dispatchTouchEvent(ev)，即ViewGroup的dispatchTouchEvent方法； ViewGroup的dispatchTouchEvent方法中intercepted为true，拦截了ACTION_MOVE事件，由自身处理，即调用CustomViewPager的onTouchEvent方法； CustomViewPager的onTouchEvent方法调用super.onTouchEvent(event)，即ViewPager的onTouchEvent方法，在这里实现滑动的效果，根据代码可知，只有在没有adapter或者滑动到最边缘的页面才会返回false，其他情况返回true； 然后依次CustomViewPager的onTouchEvent返回true，CustomViewPager的dispatchTouchEvent方法返回true。 简而言之，事件分发就是一系列的dispatchTouchEvent、onInterceptTouchEvent和onTouchEvent方法的相互调用，首先需要明确地就是最终实现滑动效果、点击效果的都是各个控件的onTouchEvent方法，dispatchTouchEvent仅用作事件分发的开始，而onInterceptTouchEvent方法用于终止事件向子控件传递。\n以上面的代码为例可以得到一些结论：\nViewPager的onInterceptTouchEvent一般对ACTION_DOWN事件返回false，即不会对ACTION_DOWN进行拦截，那么ACTION_DOWN必定传到子view中； 如果ViewPager的子view无法在onTouchEvent中进行处理，比如这里的CustomTextView，对于ACTION_DOWN事件，CustomTextView的onTouchEvent返回false（为什么无法处理ACTION_DOWN，从源码中可知是由于CustomTextView的clickable为false，所以返回false），所以CustomTextView的dispatchTouchEvent方法返回false，相当于告诉父view不要再传给我ACTION_DOWN了，我没法处理； 如果ViewPager的子view的dispatchTouchEvent方法返回false，那么ViewPager就会调用自己的onTouchEvent来处理，ViewPager的onTouchEvent可以处理ACTION_DOWN事件，并记录了点击的位置，然后返回true，从而ViewPager的dispatchTouchEvent方法返回true，ACTION_DOWN事件结束； 紧接着ACTION_DOWN事件的必定是ACTION_MOVE或ACTION_UP，以ACTION_MOVE为例，同样是从ViewPager的dispatchTouchEvent方法开始，此时没有调用onInterceptTouchEvent方法，而是直接执行onTouchEvent方法，即根据ACTION_MOVE事件带的参数实现滑动效果，然后返回true； 紧接着ACTION_MOVE的必然是ACTION_UP，流程同4； 当ViewGroup的onTouchEvent方法可以处理ACTION_DOWN事件时，即onTouchEvent方法返回true，则此ViewGroup的onInterceptTouchEvent方法不再执行（对的，就算不执行也可以拦截事件），同时后续事件被拦截，经由此ViewGroup的onTouchEvent处理。 综上所述，如果ViewPager的子view无法处理ACTION_DOWN事件，那么ViewPager自己就会处理ACTION_DOWN事件，并在后续事件传递过程中拦截（不是通过onInterceptTouchEvent方法），后续的ACTION_MOVE或ACTION_UP由ViewPager进行处理，在ViewPager的onTouchEvent中实现了滑动的效果。\n如果我们在ViewPager中加上HorizontalScrollView，并加上几个CustomTextView，会产生怎样的效果呢\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:orientation=\u0026#34;vertical\u0026#34;\u0026gt; \u0026lt;us.zoom.videomeetings.viewpagerdemo.custom.CustomHorizontalScrollView android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34;\u0026gt; \u0026lt;us.zoom.videomeetings.viewpagerdemo.custom.CustomLinearLayout android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:orientation=\u0026#34;horizontal\u0026#34;\u0026gt; \u0026lt;us.zoom.videomeetings.viewpagerdemo.custom.CustomTextView android:id=\u0026#34;@+id/custom_tv\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_gravity=\u0026#34;center\u0026#34; android:layout_margin=\u0026#34;40dp\u0026#34; android:background=\u0026#34;@color/colorPrimary\u0026#34; android:padding=\u0026#34;40dp\u0026#34; android:text=\u0026#34;Fragment\u0026#34; android:textSize=\u0026#34;30sp\u0026#34; /\u0026gt; \u0026lt;us.zoom.videomeetings.viewpagerdemo.custom.CustomTextView android:id=\u0026#34;@+id/custom_tv2\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_gravity=\u0026#34;center\u0026#34; android:layout_margin=\u0026#34;40dp\u0026#34; android:background=\u0026#34;@color/colorPrimary\u0026#34; android:padding=\u0026#34;40dp\u0026#34; android:text=\u0026#34;Fragment\u0026#34; android:textSize=\u0026#34;30sp\u0026#34; /\u0026gt; \u0026lt;/us.zoom.videomeetings.viewpagerdemo.custom.CustomLinearLayout\u0026gt; \u0026lt;/us.zoom.videomeetings.viewpagerdemo.custom.CustomHorizontalScrollView\u0026gt; \u0026lt;/LinearLayout\u0026gt; CustomHorizontalScrollView和CustomLinearLayout都是直接继承，仅重写dispatchTouchEvent、onTouchEvent、onInterceptTouchEvent方法，加上log，这里就不加代码了，基本同上。\n在上述的演示效果中可以发现，如果滑动的位置是TextView，则ViewPager的左右滑动似乎被卡住了，但是偶尔可以切换，而且就算滑动到第二个TextView的边缘也不能切换fragment；如果滑动的位置是下方空白区域则ViewPager可以正常滑动。\n根据log以及上文的分析可知，ViewPager左右滑动被卡住的原因是：\nACTION_DOWN事件向下层层传递到CustomTextView，结果发现CustomTextView的onTouchEvent无法处理返回了false，然后向上层层传递直到CustomHorizontalScrollView发现自己可以处理ACTION_DOWN事件，于是其onTouchEvent返回了true，则CustomHorizontalScrollView的dispatchTouchEvent方法返回true，从而CustomViewPager的onTouchEvent无法执行； 紧接着ACTION_MOVE事件向下层层传递到CustomHorizontalScrollView，发现CustomHorizontalScrollView之前处理了ACTION_DOWN，那么后续所有事件都被CustomHorizontalScrollView拦截，通过其onTouchEvent处理，并返回true，则CustomHorizontalScrollView的dispatchTouchEvent方法返回true，从而CustomViewPager的onTouchEvent无法执行； ACTION_UP事件同2。 经过上面的分析知道了其实是CustomHorizontalScrollView能够处理所有事件，从而导致CustomViewPager无法执行onTouchEvent，因此ViewPager无法左右滑动。\n因此我们可以简单完成几个对滑动控制的需求\n4.1 禁用ViewPager的滑动，子view可以滑动 这个需求是为了解决上面提到的ViewPager偶尔可以滑动的问题，很显然这里可能是事件传递过程中触发了某种条件导致事件最终由ViewPager的onTouchEvent方法处理，我们要防止这种情况发生。解决的方法是CustomViewPager的onTouchEvent返回false（确保CustomViewPager不会处理滑动事件），同时可以在CustomViewPager的onInterceptTouchEvent返回false（可选，但是可以保证CustomViewPager不对事件进行拦截）。\n4.2 ViewPager仅在子view滑动到左右边界时可以滑动 直接看代码\npublic class CustomHorizontalScrollView extends HorizontalScrollView { private static final String TAG = CustomHorizontalScrollView.class.getSimpleName(); public CustomHorizontalScrollView(Context context) { super(context); } public CustomHorizontalScrollView(Context context, AttributeSet attrs) { super(context, attrs); } public CustomHorizontalScrollView(Context context, AttributeSet attrs, int defStyleAttr) { super(context, attrs, defStyleAttr); } public CustomHorizontalScrollView(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes) { super(context, attrs, defStyleAttr, defStyleRes); } /** * 可以在此处理冲突 * * @param ev * @return */ @Override public boolean dispatchTouchEvent(MotionEvent ev) { // 还没滑到右边，请求父控件不要拦截我的事件，事件自己处理 true ；已经滑到右边，则事件交由父控件处理 false。 // getParent().requestDisallowInterceptTouchEvent(!isScrollToRight()); return super.dispatchTouchEvent(ev); } /** * 也可以在此处理冲突 * * @param ev * @return */ @Override public boolean onTouchEvent(MotionEvent ev) { switch (ev.getAction()) { case MotionEvent.ACTION_DOWN: break; // 处理的逻辑是在ACTION_MOVE事件上，如果滑动到最左或最右边则调用 // getParent().requestDisallowInterceptTouchEvent(false) // 那么HorizontalScrollView的父view会拦截掉ACTION_MOVE事件， // 即ViewPager拦截ACTION_MOVE事件，由他的onTouchEvent处理 case MotionEvent.ACTION_MOVE: if (isScrollToLeft() || isScrollToRight()) { Log.e(TAG, \u0026#34;滑到\u0026#34; + (isScrollToLeft() ? \u0026#34;左边\u0026#34; : \u0026#34;右边\u0026#34;)); // 把事件交给父控件处理，例如：viewpager滑动 getParent().requestDisallowInterceptTouchEvent(false); } break; case MotionEvent.ACTION_UP: case MotionEvent.ACTION_CANCEL: // 请求父控件可以拦截事件 getParent().requestDisallowInterceptTouchEvent(false); break; default: } return super.onTouchEvent(ev); } @Override public boolean onInterceptTouchEvent(MotionEvent ev) { return super.onInterceptTouchEvent(ev); } /** * 是否已经滑到了最右边 * * @return */ private boolean isScrollToRight() { // getScrollX得到View的最左边的位置，若HorizontalScrollView滑到最右边，则为负值； // getScrollX() + getWidth()为最右边的位置 // getChildAt(getChildCount() - 1).getRight()恰好得到子view的最右边的位置 return getChildAt(getChildCount() - 1).getRight() == getScrollX() + getWidth(); } /** * 是否已经滑到了最左边 * * @return */ private boolean isScrollToLeft() { return getScrollX() == 0; } } 滑动冲突的解决方式有两种：\n1.外部拦截法：触摸事件都先经过父容器的拦截处理，如果父容器需要此事件就拦截，不需要就不拦截（此方法符合view事件分发机制），这样就可以解决滑动冲突问题。需要重写onInterceptTouchEvent方法，伪代码如下：\n@Override public boolean onInterceptTouchEvent(MotionEvent ev) { boolean intercept = false; switch (ev.getAction()) { case MotionEvent.ACTION_DOWN: // 不能拦截，否则无法传递事件给子元素 intercept = false; break; case MotionEvent.ACTION_MOVE: // 针对不同的滑动冲突，只需要修改这个条件即可，其它均不需做修改并且也不能修改 if (滑动事件交由父容器处理) { // 拦截事件 intercept = true; } else { // 不拦截事件 intercept = false; } break; case MotionEvent.ACTION_UP: case MotionEvent.ACTION_CANCEL: // 不拦截，否则子元素可能无法接收到这两个事件 intercept = false; break; default: } return intercept; } 2.内部拦截法：父容器不拦截任何事件，所有的事件都传递给子元素，如果子元素需要此事件就直接消耗掉，否则就交由父容器进行处理，这种方法和android中的事件分发机制不一致，需要配合requestDisallowInterceptTouchEvent方法才能正常工作，使用越来较外部拦截法稍显复杂。我们可以修改dispatchTouchEvent方法或者onTouchEvent方法来达到目的。伪代码如下：\n@Override public boolean dispatchTouchEvent(MotionEvent ev) { switch (ev.getAction()) { case MotionEvent.ACTION_DOWN: getParent().requestDisallowInterceptTouchEvent(true); break; case MotionEvent.ACTION_MOVE: // 针对不同的滑动冲突，只需要修改这个条件即可，其它均不需做修改并且也不能修改 if (父容器需要此类触摸事件) { getParent().requestDisallowInterceptTouchEvent(false); } break; case MotionEvent.ACTION_UP: case MotionEvent.ACTION_CANCEL: break; default: } return super.dispatchTouchEvent(ev); } 参考： 菜单 Menu api 图解 Android 事件分发机制 Android事件分发机制 详解攻略 Activity、View、Window的理解一篇文章就够了 ViewPager 与 HorizontalScrollView 滑动冲突问题 ","permalink":"https://zhoutao822.github.io/posts/menu/","summary":"Menu，不同于Button、TextView之类的控件，它不需要在布局文件中指定位置，它是用于提供给用户额外的操作选择，因此不必局限于某一个固定位置，它可以搭配任何控件。","title":"Material组件-Menu"},{"content":"分号 不要在行尾加分号, 也不要用分号将两条命令放在同一行.\n行长度 每行不超过80个字符\n例外:\n长的导入模块语句 注释里的URL 不要使用反斜杠连接行.\nPython会将 圆括号, 中括号和花括号中的行隐式的连接起来 , 你可以利用这个特点. 如果需要, 你可以在表达式外围增加一对额外的圆括号.\nYes: foo_bar(self, width, height, color=\u0026#39;black\u0026#39;, design=None, x=\u0026#39;foo\u0026#39;, emphasis=None, highlight=0) if (width == 0 and height == 0 and color == \u0026#39;red\u0026#39; and emphasis == \u0026#39;strong\u0026#39;): 如果一个文本字符串在一行放不下, 可以使用圆括号来实现隐式行连接:\nx = (\u0026#39;This will build a very long long \u0026#39; \u0026#39;long long long long long long string\u0026#39;) 在注释中，如果必要，将长的URL放在一行上。\nYes: # See details at # http://www.example.com/us/developer/documentation/api/content/v2.0/csv_file_name_extension_full_specification.html No: # See details at # http://www.example.com/us/developer/documentation/api/content/\\ # v2.0/csv_file_name_extension_full_specification.html 括号 Yes: if foo: bar() while x: x = bar() if x and y: bar() if not x: bar() return foo for (x, y) in dict.items(): ... No: if (x): bar() if not(x): bar() return (foo) 缩进 用4个空格来缩进代码\n绝对不要用tab, 也不要tab和空格混用. 对于行连接的情况, 你应该要么垂直对齐换行的元素, 或者使用4空格的悬挂式缩进(这时第一行不应该有参数):\nYes: # 与起始变量对齐 foo = long_function_name(var_one, var_two, var_three, var_four) # 字典中与起始值对齐 foo = { long_dictionary_key: value1 + value2, ... } # 4 个空格缩进，第一行不需要 foo = long_function_name( var_one, var_two, var_three, var_four) # 字典中 4 个空格缩进 foo = { long_dictionary_key: long_dictionary_value, ... } No: # 第一行有空格是禁止的 foo = long_function_name(var_one, var_two, var_three, var_four) # 2 个空格是禁止的 foo = long_function_name( var_one, var_two, var_three, var_four) # 字典中没有处理缩进 foo = { long_dictionary_key: long_dictionary_value, ... } 空行 顶级定义之间空两行, 方法定义之间空一行\n顶级定义之间空两行, 比如函数或者类定义. 方法定义, 类定义与第一个方法之间, 都应该空一行. 函数或方法中, 某些地方要是你觉得合适, 就空一行.\n空格 按照标准的排版规范来使用标点两边的空格\n括号内不要有空格.\n按照标准的排版规范来使用标点两边的空格\nYes: spam(ham[1], {eggs: 2}, []) No: spam( ham[ 1 ], { eggs: 2 }, [ ] ) 不要在逗号, 分号, 冒号前面加空格, 但应该在它们后面加(除了在行尾).\nYes: if x == 4: print x, y x, y = y, x No: if x == 4 : print x , y x , y = y , x 参数列表, 索引或切片的左括号前不应加空格.\nYes: spam(1) no: spam (1) Yes: dict[\u0026#39;key\u0026#39;] = list[index] No: dict [\u0026#39;key\u0026#39;] = list [index] 在二元操作符两边都加上一个空格, 比如赋值(=), 比较(==, \u0026lt;, \u0026gt;, !=, \u0026lt;\u0026gt;, \u0026lt;=, \u0026gt;=, in, not in, is, is not), 布尔(and, or, not). 至于算术操作符两边的空格该如何使用, 需要你自己好好判断. 不过两侧务必要保持一致.\nYes: x == 1 No: x\u0026lt;1 当=用于指示关键字参数或默认参数值时, 不要在其两侧使用空格.\nYes: def complex(real, imag=0.0): return magic(r=real, i=imag) No: def complex(real, imag = 0.0): return magic(r = real, i = imag) 不要用空格来垂直对齐多行间的标记, 因为这会成为维护的负担(适用于:, #, =等):\nYes: foo = 1000 # 注释 long_name = 2 # 注释不需要对齐 dictionary = { \u0026#34;foo\u0026#34;: 1, \u0026#34;long_name\u0026#34;: 2, } No: foo = 1000 # 注释 long_name = 2 # 注释不需要对齐 dictionary = { \u0026#34;foo\u0026#34; : 1, \u0026#34;long_name\u0026#34;: 2, } Hashbang 大部分.py文件不必以#!作为文件的开始. 根据 PEP-394 , 程序的main文件应该以 #!/usr/bin/python2或者 #!/usr/bin/python3开始.\n注释 确保对模块, 函数, 方法和行内注释使用正确的风格\n文档字符串\nPython有一种独一无二的的注释方式: 使用文档字符串. 文档字符串是包, 模块, 类或函数里的第一个语句. 这些字符串可以通过对象的__doc__成员被自动提取, 并且被pydoc所用. (你可以在你的模块上运行pydoc试一把, 看看它长什么样). 我们对文档字符串的惯例是使用三重双引号\u0026#34;\u0026#34;\u0026#34;( PEP-257 ). 一个文档字符串应该这样组织: 首先是一行以句号, 问号或惊叹号结尾的概述(或者该文档字符串单纯只有一行). 接着是一个空行. 接着是文档字符串剩下的部分, 它应该与文档字符串的第一行的第一个引号对齐. 下面有更多文档字符串的格式化规范. 模块\n每个文件应该包含一个许可样板. 根据项目使用的许可(例如, Apache 2.0, BSD, LGPL, GPL), 选择合适的样板. 函数和方法\n下文所指的函数,包括函数, 方法, 以及生成器. 一个函数必须要有文档字符串, 除非它满足以下条件: 1. 外部不可见 2. 非常短小 3. 简单明了 文档字符串应该包含函数做什么, 以及输入和输出的详细描述. 通常, 不应该描述\u0026#34;怎么做\u0026#34;, 除非是一些复杂的算法. 文档字符串应该提供足够的信息, 当别人编写代码调用该函数时, 他不需要看一行代码, 只要看文档字符串就可以了. 对于复杂的代码, 在代码旁边加注释会比使用文档字符串更有意义. 关于函数的几个方面应该在特定的小节中进行描述记录， 这几个方面如下文所述. 每节应该以一个标题行开始. 标题行以冒号结尾. 除标题行外, 节的其他内容应被缩进2个空格. Args: 列出每个参数的名字, 并在名字后使用一个冒号和一个空格, 分隔对该参数的描述.如果描述太长超过了单行80字符,使用2或者4个空格的悬挂缩进(与文件其他部分保持一致). 描述应该包括所需的类型和含义. 如果一个函数接受*foo(可变长度参数列表)或者**bar (任意关键字参数), 应该详细列出*foo和**bar. Returns: (或者 Yields: 用于生成器) 描述返回值的类型和语义. 如果函数返回None, 这一部分可以省略. Raises: 列出与接口有关的所有异常. def fetch_bigtable_rows(big_table, keys, other_silly_variable=None): \u0026#34;\u0026#34;\u0026#34;Fetches rows from a Bigtable. Retrieves rows pertaining to the given keys from the Table instance represented by big_table. Silly things may happen if other_silly_variable is not None. Args: big_table: An open Bigtable Table instance. keys: A sequence of strings representing the key of each table row to fetch. other_silly_variable: Another optional variable, that has a much longer name than the other args, and which does nothing. Returns: A dict mapping keys to the corresponding table row data fetched. Each row is represented as a tuple of strings. For example: {\u0026#39;Serak\u0026#39;: (\u0026#39;Rigel VII\u0026#39;, \u0026#39;Preparer\u0026#39;), \u0026#39;Zim\u0026#39;: (\u0026#39;Irk\u0026#39;, \u0026#39;Invader\u0026#39;), \u0026#39;Lrrr\u0026#39;: (\u0026#39;Omicron Persei 8\u0026#39;, \u0026#39;Emperor\u0026#39;)} If a key from the keys argument is missing from the dictionary, then that row was not found in the table. Raises: IOError: An error occurred accessing the bigtable.Table object. \u0026#34;\u0026#34;\u0026#34; pass 类\n类应该在其定义下有一个用于描述该类的文档字符串. 如果你的类有公共属性(Attributes), 那么文档中应该有一个属性(Attributes)段. 并且应该遵守和函数参数相同的格式. class SampleClass(object): \u0026#34;\u0026#34;\u0026#34;Summary of class here. Longer class information.... Longer class information.... Attributes: likes_spam: A boolean indicating if we like SPAM or not. eggs: An integer count of the eggs we have laid. \u0026#34;\u0026#34;\u0026#34; def __init__(self, likes_spam=False): \u0026#34;\u0026#34;\u0026#34;Inits SampleClass with blah.\u0026#34;\u0026#34;\u0026#34; self.likes_spam = likes_spam self.eggs = 0 def public_method(self): \u0026#34;\u0026#34;\u0026#34;Performs operation blah.\u0026#34;\u0026#34;\u0026#34; 块注释和行注释\n最需要写注释的是代码中那些技巧性的部分. 如果你在下次 代码审查 的时候必须解释一下, 那么你应该现在就给它写注释. 对于复杂的操作, 应该在其操作开始前写上若干行注释. 对于不是一目了然的代码, 应在其行尾添加注释. # We use a weighted dictionary search to find out where i is in # the array. We extrapolate position based on the largest num # in the array and the array size and then do binary search to # get the exact number. if i \u0026amp; (i-1) == 0: # true iff i is a power of 2 为了提高可读性, 注释应该至少离开代码2个空格. 另一方面, 绝不要描述代码. 假设阅读代码的人比你更懂Python, 他只是不知道你的代码要做什么. # BAD COMMENT: Now go through the b array and make sure whenever i occurs # the next element is i+1 类 如果一个类不继承自其它类, 就显式的从object继承. 嵌套类也一样.\nYes: class SampleClass(object): pass class OuterClass(object): class InnerClass(object): pass class ChildClass(ParentClass): \u0026#34;\u0026#34;\u0026#34;Explicitly inherits from another class already.\u0026#34;\u0026#34;\u0026#34; No: class SampleClass: pass class OuterClass: class InnerClass: pass 继承自 object 是为了使属性(properties)正常工作, 并且这样可以保护你的代码, 使其不受Python 3000的一个特殊的潜在不兼容性影响. 这样做也定义了一些特殊的方法, 这些方法实现了对象的默认语义, 包括 __new__, __init__, __delattr__, __getattribute__, __setattr__, __hash__, __repr__, and __str__ .\n字符串 Yes: x = a + b x = \u0026#39;%s, %s!\u0026#39; % (imperative, expletive) x = \u0026#39;{}, {}!\u0026#39;.format(imperative, expletive) x = \u0026#39;name: %s; score: %d\u0026#39; % (name, n) x = \u0026#39;name: {}; score: {}\u0026#39;.format(name, n) No: x = \u0026#39;%s%s\u0026#39; % (a, b) # use + in this case x = \u0026#39;{}{}\u0026#39;.format(a, b) # use + in this case x = imperative + \u0026#39;, \u0026#39; + expletive + \u0026#39;!\u0026#39; x = \u0026#39;name: \u0026#39; + name + \u0026#39;; score: \u0026#39; + str(n) 避免在循环中用+和+=操作符来累加字符串. 由于字符串是不可变的, 这样做会创建不必要的临时对象, 并且导致二次方而不是线性的运行时间. 作为替代方案, 你可以将每个子串加入列表, 然后在循环结束后用 .join 连接列表. (也可以将每个子串写入一个 cStringIO.StringIO 缓存中.)\nYes: items = [\u0026#39;\u0026lt;table\u0026gt;\u0026#39;] for last_name, first_name in employee_list: items.append(\u0026#39;\u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;%s, %s\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt;\u0026#39; % (last_name, first_name)) items.append(\u0026#39;\u0026lt;/table\u0026gt;\u0026#39;) employee_table = \u0026#39;\u0026#39;.join(items) No: employee_table = \u0026#39;\u0026lt;table\u0026gt;\u0026#39; for last_name, first_name in employee_list: employee_table += \u0026#39;\u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;%s, %s\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt;\u0026#39; % (last_name, first_name) employee_table += \u0026#39;\u0026lt;/table\u0026gt;\u0026#39; 在同一个文件中, 保持使用字符串引号的一致性. 使用单引号\u0026rsquo;或者双引号\u0026quot;之一用以引用字符串, 并在同一文件中沿用. 在字符串内可以使用另外一种引号, 以避免在字符串中使用. PyLint已经加入了这一检查.\nYes: Python(\u0026#39;Why are you hiding your eyes?\u0026#39;) Gollum(\u0026#34;I\u0026#39;m scared of lint errors.\u0026#34;) Narrator(\u0026#39;\u0026#34;Good!\u0026#34; thought a happy Python reviewer.\u0026#39;) No: Python(\u0026#34;Why are you hiding your eyes?\u0026#34;) Gollum(\u0026#39;The lint. It burns. It burns us.\u0026#39;) Gollum(\u0026#34;Always the great lint. Watching. Watching.\u0026#34;) 为多行字符串使用三重双引号\u0026quot;\u0026ldquo;\u0026ldquo;而非三重单引号\u0026rsquo;\u0026rsquo;\u0026rsquo;. 当且仅当项目中使用单引号\u0026rsquo;来引用字符串时, 才可能会使用三重\u0026rsquo;\u0026lsquo;\u0026lsquo;为非文档字符串的多行字符串来标识引用. 文档字符串必须使用三重双引号\u0026rdquo;\u0026rdquo;\u0026quot;. 不过要注意, 通常用隐式行连接更清晰, 因为多行字符串与程序其他部分的缩进方式不一致.\nYes: print (\u0026#34;This is much nicer.\\n\u0026#34; \u0026#34;Do it this way.\\n\u0026#34;) No: print \u0026#34;\u0026#34;\u0026#34;This is pretty ugly. Don\u0026#39;t do this. \u0026#34;\u0026#34;\u0026#34; 文件和sockets 在文件和sockets结束时, 显式的关闭它.\n除文件外, sockets或其他类似文件的对象在没有必要的情况下打开, 会有许多副作用, 例如:\n它们可能会消耗有限的系统资源, 如文件描述符. 如果这些资源在使用后没有及时归还系统, 那么用于处理这些对象的代码会将资源消耗殆尽. 持有文件将会阻止对于文件的其他诸如移动、删除之类的操作. 仅仅是从逻辑上关闭文件和sockets, 那么它们仍然可能会被其共享的程序在无意中进行读或者写操作. 只有当它们真正被关闭后, 对于它们尝试进行读或者写操作将会跑出异常, 并使得问题快速显现出来. 而且, 幻想当文件对象析构时, 文件和sockets会自动关闭, 试图将文件对象的生命周期和文件的状态绑定在一起的想法, 都是不现实的. 因为有如下原因:\n没有任何方法可以确保运行环境会真正的执行文件的析构. 不同的Python实现采用不同的内存管理技术, 比如延时垃圾处理机制. 延时垃圾处理机制可能会导致对象生命周期被任意无限制的延长. 对于文件意外的引用,会导致对于文件的持有时间超出预期(比如对于异常的跟踪, 包含有全局变量等). 推荐使用 with语句 以管理文件:\nwith open(\u0026#34;hello.txt\u0026#34;) as hello_file: for line in hello_file: print line 对于不支持使用with语句的类似文件的对象,使用 contextlib.closing():\nimport contextlib with contextlib.closing(urllib.urlopen(\u0026#34;http://www.python.org/\u0026#34;)) as front_page: for line in front_page: print line TODO注释 为临时代码使用TODO注释, 它是一种短期解决方案. 不算完美, 但够好了.\nTODO注释应该在所有开头处包含\u0026quot;TODO\u0026quot;字符串, 紧跟着是用括号括起来的你的名字, email地址或其它标识符. 然后是一个可选的冒号. 接着必须有一行注释, 解释要做什么. 主要目的是为了有一个统一的TODO格式, 这样添加注释的人就可以搜索到(并可以按需提供更多细节). 写了TODO注释并不保证写的人会亲自解决问题. 当你写了一个TODO, 请注上你的名字.\n# TODO(kl@gmail.com): Use a \u0026#34;*\u0026#34; here for string repetition. # TODO(Zeke) Change this to use relations. 如果你的TODO是\u0026quot;将来做某事\u0026quot;的形式, 那么请确保你包含了一个指定的日期(\u0026ldquo;2009年11月解决\u0026rdquo;)或者一个特定的事件(\u0026ldquo;等到所有的客户都可以处理XML请求就移除这些代码\u0026rdquo;).\n导入格式 每个导入应该独占一行\nYes: import os import sys No: import os, sys 导入总应该放在文件顶部, 位于模块注释和文档字符串之后, 模块全局变量和常量之前. 导入应该按照从最通用到最不通用的顺序分组:\n标准库导入 第三方库导入 应用程序指定导入 每种分组中, 应该根据每个模块的完整包路径按字典序排序, 忽略大小写.\nimport foo from foo import bar from foo.bar import baz from foo.bar import Quux from Foob import ar 语句 通常每个语句应该独占一行\n不过, 如果测试结果与测试语句在一行放得下, 你也可以将它们放在同一行. 如果是if语句, 只有在没有else时才能这样做. 特别地, 绝不要对 try/except 这样做, 因为try和except不能放在同一行.\nYes: if foo: bar(foo) No: if foo: bar(foo) else: baz(foo) try: bar(foo) except ValueError: baz(foo) try: bar(foo) except ValueError: baz(foo) 访问控制 在Python中, 对于琐碎又不太重要的访问函数, 你应该直接使用公有变量来取代它们, 这样可以避免额外的函数调用开销. 当添加更多功能时, 你可以用属性(property)来保持语法的一致性.\n(译者注: 重视封装的面向对象程序员看到这个可能会很反感, 因为他们一直被教育: 所有成员变量都必须是私有的! 其实, 那真的是有点麻烦啊. 试着去接受Pythonic哲学吧)\n另一方面, 如果访问更复杂, 或者变量的访问开销很显著, 那么你应该使用像 get_foo() 和 set_foo() 这样的函数调用. 如果之前的代码行为允许通过属性(property)访问 , 那么就不要将新的访问函数与属性绑定. 这样, 任何试图通过老方法访问变量的代码就没法运行, 使用者也就会意识到复杂性发生了变化.\n命名 应该避免的名称\n单字符名称, 除了计数器和迭代器. 包/模块名中的连字符(-) 双下划线开头并结尾的名称(Python保留, 例如__init__) 命名约定\n所谓\u0026quot;内部(Internal)\u0026ldquo;表示仅模块内可用, 或者, 在类内是保护或私有的. 用单下划线(_)开头表示模块变量或函数是protected的(使用import * from时不会包含). 用双下划线(__)开头的实例变量或方法表示类内私有. 将相关的类和顶级函数放在同一个模块里. 不像Java, 没必要限制一个类一个模块. 对类名使用大写字母开头的单词(如CapWords, 即Pascal风格), 但是模块名应该用小写加下划线的方式(如lower_with_under.py). 尽管已经有很多现存的模块使用类似于CapWords.py这样的命名, 但现在已经不鼓励这样做, 因为如果模块名碰巧和类名一致, 这会让人困扰. Main 即使是一个打算被用作脚本的文件, 也应该是可导入的. 并且简单的导入不应该导致这个脚本的主功能(main functionality)被执行, 这是一种副作用. 主功能应该放在一个main()函数中.\n在Python中, pydoc以及单元测试要求模块必须是可导入的. 你的代码应该在执行主程序前总是检查 if __name__ == '__main__' , 这样当模块被导入时主程序就不会被执行.\ndef main(): ... if __name__ == \u0026#39;__main__\u0026#39;: main() 所有的顶级代码在模块导入时都会被执行. 要小心不要去调用函数, 创建对象, 或者执行那些不应该在使用pydoc时执行的操作.\n参考： Google Python风格规范 ","permalink":"https://zhoutao822.github.io/posts/python_style_rules/","summary":"Python风格规范总结","title":"Python风格规范"},{"content":"1. Pylint pylint是一个可以查找py文件中部分错误以及不规范的语法，虽然pylint还不够完美但是我们可以借助它修正不规范的地方。\n使用方式\npylint xxx.py 输出类似于\n************* Module wine wine.py:20:0: C0304: Final newline missing (missing-final-newline) wine.py:1:0: C0111: Missing module docstring (missing-docstring) wine.py:3:0: E0401: Unable to import \u0026#39;numpy\u0026#39; (import-error) wine.py:4:0: E0401: Unable to import \u0026#39;sklearn.datasets\u0026#39; (import-error) wine.py:5:0: E0401: Unable to import \u0026#39;sklearn.mixture\u0026#39; (import-error) wine.py:6:0: C0103: Constant name \u0026#34;rawData\u0026#34; doesn\u0026#39;t conform to UPPER_CASE naming style (invalid-name) wine.py:8:0: C0103: Constant name \u0026#34;data\u0026#34; doesn\u0026#39;t conform to UPPER_CASE naming style (invalid-name) wine.py:9:0: C0103: Constant name \u0026#34;target\u0026#34; doesn\u0026#39;t conform to UPPER_CASE naming style (invalid-name) wine.py:11:0: C0103: Constant name \u0026#34;gmm\u0026#34; doesn\u0026#39;t conform to UPPER_CASE naming style (invalid-name) wine.py:15:0: C0103: Constant name \u0026#34;prediction\u0026#34; doesn\u0026#39;t conform to UPPER_CASE naming style (invalid-name) wine.py:19:0: C0103: Constant name \u0026#34;acc\u0026#34; doesn\u0026#39;t conform to UPPER_CASE naming style (invalid-name) --------------------------------------------------------------------- Your code has been rated at -9.17/10 (previous run: 10.00/10, -19.17) 也可以通过行注释来抑制警告\ndict = \u0026#39;something awful\u0026#39; # Bad Idea... pylint: disable=redefined-builtin 要抑制”参数未使用”告警, 你可以用””作为参数标识符, 或者在参数名前加”unused”. 遇到不能改变参数名的情况, 你可以通过在函数开头”提到”它们来消除告警. 例如:\ndef foo(a, unused_b, unused_c, d=None, e=None): _ = d, e return a 2. 导入 使用 import x 来导入包和模块.\n使用 from x import y, 其中x是包前缀, y是不带前缀的模块名.\n使用 from x import y as z, 如果两个要导入的模块都叫做y或者y太长了.\n例如, 模块 sound.effects.echo 可以用如下方式导入:\nfrom sound.effects import echo ... echo.EchoFilter(input, output, delay=0.7, atten=4) 导入时不要使用相对名称. 即使模块在同一个包中, 也要使用完整包名. 这能帮助你避免无意间导入一个包两次.\n3. 包 所有的新代码都应该用完整包名来导入每个模块.\n应该像下面这样导入:\n# Reference in code with complete name. import sound.effects.echo # Reference in code with just module name (preferred). from sound.effects import echo 4. 异常 异常必须遵守特定条件:\n像这样触发异常: raise MyException(\u0026quot;Error message\u0026quot;) 或者 raise MyException . 不要使用两个参数的形式( raise MyException, \u0026quot;Error message\u0026quot; )或者过时的字符串异常( raise \u0026quot;Error message\u0026quot; ). 模块或包应该定义自己的特定域的异常基类, 这个基类应该从内建的Exception类继承. 模块的异常基类应该叫做”Error”. class Error(Exception): pass 永远不要使用 except: 语句来捕获所有异常, 也不要捕获 Exception 或者 StandardError , 除非你打算重新触发该异常, 或者你已经在当前线程的最外层(记得还是要打印一条错误消息). 在异常这方面, Python非常宽容, except: 真的会捕获包括Python语法错误在内的任何错误. 使用 except: 很容易隐藏真正的bug. 尽量减少try/except块中的代码量. try块的体积越大, 期望之外的异常就越容易被触发. 这种情况下, try/except块将隐藏真正的错误. 使用finally子句来执行那些无论try块中有没有异常都应该被执行的代码. 这对于清理资源常常很有用, 例如关闭文件. 当捕获异常时, 使用 as 而不要用逗号. 例如 try: raise Error except Error as error: pass 5. 全局变量 避免使用全局变量, 用类变量来代替. 但也有一些例外:\n脚本的默认选项. 模块级常量. 例如:　PI = 3.14159. 常量应该全大写, 用下划线连接. 有时候用全局变量来缓存值或者作为函数返回值很有用. 如果需要, 全局变量应该仅在模块内部可用, 并通过模块级的公共函数来访问. 6. 嵌套/局部/内部类或函数 鼓励使用嵌套/本地/内部类或函数\n类可以定义在方法, 函数或者类中. 函数可以定义在方法或函数中. 封闭区间中定义的变量对嵌套函数是只读的.\n嵌套类或局部类的实例不能序列化(pickled).\n6. 列表推导 适用于简单情况. 每个部分应该单独置于一行: 映射表达式, for语句, 过滤器表达式. 禁止多重for语句或过滤器表达式. 复杂情况下还是使用循环.\nYes: result = [] for x in range(10): for y in range(5): if x * y \u0026gt; 10: result.append((x, y)) for x in xrange(5): for y in xrange(5): if x != y: for z in xrange(5): if y != z: yield (x, y, z) return ((x, complicated_transform(x)) for x in long_generator_function(parameter) if x is not None) squares = [x * x for x in range(10)] eat(jelly_bean for jelly_bean in jelly_beans if jelly_bean.color == \u0026#39;black\u0026#39;) No: result = [(x, y) for x in range(10) for y in range(5) if x * y \u0026gt; 10] return ((x, y, z) for x in xrange(5) for y in xrange(5) if x != y for z in xrange(5) if y != z) 7. 默认迭代器和操作符 如果类型支持, 就使用默认迭代器和操作符, 例如列表, 字典和文件. 内建类型也定义了迭代器方法. 优先考虑这些方法, 而不是那些返回列表的方法. 当然，这样遍历容器时，你将不能修改容器.\nYes: for key in adict: ... if key not in adict: ... if obj in alist: ... for line in afile: ... for k, v in dict.iteritems(): ... No: for key in adict.keys(): ... if not adict.has_key(key): ... for line in afile.readlines(): ... 8. 生成器 所谓生成器函数, 就是每当它执行一次生成(yield)语句, 它就返回一个迭代器, 这个迭代器生成一个值. 生成值后, 生成器函数的运行状态将被挂起, 直到下一次生成.\n鼓励使用. 注意在生成器函数的文档字符串中使用”Yields:”而不是”Returns:”.\n9. Lambda函数 适用于单行函数. 如果代码超过60-80个字符, 最好还是定义成常规(嵌套)函数.\n对于常见的操作符，例如乘法操作符，使用 operator 模块中的函数以代替lambda函数. 例如, 推荐使用 operator.mul , 而不是 lambda x, y: x * y .\n10. 条件表达式 适用于单行函数. 在其他情况下，推荐使用完整的if语句.\n11. 默认参数值 鼓励使用, 不过有如下注意事项:\n不要在函数或方法定义中使用可变对象作为默认值.\nYes: def foo(a, b=None): if b is None: b = [] No: def foo(a, b=[]): ... No: def foo(a, b=time.time()): # The time the module was loaded??? ... No: def foo(a, b=FLAGS.my_thing): # sys.argv has not yet been parsed... ... 12. 属性 你通常习惯于使用访问或设置方法来访问或设置数据, 它们简单而轻量. 不过我们建议你在新的代码中使用属性. 只读属性应该用 @property 装饰器 来创建.\n如果子类没有覆盖属性, 那么属性的继承可能看上去不明显. 因此使用者必须确保访问方法间接被调用, 以保证子类中的重载方法被属性调用(使用模板方法设计模式).\nYes: import math class Square(object): \u0026#34;\u0026#34;\u0026#34;A square with two properties: a writable area and a read-only perimeter. To use: \u0026gt;\u0026gt;\u0026gt; sq = Square(3) \u0026gt;\u0026gt;\u0026gt; sq.area 9 \u0026gt;\u0026gt;\u0026gt; sq.perimeter 12 \u0026gt;\u0026gt;\u0026gt; sq.area = 16 \u0026gt;\u0026gt;\u0026gt; sq.side 4 \u0026gt;\u0026gt;\u0026gt; sq.perimeter 16 \u0026#34;\u0026#34;\u0026#34; def __init__(self, side): self.side = side def __get_area(self): \u0026#34;\u0026#34;\u0026#34;Calculates the \u0026#39;area\u0026#39; property.\u0026#34;\u0026#34;\u0026#34; return self.side ** 2 def ___get_area(self): \u0026#34;\u0026#34;\u0026#34;Indirect accessor for \u0026#39;area\u0026#39; property.\u0026#34;\u0026#34;\u0026#34; return self.__get_area() def __set_area(self, area): \u0026#34;\u0026#34;\u0026#34;Sets the \u0026#39;area\u0026#39; property.\u0026#34;\u0026#34;\u0026#34; self.side = math.sqrt(area) def ___set_area(self, area): \u0026#34;\u0026#34;\u0026#34;Indirect setter for \u0026#39;area\u0026#39; property.\u0026#34;\u0026#34;\u0026#34; self._SetArea(area) area = property(___get_area, ___set_area, doc=\u0026#34;\u0026#34;\u0026#34;Gets or sets the area of the square.\u0026#34;\u0026#34;\u0026#34;) @property def perimeter(self): return self.side * 4 13. True/False的求值 尽可能使用隐式的false, 例如: 使用 if foo: 而不是 if foo != []: . 不过还是有一些注意事项需要你铭记在心:\n永远不要用==或者!=来比较单件, 比如None. 使用is或者is not.\n注意: 当你写下 if x: 时, 你其实表示的是 if x is not None . 例如: 当你要测试一个默认值是None的变量或参数是否被设为其它值. 这个值在布尔语义下可能是false!\n永远不要用==将一个布尔量与false相比较. 使用 if not x: 代替. 如果你需要区分false和None, 你应该用像 if not x and x is not None: 这样的语句.\n对于序列(字符串, 列表, 元组), 要注意空序列是false. 因此 if not seq: 或者 if seq: 比 if len(seq): 或 if not len(seq): 要更好.\n处理整数时, 使用隐式false可能会得不偿失(即不小心将None当做0来处理). 你可以将一个已知是整型(且不是len()的返回结果)的值与0比较.\nYes: if not users: print \u0026#39;no users\u0026#39; if foo == 0: self.handle_zero() if i % 10 == 0: self.handle_multiple_of_ten() No: if len(users) == 0: print \u0026#39;no users\u0026#39; if foo is not None and not foo: self.handle_zero() if not i % 10: self.handle_multiple_of_ten() 注意‘0’(字符串)会被当做true. 14. 词法作用域 嵌套的Python函数可以引用外层函数中定义的变量, 但是不能够对它们赋值. 变量绑定的解析是使用词法作用域, 也就是基于静态的程序文本. 对一个块中的某个名称的任何赋值都会导致Python将对该名称的全部引用当做局部变量, 甚至是赋值前的处理. 如果碰到global声明, 该名称就会被视作全局变量.\n一个使用这个特性的例子:\ndef get_adder(summand1): \u0026#34;\u0026#34;\u0026#34;Returns a function that adds numbers to a given number.\u0026#34;\u0026#34;\u0026#34; def adder(summand2): return summand1 + summand2 return adder (译者注: 这个例子有点诡异, 你应该这样使用这个函数: sum = get_adder(summand1)(summand2) )\n15. 函数与方法装饰器 用于函数及方法的装饰器 (也就是@标记). 最常见的装饰器是@classmethod 和@staticmethod, 用于将常规函数转换成类方法或静态方法. 不过, 装饰器语法也允许用户自定义装饰器. 特别地, 对于某个函数 my_decorator , 下面的两段代码是等效的:\nclass C(object): @my_decorator def method(self): # method body ... class C(object): def method(self): # method body ... method = my_decorator(method) 16. 线程 虽然Python的内建类型例如字典看上去拥有原子操作, 但是在某些情形下它们仍然不是原子的(即: 如果__hash__或__eq__被实现为Python方法)且它们的原子性是靠不住的. 你也不能指望原子变量赋值(因为这个反过来依赖字典).\n优先使用Queue模块的 Queue 数据类型作为线程间的数据通信方式. 另外, 使用threading模块及其锁原语(locking primitives). 了解条件变量的合适使用方式, 这样你就可以使用 threading.Condition 来取代低级别的锁了.\n参考： Google Python语言规范 ","permalink":"https://zhoutao822.github.io/posts/python_language_rules/","summary":"pylint是一个可以查找py文件中部分错误以及不规范的语法，虽然pylint还不够完美但是我们可以借助它修正不规范的地方。","title":"Python语言规范"},{"content":"BottomSheetDialog，顾名思义就是从界面底部往上出现的Dialog，它是Material Design的控件之一，目前在Material Components库中。\n1. 准备工作 Google推出的Material Components库包括了很多常用的控件，我们只需要直接用这些控件就可以实现很多复杂的功能或界面，但是在使用之前还需要一些准备工作，大致在Getting started with Material Components for Android也给出了，我这里简要描述一下：\n首先使是依赖（建议更新项目到androidx再继续），需要在build.gradle中加入Google\u0026rsquo;s Maven Repository google()，然后加入库； allprojects { repositories { google() jcenter() } } dependencies { // ... // 目前最新版为1.1.0-alpha07，有部分控件还是存在Bug implementation \u0026#39;com.google.android.material:material:1.1.0-alpha07\u0026#39; // ... } 其次是compileSdkVersion需要在28或以上才能使用Material控件； 然后需要使用或继承AppCompatActivity，AppCompatActivity是专门为Material控件设计的Activity，如果不能继承则需要使用AppCompatDelegate； 最后是需要修改AppTheme，在AndroidManifest.xml里面修改主题，需要继承自Material Components themes，具体有哪些可以看上面给的地址，如果暂时不允许修改AppTheme，可以使用Material Components Bridge themes，这里的区别在于使用Material Components themes可能会导致你原来的应用中某些布局颜色UI发生改变，这时候需要重新修改一些资源文件；如果使用Bridge themes则不会修改原来应用的布局颜色UI等，却可以使用Material组件。 \u0026lt;style name=\u0026#34;AppTheme\u0026#34; parent=\u0026#34;Theme.MaterialComponents.NoActionBar.Bridge\u0026#34;\u0026gt; \u0026lt;!-- Customize your theme here. --\u0026gt; \u0026lt;item name=\u0026#34;colorPrimary\u0026#34;\u0026gt;@color/colorPrimary\u0026lt;/item\u0026gt; \u0026lt;item name=\u0026#34;colorPrimaryDark\u0026#34;\u0026gt;@color/colorPrimaryDark\u0026lt;/item\u0026gt; \u0026lt;item name=\u0026#34;colorAccent\u0026#34;\u0026gt;@color/colorAccent\u0026lt;/item\u0026gt; \u0026lt;/style\u0026gt; 到这里，准备工作基本完成，可以进行下一步使用Material组件了。\n2. BottomSheetDialog使用 根据官网说明，BottomSheetDialog有两种使用方式（这里很多博客没有说明就直接给代码了），一种是Persistent，另一种是Modal，简而言之就是前者是固定的BottomSheetDialog，后者是动态调用的。\n2.1 Persistent BottomSheetDialog 设想一个使用场景，某个界面必定包含BottomSheetDialog，需要靠它实现其他功能的选择，举个例子，知乎的评论就是依靠BottomSheetDialog来实现的（一个东西看起来像鸭子，吃起来也像鸭子，那么它就是鸭子），而且有很明显的特征：在回答界面必定存在这个评论功能，那么我们可以将它视为Persistent固定场景，此时实现BottomSheetDialog的方式是使用BottomSheetBehavior，而不是new BottomSheetDialog()，实例代码如下：\n首先是activity的布局文件activity_second.xml \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;!-- 注意要使用BottomSheetBehavior，则必须使用CoordinatorLayout作为父布局，而且需要xmlns:app --\u0026gt; \u0026lt;androidx.coordinatorlayout.widget.CoordinatorLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; xmlns:app=\u0026#34;http://schemas.android.com/apk/res-auto\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34;\u0026gt; \u0026lt;LinearLayout android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:orientation=\u0026#34;vertical\u0026#34;\u0026gt; \u0026lt;Button android:id=\u0026#34;@+id/btn_show\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_gravity=\u0026#34;center\u0026#34; android:text=\u0026#34;Show\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; \u0026lt;!-- BottomSheetBehavior需要一个寄主，可以是LinearLayout也可以是其他，这个layout就是弹出的dialog布局， 同时需要几个属性： app:behavior_hideable=\u0026#34;true\u0026#34;否则BottomSheetDialog不会收起来 app:behavior_peekHeight=\u0026#34;300dp\u0026#34;设置BottomSheetDialog在STATE_COLLAPSED状态的高度，也可以不设置，这个会产生一种弹性收缩的效果，具体自行尝试 app:elevation=\u0026#34;6dp\u0026#34;设置z轴高度，可以产生一种悬浮效果，可以不设置 app:layout_behavior=\u0026#34;com.google.android.material.bottomsheet.BottomSheetBehavior\u0026#34;最重要的属性，简而言之就是让LinearLayout 的行为变成BottomSheetDialog的行为，这样我们就不需要实例化一个BottomSheetDialog，取而代之的是通过BottomSheetBehavior来实现， 需要注意的地方是，app:layout_behavior只能在CoordinatorLayout下直接子控件中使用，像这里的CoordinatorLayout-\u0026gt;LinearLayout就可以 --\u0026gt; \u0026lt;LinearLayout android:id=\u0026#34;@+id/bottom_sheet\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:background=\u0026#34;@color/white\u0026#34; android:orientation=\u0026#34;vertical\u0026#34; app:behavior_hideable=\u0026#34;true\u0026#34; app:behavior_peekHeight=\u0026#34;300dp\u0026#34; app:elevation=\u0026#34;6dp\u0026#34; app:layout_behavior=\u0026#34;com.google.android.material.bottomsheet.BottomSheetBehavior\u0026#34;\u0026gt; \u0026lt;!-- 这里随便加了几个子项，在BottomSheetBehavior布局下的子控件都是BottomSheetDialog一部分 --\u0026gt; \u0026lt;LinearLayout android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:orientation=\u0026#34;horizontal\u0026#34;\u0026gt; \u0026lt;ImageView style=\u0026#34;@style/MenuIcon\u0026#34; android:src=\u0026#34;@drawable/ic_share_black_24dp\u0026#34; /\u0026gt; \u0026lt;TextView style=\u0026#34;@style/MenuText\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;Share\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; \u0026lt;LinearLayout android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:orientation=\u0026#34;horizontal\u0026#34;\u0026gt; \u0026lt;ImageView style=\u0026#34;@style/MenuIcon\u0026#34; android:src=\u0026#34;@drawable/ic_cloud_upload_black_24dp\u0026#34; /\u0026gt; \u0026lt;TextView style=\u0026#34;@style/MenuText\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;Upload\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; \u0026lt;LinearLayout android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:orientation=\u0026#34;horizontal\u0026#34;\u0026gt; \u0026lt;ImageView style=\u0026#34;@style/MenuIcon\u0026#34; android:src=\u0026#34;@drawable/ic_content_copy_black_24dp\u0026#34; /\u0026gt; \u0026lt;TextView style=\u0026#34;@style/MenuText\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;Copy\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; \u0026lt;LinearLayout android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:orientation=\u0026#34;horizontal\u0026#34;\u0026gt; \u0026lt;ImageView style=\u0026#34;@style/MenuIcon\u0026#34; android:src=\u0026#34;@drawable/ic_print_black_24dp\u0026#34; /\u0026gt; \u0026lt;TextView style=\u0026#34;@style/MenuText\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;Print\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; \u0026lt;/LinearLayout\u0026gt; \u0026lt;/androidx.coordinatorlayout.widget.CoordinatorLayout\u0026gt; 这里用了styles.xml减少重复代码\n\u0026lt;style name=\u0026#34;MenuIcon\u0026#34;\u0026gt; \u0026lt;item name=\u0026#34;android:layout_height\u0026#34;\u0026gt;30dp\u0026lt;/item\u0026gt; \u0026lt;item name=\u0026#34;android:layout_width\u0026#34;\u0026gt;30dp\u0026lt;/item\u0026gt; \u0026lt;item name=\u0026#34;android:layout_margin\u0026#34;\u0026gt;15dp\u0026lt;/item\u0026gt; \u0026lt;/style\u0026gt; \u0026lt;style name=\u0026#34;MenuText\u0026#34;\u0026gt; \u0026lt;item name=\u0026#34;android:layout_gravity\u0026#34;\u0026gt;center_vertical\u0026lt;/item\u0026gt; \u0026lt;item name=\u0026#34;android:layout_marginStart\u0026#34;\u0026gt;30dp\u0026lt;/item\u0026gt; \u0026lt;item name=\u0026#34;android:gravity\u0026#34;\u0026gt;start\u0026lt;/item\u0026gt; \u0026lt;item name=\u0026#34;android:textColor\u0026#34;\u0026gt;#00574B\u0026lt;/item\u0026gt; \u0026lt;item name=\u0026#34;android:textSize\u0026#34;\u0026gt;20sp\u0026lt;/item\u0026gt; \u0026lt;/style\u0026gt; 然后是activity的代码SecondActivity.java public class SecondActivity extends AppCompatActivity { @Override protected void onCreate(@Nullable Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_second); // BottomSheetBehavior一共有5个状态：STATE_COLLAPSED/STATE_EXPANDED/STATE_DRAGGING/STATE_SETTLING/STATE_HIDDEN // 当你的布局文件中BottomSheetBehavior控件高度大于设置behavior_peekHeight，则Dialog会产生三种位置，一个是隐藏STATE_HIDDEN， // 另一个是STATE_EXPANDED即BottomSheetBehavior控件全部显示出来的位置，还有一个是介于前两者之间的STATE_COLLAPSED状态， // 此时露出来的Dialog高度为behavior_peekHeight； // 另一种情况是behavior_peekHeight大于BottomSheetBehavior控件高度，那么会产生一种弹性收缩的效果 BottomSheetBehavior bottomSheetBehavior = BottomSheetBehavior.from(findViewById(R.id.bottom_sheet)); bottomSheetBehavior.setState(BottomSheetBehavior.STATE_HIDDEN); findViewById(R.id.btn_show).setOnClickListener(v -\u0026gt; { // 这里通过判断当前状态来进行收缩和打开，与此同时Dialog支持直接滑动关闭 if (bottomSheetBehavior.getState() == BottomSheetBehavior.STATE_HIDDEN) { bottomSheetBehavior.setState(BottomSheetBehavior.STATE_COLLAPSED); } else if (bottomSheetBehavior.getState() == BottomSheetBehavior.STATE_COLLAPSED) { bottomSheetBehavior.setState(BottomSheetBehavior.STATE_HIDDEN); } }); // 通过设置BottomSheetCallback来控制状态变化产生的其他效果，也可以控制滑动过程中产生其他效果 bottomSheetBehavior.setBottomSheetCallback(new BottomSheetBehavior.BottomSheetCallback() { @Override public void onStateChanged(@NonNull View bottomSheet, int newState) { //拖动 } @Override public void onSlide(@NonNull View bottomSheet, float slideOffset) { //状态变化 } }); } } 在设备屏幕旋转时BottomSheetDialog会消失，通过在AndroidManifest.xml设置configChanges可以避免 \u0026lt;activity android:name=\u0026#34;.SecondActivity\u0026#34; android:configChanges=\u0026#34;orientation\u0026#34; /\u0026gt; 至此，简单的通过BottomSheetBehavior实现BottomSheetDialog就结束了，更复杂的效果是添加RecyclerView到BottomSheetDialog 中，同时增加点击事件监听等等，接下来介绍如何动态使用BottomSheetDialog。\n2.2 Modal BottomSheetDialog 如果你使用过AlertDialog那么就应该知道了，动态调用就是直接new一个出来，然后show一下就完事了，同理对BottomSheetDialog也成立， 因此不需要固定的BottomSheetBehavior，而直接new也分为两种方式，一个是new BottomSheetDialog()，另一个是new BottomSheetDialog()， 两者显示效果相同，但是后者通过fragment控制生命周期更合理，所以使用后者，简单使用的话只需要三步：\n继承自BottomSheetDialogFragment； 重写onCreateView方法，加入你自定义的布局； 调用show方法，这里需要Activity.getSupportFragmentManager()。 我这里实现一个相对复杂的布局，如上图所示，具体包括两部分，一个是header，header可以是一个自定义view，也可以将header隐藏，header与下面的Menu之间是透明的，下面的Menu通过RecyclerView控制选项数量，点击单个选项有水波纹效果，代码如下：\n首先是Dialog的布局文件dialog_option.xml，根据上面的描述就知道是一个RecyclerView \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:id=\u0026#34;@+id/forget_psw_bottom_sheet_layout\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:orientation=\u0026#34;vertical\u0026#34;\u0026gt; \u0026lt;androidx.recyclerview.widget.RecyclerView android:id=\u0026#34;@+id/menu_list\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; 然后是需要实现这个Dialog为透明背景，这是因为header也在RecyclerView中，那么只有透明背景才可以实现header悬浮的效果，Dialog透明背景需要styles文件 \u0026lt;style name=\u0026#34;SheetDialog\u0026#34; parent=\u0026#34;Theme.Design.Light.BottomSheetDialog\u0026#34;\u0026gt; \u0026lt;!-- 关键属性是colorBackground，transparent可以是背景透明，但是这会导致一个问题，此处伏笔 --\u0026gt; \u0026lt;item name=\u0026#34;android:windowIsTranslucent\u0026#34;\u0026gt;true\u0026lt;/item\u0026gt; \u0026lt;item name=\u0026#34;android:windowContentOverlay\u0026#34;\u0026gt;@null\u0026lt;/item\u0026gt; \u0026lt;item name=\u0026#34;android:colorBackground\u0026#34;\u0026gt;@android:color/transparent\u0026lt;/item\u0026gt; \u0026lt;item name=\u0026#34;android:backgroundDimEnabled\u0026#34;\u0026gt;true\u0026lt;/item\u0026gt; \u0026lt;item name=\u0026#34;android:backgroundDimAmount\u0026#34;\u0026gt;0.3\u0026lt;/item\u0026gt; \u0026lt;item name=\u0026#34;android:windowFrame\u0026#34;\u0026gt;@null\u0026lt;/item\u0026gt; \u0026lt;item name=\u0026#34;android:windowIsFloating\u0026#34;\u0026gt;true\u0026lt;/item\u0026gt; \u0026lt;/style\u0026gt; 以及header的布局文件card_layout.xml和Menu Item的布局文件menu_item.xml，header有圆角，可以用另一种Material组件实现CardView \u0026lt;!-- card_layout.xml --\u0026gt; \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; xmlns:app=\u0026#34;http://schemas.android.com/apk/res-auto\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:orientation=\u0026#34;horizontal\u0026#34; android:padding=\u0026#34;8dp\u0026#34;\u0026gt; \u0026lt;androidx.cardview.widget.CardView android:layout_width=\u0026#34;0dp\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_margin=\u0026#34;4dp\u0026#34; android:layout_weight=\u0026#34;1\u0026#34; android:elevation=\u0026#34;4dp\u0026#34; app:cardCornerRadius=\u0026#34;10dp\u0026#34;\u0026gt; \u0026lt;LinearLayout android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:background=\u0026#34;@color/white\u0026#34; android:orientation=\u0026#34;horizontal\u0026#34; android:padding=\u0026#34;12dp\u0026#34;\u0026gt; \u0026lt;TextView style=\u0026#34;@style/Image\u0026#34; android:text=\u0026#34;@string/glass\u0026#34; /\u0026gt; \u0026lt;TextView style=\u0026#34;@style/Image\u0026#34; android:text=\u0026#34;@string/clap\u0026#34; /\u0026gt; \u0026lt;TextView style=\u0026#34;@style/Image\u0026#34; android:text=\u0026#34;@string/cry\u0026#34; /\u0026gt; \u0026lt;TextView style=\u0026#34;@style/Image\u0026#34; android:text=\u0026#34;@string/party\u0026#34; /\u0026gt; \u0026lt;TextView style=\u0026#34;@style/Image\u0026#34; android:text=\u0026#34;@string/heart\u0026#34; /\u0026gt; \u0026lt;TextView style=\u0026#34;@style/Image\u0026#34; android:text=\u0026#34;@string/thumb\u0026#34; /\u0026gt; \u0026lt;ImageView style=\u0026#34;@style/Image\u0026#34; android:src=\u0026#34;@drawable/ic_keyboard_arrow_right_black_24dp\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; \u0026lt;/androidx.cardview.widget.CardView\u0026gt; \u0026lt;androidx.cardview.widget.CardView android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_margin=\u0026#34;4dp\u0026#34; android:elevation=\u0026#34;4dp\u0026#34; app:cardCornerRadius=\u0026#34;10dp\u0026#34;\u0026gt; \u0026lt;LinearLayout android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:background=\u0026#34;@color/white\u0026#34; android:orientation=\u0026#34;horizontal\u0026#34; android:padding=\u0026#34;12dp\u0026#34;\u0026gt; \u0026lt;ImageView android:layout_width=\u0026#34;20dp\u0026#34; android:layout_height=\u0026#34;20dp\u0026#34; android:layout_gravity=\u0026#34;center\u0026#34; android:src=\u0026#34;@drawable/outline\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; \u0026lt;/androidx.cardview.widget.CardView\u0026gt; \u0026lt;/LinearLayout\u0026gt; 这里使用了strings的资源，通过Unicode表示表情符号\n\u0026lt;resources\u0026gt; \u0026lt;string name=\u0026#34;thumb\u0026#34;\u0026gt;\u0026amp;#128532;\u0026lt;/string\u0026gt; \u0026lt;string name=\u0026#34;heart\u0026#34;\u0026gt;❤️\u0026lt;/string\u0026gt; \u0026lt;string name=\u0026#34;party\u0026#34;\u0026gt;\u0026amp;#128222;\u0026lt;/string\u0026gt; \u0026lt;string name=\u0026#34;cry\u0026#34;\u0026gt;\u0026amp;#128722;\u0026lt;/string\u0026gt; \u0026lt;string name=\u0026#34;clap\u0026#34;\u0026gt;\u0026amp;#128512;\u0026lt;/string\u0026gt; \u0026lt;string name=\u0026#34;glass\u0026#34;\u0026gt;\u0026amp;#128522;\u0026lt;/string\u0026gt; \u0026lt;/resources\u0026gt; \u0026lt;!-- menu_item.xml --\u0026gt; \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34;\u0026gt; \u0026lt;!-- 注意这里伏笔就来了，设置为透明背景的Dialog中，子控件也会是透明的，而且若对子控件的background 设置为某种颜色则无法产生水波纹效果，所以需要自定义@drawable/touch_bg --\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/menu_text\u0026#34; style=\u0026#34;@style/BottomDialog\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:background=\u0026#34;@drawable/touch_bg\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; \u0026lt;style name=\u0026#34;BottomDialog\u0026#34;\u0026gt; \u0026lt;item name=\u0026#34;android:padding\u0026#34;\u0026gt;16dp\u0026lt;/item\u0026gt; \u0026lt;item name=\u0026#34;android:textSize\u0026#34;\u0026gt;16sp\u0026lt;/item\u0026gt; \u0026lt;item name=\u0026#34;android:textColor\u0026#34;\u0026gt;@color/black\u0026lt;/item\u0026gt; \u0026lt;item name=\u0026#34;android:gravity\u0026#34;\u0026gt;center\u0026lt;/item\u0026gt; \u0026lt;item name=\u0026#34;android:textStyle\u0026#34;\u0026gt;normal\u0026lt;/item\u0026gt; \u0026lt;/style\u0026gt; \u0026lt;!-- touch_bg.xml --\u0026gt; \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;!--Use an almost transparent color for the ripple itself--\u0026gt; \u0026lt;ripple xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:color=\u0026#34;#22000000\u0026#34;\u0026gt; \u0026lt;!--Use this to define the shape of the ripple effect (rectangle, oval, ring or line). The color specified here isn\u0026#39;t used anyway--\u0026gt; \u0026lt;item android:id=\u0026#34;@android:id/mask\u0026#34;\u0026gt; \u0026lt;shape android:shape=\u0026#34;rectangle\u0026#34;\u0026gt; \u0026lt;solid android:color=\u0026#34;#000000\u0026#34; /\u0026gt; \u0026lt;/shape\u0026gt; \u0026lt;/item\u0026gt; \u0026lt;!--This is the background for your button--\u0026gt; \u0026lt;item\u0026gt; \u0026lt;!--Use the shape you want here--\u0026gt; \u0026lt;shape android:shape=\u0026#34;rectangle\u0026#34;\u0026gt; \u0026lt;!--Use the solid tag to define the background color you want (here white)--\u0026gt; \u0026lt;solid android:color=\u0026#34;@color/white\u0026#34;/\u0026gt; \u0026lt;!--Use the stroke tag for a border--\u0026gt; \u0026lt;stroke android:width=\u0026#34;1dp\u0026#34; android:color=\u0026#34;@color/white\u0026#34;/\u0026gt; \u0026lt;/shape\u0026gt; \u0026lt;/item\u0026gt; \u0026lt;/ripple\u0026gt; 接下来就是主要java代码了，包括MenuBottomSheetDialog.java和MenuListAdapter.java，前者是我们最终调用的Dialog，后者是RecyclerView的Adapter，以及自定义一个Menu Item的实体类OptionMenuItem.java用于保存信息 public class OptionMenuItem { // label表示选项的名称最终会显示在Dialog，action表示该选项的行为，这里可以自定义增加其他内容， // 比如增加一个state属性表示该选项是否可用等等，如不可用，则颜色为灰色且不可点击，不过我没加 private String label; private int action; public OptionMenuItem(String label, int action) { this.label = label; this.action = action; } public String getLabel() { return label; } public void setLabel(String label) { this.label = label; } public int getAction() { return action; } public void setAction(int action) { this.action = action; } } public class MenuBottomSheetDialog extends BottomSheetDialogFragment { private static final String TAG = MenuBottomSheetDialog.class.getSimpleName(); private RecyclerView recyclerView; private MenuListAdapter adapter; // 这里还加了一个参数hasItemDecoration用于控制是否显示选项之间的分割线 private Boolean hasItemDecoration = true; private Context context; private static MenuBottomSheetDialog newInstance(Builder builder) { MenuBottomSheetDialog fragment = new MenuBottomSheetDialog(); // Bundle bundle = new Bundle(); // fragment.setArguments(bundle); fragment.setHasItemDecoration(builder.hasItemDecoration); fragment.setAdapter(builder.adapter); fragment.setContext(builder.context); return fragment; } @NonNull @Override public Dialog onCreateDialog(Bundle savedInstanceState) { // R.style.SheetDialog 透明背景需要在onCreateDialog方法引入 return new BottomSheetDialog(context, R.style.SheetDialog); } @Nullable @Override public View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) { // 在onCreateView引入定义的dialog布局 return inflater.inflate(R.layout.dialog_option, container, false); } @Override public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) { super.onViewCreated(view, savedInstanceState); // onViewCreated中进行初始化，这里就很简单的使用了RecyclerView recyclerView = view.findViewById(R.id.menu_list); recyclerView.setLayoutManager(new LinearLayoutManager(getContext())); recyclerView.setAdapter(adapter); if (hasItemDecoration) { // DividerItemDecoration可以方便的加入到RecyclerView，形成分割线，布局文件在下面 DividerItemDecoration dec = new DividerItemDecoration(context, DividerItemDecoration.VERTICAL); dec.setDrawable(getResources().getDrawable(R.drawable.divider_line)); recyclerView.addItemDecoration(dec); } } // 最终我们通过show方法调用 public void show(FragmentManager fragmentManager) { FragmentTransaction transaction = fragmentManager.beginTransaction(); Fragment prevFragment = fragmentManager.findFragmentByTag(TAG); if (prevFragment != null) { transaction.remove(prevFragment); } transaction.addToBackStack(null); show(transaction, TAG); } // 这里因为参数可能会有很多，所以采用建造者模式实现 public static Builder builder(Context context) { return new Builder(context); } public static class Builder { // 建造者模式需要传入的参数有三个 private MenuListAdapter adapter; private Boolean hasItemDecoration; private Context context; public Builder(Context context) { this.context = context; } // 以下都是建造者模式可调用的方法 public Builder setAdapter(MenuListAdapter adapter) { this.adapter = adapter; return this; } public Builder setHasItemDecoration(Boolean hasItemDecoration) { this.hasItemDecoration = hasItemDecoration; return this; } public MenuBottomSheetDialog build() { return newInstance(this); } public MenuBottomSheetDialog show(FragmentManager fragmentManager) { MenuBottomSheetDialog dialog = build(); dialog.show(fragmentManager); return dialog; } } private void setAdapter(MenuListAdapter adapter) { this.adapter = adapter; } private void setContext(Context context) { this.context = context; } private void setHasItemDecoration(Boolean hasItemDecoration) { this.hasItemDecoration = hasItemDecoration; } } \u0026lt;!-- divider_line.xml --\u0026gt; \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;layer-list xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34;\u0026gt; \u0026lt;!--分割线左右边距--\u0026gt; \u0026lt;item\u0026gt; \u0026lt;shape\u0026gt; \u0026lt;solid android:color=\u0026#34;@color/split_line_grey\u0026#34; /\u0026gt; \u0026lt;size android:height=\u0026#34;1dp\u0026#34; /\u0026gt; \u0026lt;/shape\u0026gt; \u0026lt;/item\u0026gt; \u0026lt;/layer-list\u0026gt; 接下来是RecyclerView的Adapter文件MenuListAdapter.java public class MenuListAdapter extends RecyclerView.Adapter\u0026lt;RecyclerView.ViewHolder\u0026gt; { // 通过hasHeader控制是否显示header，这里是通过MenuListAdapter传入的参数，没有用上面建造者模式 private Boolean hasHeader; // 监听选项点击，这里我仅仅对选项做监听没有对header进行任何控制，所以header只是个没有灵魂的花瓶 private OnMenuItemClickListener onMenuClickListener; // 传入的选项list private List\u0026lt;OptionMenuItem\u0026gt; options; // onCreateViewHolder判断是否为header的参数 public static final int VIEW_TYPE_HEADER = 0; public static final int VIEW_TYPE_ITEM = 1; public MenuListAdapter() { this.options = new ArrayList\u0026lt;\u0026gt;(); } public MenuListAdapter(List\u0026lt;OptionMenuItem\u0026gt; options) { this.options = options; } @NonNull @Override public RecyclerView.ViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) { RecyclerView.ViewHolder viewHolder = null; switch (viewType) { // 这里也比较好理解，如果为header传入header的布局，如果为Menu Item则传入Item的布局 case VIEW_TYPE_HEADER: viewHolder = new HeaderViewHolder(LayoutInflater.from(parent.getContext()).inflate(R.layout.card_layout, parent, false)); break; case VIEW_TYPE_ITEM: viewHolder = new MenuItemViewHolder(LayoutInflater.from(parent.getContext()).inflate(R.layout.menu_item, parent, false)); break; } return viewHolder; } @Override public void onBindViewHolder(@NonNull RecyclerView.ViewHolder holder, int position) { switch (holder.getItemViewType()) { case VIEW_TYPE_HEADER: // todo add header view listener break; case VIEW_TYPE_ITEM: // 注意这里positon与header存在与否的关系，然后通过接口把点击事件传出去 OptionMenuItem menuItem = options.get(hasHeader ? position - 1 : position); ((MenuItemViewHolder) holder).bind(menuItem); holder.itemView.setOnClickListener(v -\u0026gt; { Log.i(\u0026#34;aaa\u0026#34;, \u0026#34;click\u0026#34;); if (onMenuClickListener != null) { onMenuClickListener.onMenuClick(holder.itemView, menuItem.getAction()); } }); break; } } @Override public int getItemViewType(int position) { // 在getItemViewType定义type，从而在前面两个方法中获取 if (hasHeader) { if (position == 0) { return VIEW_TYPE_HEADER; } } return VIEW_TYPE_ITEM; } @Override public int getItemCount() { // 同理options.size()与hasHeader的关系 return hasHeader ? (options.size() + 1) : options.size(); } class MenuItemViewHolder extends RecyclerView.ViewHolder { TextView text; // 正如我在Menu Item实体类中所设想的，我们可以在这里根据state进行额外的控制 public MenuItemViewHolder(@NonNull View itemView) { super(itemView); text = itemView.findViewById(R.id.menu_text); } private void bind(OptionMenuItem optionMenuItem) { text.setText(optionMenuItem.getLabel()); } } class HeaderViewHolder extends RecyclerView.ViewHolder { public HeaderViewHolder(@NonNull View itemView) { super(itemView); } } public void addAll(List\u0026lt;OptionMenuItem\u0026gt; options) { this.options.clear(); this.options.addAll(options); notifyDataSetChanged(); } public void add(OptionMenuItem option) { if (options != null) { this.options.add(option); notifyDataSetChanged(); } } public void setHasHeader(Boolean hasHeader) { this.hasHeader = hasHeader; } // 对外暴露的接口以及设置监听的方法 public interface OnMenuItemClickListener { void onMenuClick(View view, int action); } public void setOnMenuItemClickListener(OnMenuItemClickListener listener) { this.onMenuClickListener = listener; } } 最后是直接使用的方式ThirdActivity.java public class ThirdActivity extends AppCompatActivity implements MenuListAdapter.OnMenuItemClickListener{ @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_third); ArrayList\u0026lt;OptionMenuItem\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); list.add(new OptionMenuItem(\u0026#34;Forward\u0026#34;, 98)); list.add(new OptionMenuItem(\u0026#34;Copy\u0026#34;, 2121)); list.add(new OptionMenuItem(\u0026#34;Mark as unread\u0026#34;, 111)); list.add(new OptionMenuItem(\u0026#34;Star message\u0026#34;, 66)); list.add(new OptionMenuItem(\u0026#34;Cancel\u0026#34;, 2)); MenuListAdapter menuListAdapter = new MenuListAdapter(); menuListAdapter.addAll(list); menuListAdapter.setHasHeader(true); menuListAdapter.setOnMenuItemClickListener(this); findViewById(R.id.button2).setOnClickListener(v -\u0026gt; { // 两种方式等效 // MenuBottomSheetDialog.builder(ThirdActivity.this) // .setAdapter(menuListAdapter) // .setHasItemDecoration(true) // .show(getSupportFragmentManager()); MenuBottomSheetDialog dialog = MenuBottomSheetDialog.builder(ThirdActivity.this) .setAdapter(menuListAdapter) .setHasItemDecoration(true) .build(); dialog.show(getSupportFragmentManager()); }); } @Override public void onMenuClick(View view, int action) { // 点击事件的回调 Toast.makeText(this, \u0026#34;action \u0026#34; + action, Toast.LENGTH_SHORT).show(); } } 3. BottomSheetDialog进阶与Bug 上图即BottomSheetDialog与ViewPager以及RecyclerView之间的Bug，简而言之就是ViewPager下除了第一个页面可以滑动之外，其他页面均不可滑动，具体的Error link以及我在Github上提的issue，这个问题已经有大神给出了解决方法，但是官方目前还是没有引入。\n下面我们就来复现这种状况，不过我的设计效果与上图略有不同，增加了一些内容，首先是TabLayout的title，它是由两部分组成，前面是一个Unicode表情，后面是数字，数值表示在这个表情下的list的大小；TabLayout下面对应不同的Fragment，Fragment中显示当前的list，我这里生成的Item都是简单写一下，没有具体意义；整个设计思路是，自定义一个ListBottomSheetDialog，这个dialog由ViewPager + TabLayout + Fragment + RecyclerView组成，先从Fragment开始实现步骤\nListObjectFragment布局文件fragment_list.xml与Item布局文件item_list.xml \u0026lt;!-- fragment_list.xml --\u0026gt; \u0026lt;!-- 首先暂时使用CoordinatorLayout，可能后续会修改为NestedScrollView，此处伏笔 --\u0026gt; \u0026lt;!-- 而且background=\u0026#34;@color/white\u0026#34;是由于后面Dialog为透明背景，这里需要白色背景避免Fragment切换时背景突变透明 --\u0026gt; \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;androidx.coordinatorlayout.widget.CoordinatorLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; xmlns:app=\u0026#34;http://schemas.android.com/apk/res-auto\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:background=\u0026#34;@color/white\u0026#34; android:orientation=\u0026#34;vertical\u0026#34;\u0026gt; \u0026lt;androidx.recyclerview.widget.RecyclerView android:id=\u0026#34;@+id/list_view\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; app:layout_behavior=\u0026#34;com.google.android.material.bottomsheet.BottomSheetBehavior\u0026#34; /\u0026gt; \u0026lt;/androidx.coordinatorlayout.widget.CoordinatorLayout\u0026gt; \u0026lt;!-- item_list.xml --\u0026gt; \u0026lt;!-- 注意这里也使用了上面文中出现的水波纹效果背景touch_bg，这是因为要实现圆角背景 --\u0026gt; \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:background=\u0026#34;@drawable/touch_bg\u0026#34; android:orientation=\u0026#34;horizontal\u0026#34; android:padding=\u0026#34;10dp\u0026#34;\u0026gt; \u0026lt;ImageView android:id=\u0026#34;@+id/avatar\u0026#34; android:layout_width=\u0026#34;40dp\u0026#34; android:layout_height=\u0026#34;40dp\u0026#34; android:background=\u0026#34;@color/holo_blue_light\u0026#34; /\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/name\u0026#34; android:layout_width=\u0026#34;0dp\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_gravity=\u0026#34;center\u0026#34; android:layout_marginStart=\u0026#34;10dp\u0026#34; android:layout_weight=\u0026#34;1\u0026#34; android:padding=\u0026#34;5dp\u0026#34; android:text=\u0026#34;name\u0026#34; android:textColor=\u0026#34;@color/black\u0026#34; android:textSize=\u0026#34;20sp\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; 然后是RecyclerView的Adapter ListViewAdapter.java public class ListViewAdapter extends RecyclerView.Adapter\u0026lt;ListViewAdapter.MyViewHolder\u0026gt;{ // 这里加了点击事件的接口 private ItemClickListener onItemClickListener; // 显示的Item就是一个一个的User信息，User信息也很简单，avatar和name，但是avatar没有赋值 private List\u0026lt;User\u0026gt; data; public ListViewAdapter(List\u0026lt;User\u0026gt; data) { this.data = data; } @NonNull @Override public MyViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) { // 常见方式 View view = LayoutInflater.from(parent.getContext()).inflate(R.layout.item_list, parent, false); MyViewHolder holder = new MyViewHolder(view); return holder; } @Override public void onBindViewHolder(@NonNull MyViewHolder holder, int position) { User user = data.get(position); // 这里avatar写死了，没有赋值，偷个懒 holder.avatar.setImageResource(R.drawable.ic_launcher_foreground); holder.name.setText(user.getName()); // 把点击事件传出去 holder.itemView.setOnClickListener(v -\u0026gt; { if (onItemClickListener != null) { onItemClickListener.onItemClick(holder.itemView, position); } }); } @Override public int getItemCount() { return data.size(); } class MyViewHolder extends RecyclerView.ViewHolder { ImageView avatar; TextView name; public MyViewHolder(@NonNull View itemView) { super(itemView); avatar = itemView.findViewById(R.id.avatar); name = itemView.findViewById(R.id.name); } } public interface ItemClickListener { void onItemClick(View view, int position); } public void setItemClickListener(ItemClickListener clickListener) { onItemClickListener = clickListener; } } public class User { private String avatar; private String name; public User(String avatar, String name) { this.avatar = avatar; this.name = name; } public String getAvatar() { return avatar; } public void setAvatar(String avatar) { this.avatar = avatar; } public String getName() { return name; } public void setName(String name) { this.name = name; } } Fragment ListObjectFragment.java public class ListObjectFragment extends Fragment implements ListViewAdapter.ItemClickListener{ // emoji表示Unicode表情，count表示list大小 private int count; private String emoji; private List\u0026lt;User\u0026gt; list; private ListViewAdapter listViewAdapter; private RecyclerView recyclerView; // 加了几个参数用于仅在Fragment对用户可见时加载数据，针对ViewPager预加载 private boolean isViewInitiated; private boolean isVisibleToUser; private boolean isDataInitiated; // 这里传入了list，但是在onResume时才是真实加载数据的时候 public ListObjectFragment(String emoji, int count, List\u0026lt;User\u0026gt; list) { this.emoji = emoji; this.count = count; this.list = list; } @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) { return inflater.inflate(R.layout.fragment_list_test, container, false); } @Override public void onResume() { super.onResume(); isVisibleToUser = true; prepareFetchData(); listViewAdapter = new ListViewAdapter(list); listViewAdapter.setItemClickListener(this); recyclerView.setLayoutManager(new LinearLayoutManager(getContext())); recyclerView.setAdapter(listViewAdapter); } @Override public void onStop() { super.onStop(); isVisibleToUser = false; } private void fetchData() { // 真实加载list的地方，这里仅模拟 list = new ArrayList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; count; i++) { list.add(new User(\u0026#34;\u0026#34;, \u0026#34;name\u0026#34; + i)); } } public boolean prepareFetchData() { return prepareFetchData(false); } public boolean prepareFetchData(boolean forceUpdate) { if (isVisibleToUser \u0026amp;\u0026amp; isViewInitiated \u0026amp;\u0026amp; (!isDataInitiated || forceUpdate)) { fetchData(); isDataInitiated = true; return true; } return false; } @Override public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) { isViewInitiated = true; recyclerView = view.findViewById(R.id.list_view); } @Override public void onItemClick(View view, int position) { // 点击事件回调 Toast.makeText(getContext(), \u0026#34;position\u0026#34; + position, Toast.LENGTH_SHORT).show(); } } 自定义BottomSheetDialog的布局文件dialog_list.xml，圆角背景radius_background.xml \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; xmlns:app=\u0026#34;http://schemas.android.com/apk/res-auto\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:orientation=\u0026#34;vertical\u0026#34;\u0026gt; \u0026lt;com.google.android.material.tabs.TabLayout android:id=\u0026#34;@+id/tablayout\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:background=\u0026#34;@drawable/radius_background\u0026#34; app:tabIndicatorColor=\u0026#34;@color/colorPrimaryDark\u0026#34; app:tabMode=\u0026#34;scrollable\u0026#34; app:tabTextColor=\u0026#34;@color/black\u0026#34; /\u0026gt; \u0026lt;View android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;1dp\u0026#34; android:background=\u0026#34;@color/split_line_grey\u0026#34; /\u0026gt; \u0026lt;com.tao.bottomsheetdemo.custom.CustomViewPager android:id=\u0026#34;@+id/viewpager\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34;/\u0026gt; \u0026lt;/LinearLayout\u0026gt; \u0026lt;!-- radius_background.xml --\u0026gt; \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;shape xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34;\u0026gt; \u0026lt;solid android:color=\u0026#34;@color/white\u0026#34; /\u0026gt; \u0026lt;corners android:topLeftRadius=\u0026#34;10dp\u0026#34; android:topRightRadius=\u0026#34;10dp\u0026#34; /\u0026gt; \u0026lt;/shape\u0026gt; 自定义ViewPager CustomViewPager.java public class CustomViewPager extends ViewPager { // CustomViewPager control scroll enable private boolean enabled; public CustomViewPager(@NonNull Context context) { super(context); this.enabled = true; } public CustomViewPager(Context context, AttributeSet attrs) { super(context, attrs); this.enabled = true; } @Override public boolean onTouchEvent(MotionEvent event) { if (this.enabled) { return super.onTouchEvent(event); } return false; } @Override public boolean onInterceptTouchEvent(MotionEvent event) { // 事件传递控制是否支持左右滑动 if (this.enabled) { return super.onInterceptTouchEvent(event); } return false; } public void setPagingEnabled(boolean enabled) { this.enabled = enabled; } } 自定义BottomSheetDialog ListBottomSheetDialog.java与ViewPager的Adapter ListPagerAdapter.java public class ListBottomSheetDialog extends BottomSheetDialogFragment { private static final String TAG = ListBottomSheetDialog.class.getSimpleName(); // 这里的ViewPager为自定义的CustomViewPager，多了额外的功能：可以控制是否支持左右滑动切换Fragment private TabLayout tabLayout; private CustomViewPager viewPager; // offscreenPageLimit设置可以使ViewPager下的Fragment缓存数据，数值表示缓存数据的Fragment数量 private int offscreenPageLimit = 10; // 通过参数控制是否支持左右滑动 private Boolean enableScroll; // EmojiItem是包含emoji/count/list的实体类，所以可知传入Dialog的数据是一种嵌套list形式 private List\u0026lt;EmojiItem\u0026gt; emojiItemList; private Context context; // ViewPager的Adapter private ListPagerAdapter adapter; private static ListBottomSheetDialog newInstance(ListBottomSheetDialog.Builder builder) { ListBottomSheetDialog fragment = new ListBottomSheetDialog(); // Bundle bundle = new Bundle(); // fragment.setArguments(bundle); // fragment.setHeight(builder.peekHeight, builder.maxHeight); fragment.setEmojiItemList(builder.emojiItemList); fragment.setContext(builder.context); fragment.setOffscreenPageLimit(builder.offscreenPageLimit); fragment.setEnableScroll(builder.enableScroll); return fragment; } @NonNull @Override public Dialog onCreateDialog(@Nullable Bundle savedInstanceState) { // 由于需要首先圆角背景，所以这里也使用了透明背景 BottomSheetDialog dialog = new BottomSheetDialog(context, R.style.SheetDialog); // set dialog peek height and max height // dialog.setPeekHeight(peekHeight); // dialog.setMaxHeight(maxHeight); return dialog; } @Nullable @Override public View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) { return inflater.inflate(R.layout.dialog_list, container, false); } @Override public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) { super.onViewCreated(view, savedInstanceState); viewPager = view.findViewById(R.id.viewpager); tabLayout = view.findViewById(R.id.tablayout); if (viewPager != null \u0026amp;\u0026amp; tabLayout != null) { initViewPager(); } } private void initViewPager() { // ListPagerAdapter.BEHAVIOR_RESUME_ONLY_CURRENT_FRAGMENT参数控制仅在Fragment对用户可见时调用onResume，这也是对应了上面在 // Fragment中数据加载 adapter = new ListPagerAdapter(getChildFragmentManager(), ListPagerAdapter.BEHAVIOR_RESUME_ONLY_CURRENT_FRAGMENT, context); // 这里的emojiItemList比较简单，没有其他参数，理论上需要根据定义的其他参数传入到Fragment中再进行进一步请求数据 adapter.setEmojiItemList(emojiItemList); viewPager.setAdapter(adapter); viewPager.setOffscreenPageLimit(offscreenPageLimit); // 这里可以控制是否左右滑动 viewPager.setPagingEnabled(enableScroll); // TabLayout与ViewPager关联，自动实现滑动切换或者点击切换的效果 tabLayout.setupWithViewPager(viewPager); } public void show(FragmentManager fragmentManager) { FragmentTransaction transaction = fragmentManager.beginTransaction(); Fragment prevFragment = fragmentManager.findFragmentByTag(TAG); if (prevFragment != null) { transaction.remove(prevFragment); } transaction.addToBackStack(null); show(transaction, TAG); } // 建造者模式，同上 public static Builder builder(Context context) { return new Builder(context); } public static class Builder { // private int peekHeight; // private int maxHeight; private int offscreenPageLimit; private Boolean enableScroll; private List\u0026lt;EmojiItem\u0026gt; emojiItemList; private Context context; public Builder(Context context) { this.context = context; } // 这里注释掉的方法可以控制Dialog Expand状态下的高度以及Collapse状态的高度，但是需要自定义BottomSheetDialog // 暂时不写 // public Builder setPeekHeight(int peekHeight) { // this.peekHeight = peekHeight; // return this; // } // public Builder setMaxHeight(int maxHeight) { // this.maxHeight = maxHeight; // return this; // } public Builder setOffscreenPageLimit(int offscreenPageLimit) { this.offscreenPageLimit = offscreenPageLimit; return this; } public Builder setEnableScroll(Boolean enableScroll) { this.enableScroll = enableScroll; return this; } public Builder setEmojiItemList(List\u0026lt;EmojiItem\u0026gt; emojiItemList) { this.emojiItemList = emojiItemList; return this; } public ListBottomSheetDialog build() { return newInstance(this); } public ListBottomSheetDialog show(FragmentManager fragmentManager) { ListBottomSheetDialog dialog = build(); dialog.show(fragmentManager); return dialog; } } private void setContext(Context context) { this.context = context; } // private void setHeight(int peekHeight, int maxHeight) { // this.peekHeight = peekHeight; // this.maxHeight = maxHeight; // } private void setOffscreenPageLimit(int offscreenPageLimit) { this.offscreenPageLimit = offscreenPageLimit; } private void setEnableScroll(Boolean enableScroll) { this.enableScroll = enableScroll; } private void setEmojiItemList(List\u0026lt;EmojiItem\u0026gt; emojiItemList) { this.emojiItemList = emojiItemList; } } public class ListPagerAdapter extends FragmentStatePagerAdapter { private List\u0026lt;EmojiItem\u0026gt; emojiItemList; private List\u0026lt;EmojiItem\u0026gt; sortedList; private Context context; public ListPagerAdapter(@NonNull FragmentManager fm, int behavior, Context context) { super(fm, behavior); this.context = context; } public ListPagerAdapter(@NonNull FragmentManager fm, int behavior, List\u0026lt;EmojiItem\u0026gt; emojiItemList, Context context) { super(fm, behavior); this.emojiItemList = emojiItemList; this.context = context; // 这里还需要将传入的emojiItemList按照count进行降序排列 this.sortedList = sortList(emojiItemList); } @Override public Fragment getItem(int position) { String label = sortedList.get(position).getEmoji(); int count = sortedList.get(position).getCount(); List\u0026lt;User\u0026gt; list = sortedList.get(position).getUserList(); Fragment fragment = new ListObjectFragment(label, count, list); Bundle args = new Bundle(); return fragment; } @Override public int getCount() { return emojiItemList.size(); } @Override public CharSequence getPageTitle(int position) { // 这里设置TabLayout的title，emoji+count CharSequence emoji = sortedList.get(position).getEmoji(); CharSequence title = emoji + \u0026#34; \u0026#34; + sortedList.get(position).getCount(); SpannableStringBuilder spBuilder = new SpannableStringBuilder(title); Pattern pattern = Pattern.compile(emoji.toString()); Matcher matcher = pattern.matcher(title); while (matcher.find()) { TextAppearanceSpan span = new TextAppearanceSpan(context, R.style.UIKitTextView_ReactionLabel); spBuilder.setSpan(span, matcher.start(), matcher.end(), Spannable.SPAN_EXCLUSIVE_EXCLUSIVE); } return spBuilder; } private List\u0026lt;EmojiItem\u0026gt; sortList(List\u0026lt;EmojiItem\u0026gt; list) { List\u0026lt;EmojiItem\u0026gt; tmp = new ArrayList\u0026lt;\u0026gt;(list); Collections.sort(tmp, new Comparator\u0026lt;EmojiItem\u0026gt;() { @Override public int compare(EmojiItem o1, EmojiItem o2) { return o2.getCount() - o1.getCount(); } }); return tmp; } public void setEmojiItemList(List\u0026lt;EmojiItem\u0026gt; emojiItemList) { this.emojiItemList = emojiItemList; this.sortedList = sortList(emojiItemList); } } EmojiItem实体类 public class EmojiItem { private String emoji; private int count; private List\u0026lt;User\u0026gt; userList; public EmojiItem(String emoji, int count, List\u0026lt;User\u0026gt; userList) { this.emoji = emoji; this.count = count; this.userList = userList; } public String getEmoji() { return emoji; } public void setEmoji(String emoji) { this.emoji = emoji; } public int getCount() { return count; } public void setCount(int count) { this.count = count; } public List\u0026lt;User\u0026gt; getUserList() { return userList; } public void setUserList(List\u0026lt;User\u0026gt; userList) { this.userList = userList; } } 调用 FourthActivity.java public class FourthActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_fourth); List\u0026lt;EmojiItem\u0026gt; data = new ArrayList\u0026lt;\u0026gt;(); String[] arr = new String[]{ \u0026#34;\\uD83D\\uDC4D\u0026#34;, \u0026#34;❤️\u0026#34;, \u0026#34;\\uD83C\\uDF89\u0026#34;, \u0026#34;\\uD83D\\uDE02\u0026#34;, \u0026#34;\\uD83D\\uDC4F\u0026#34;, \u0026#34;\\uD83D\\uDE0E\u0026#34; }; for (int i = 0; i \u0026lt; arr.length; i++) { data.add(new EmojiItem(arr[i], i + 10, null)); } findViewById(R.id.button4).setOnClickListener(v -\u0026gt; ListBottomSheetDialog.builder(FourthActivity.this) .setEmojiItemList(data) .setOffscreenPageLimit(5) .setEnableScroll(true) .show(getSupportFragmentManager())); } } 运行结果\n很明显有几个问题：\nlist上面有一段空白； 除了第一个Fragment中的list可以上下滑动以外，其他Fragment中的list不可滑动，这也就是BottomSheetDialog的bug。 4. 解决方法 针对第一个Bug，这是由于Fragment的布局文件中采用了CoordinatorLayout，我们替换为NestedScrollView，对应伏笔。\n第二个bug就比较复杂，根据找到的资料显示大致有两种解决方法（并不一定能成功）\n4.1 重写ViewPager的Adapter的setPrimaryItem方法 也就是在ListPagerAdapter.java中加入\n@Override public void setPrimaryItem(@NonNull ViewGroup container, int position, @NonNull Object object) { super.setPrimaryItem(container, position, object); Fragment currentFragment = (Fragment) object; if (currentFragment.getView() != null) { for (int i = 0; i \u0026lt; container.getChildCount(); i++) { if (i != position) { // 注意这里用NestedScrollView是因为已经默认上面第一个bug被纠正 NestedScrollView otherScrollView = (NestedScrollView) container.getChildAt(i); otherScrollView.setNestedScrollingEnabled(false); } } NestedScrollView currentNestedScrollView = (NestedScrollView) currentFragment.getView(); currentNestedScrollView.setNestedScrollingEnabled(true); container.requestLayout(); } } 这段代码的作用是让对用户可见的Fragment中的NestedScrollView设置为可以滑动，其他不可见为禁止滑动，但是很遗憾，并没有解决问题，不可滑动问题依然存在。\n4.2 重写BottomSheetBehavior的findScrollingChild方法 我们可以对比以下原始的findScrollingChild方法\nView findScrollingChild(View view) { if (ViewCompat.isNestedScrollingEnabled(view)) { return view; } if (view instanceof ViewGroup) { ViewGroup group = (ViewGroup) view; for (int i = 0, count = group.getChildCount(); i \u0026lt; count; i++) { View scrollingChild = findScrollingChild(group.getChildAt(i)); if (scrollingChild != null) { return scrollingChild; } } } return null; } 以及修改后的findScrollingChild方法\nprivate View findScrollingChild(View view) { if (ViewCompat.isNestedScrollingEnabled(view)) { return view; } // 修改后的代码增加了判断的选项，根据debug的结果我们知道如果最终返回的scrollingChild是可见状态的Fragment中的NestedScrollView， // 那么则可以正常滑动，否则不可滑动 if (view instanceof ViewPager) { ViewPager viewPager = (ViewPager) view; // ViewPagerUtils通过反射获取position得到当前的Fragment中的NestedScrollView View currentViewPagerChild = ViewPagerUtils.getCurrentView(viewPager); if (currentViewPagerChild == null) { return null; } View scrollingChild = findScrollingChild(currentViewPagerChild); if (scrollingChild != null) { return scrollingChild; } } else if (view instanceof ViewGroup) { ViewGroup group = (ViewGroup) view; for (int i = 0, count = group.getChildCount(); i \u0026lt; count; i++) { View scrollingChild = findScrollingChild(group.getChildAt(i)); if (scrollingChild != null) { return scrollingChild; } } } return null; } 为了重写findScrollingChild方法，有两种方式，一是在com.google.android.material.bottomsheet包下继承BottomSheetBehavior并重写findScrollingChild方法，一是创建新的BottomSheetBehavior类，复制其中的大部分代码以及相关文件。\n创建当前项目下的另一个包com.google.android.material.bottomsheet不是一个很好的选择，所以不采用； 新建ViewPagerBottomSheetBehavior类，复制代码，并修改findScrollingChild方法，这样会创建很多额外的文件。 采用方法二，我们需要加入以下几个文件：\nViewPagerBottomSheetBehavior.java\nViewPagerUtils.java\nBottomSheetUtils.java\ndesign_view_pager_bottom_sheet_dialog.xml\n/** * An interaction behavior plugin for a child view of {@link CoordinatorLayout} to make it work as * a bottom sheet. */ public class ViewPagerBottomSheetBehavior\u0026lt;V extends View\u0026gt; extends CoordinatorLayout.Behavior\u0026lt;V\u0026gt; { /** * Callback for monitoring events about bottom sheets. */ public abstract static class BottomSheetCallback { /** * Called when the bottom sheet changes its state. * * @param bottomSheet The bottom sheet view. * @param newState The new state. This will be one of {@link #STATE_DRAGGING}, * {@link #STATE_SETTLING}, {@link #STATE_EXPANDED}, * {@link #STATE_COLLAPSED}, or {@link #STATE_HIDDEN}. */ public abstract void onStateChanged(@NonNull View bottomSheet, @State int newState); /** * Called when the bottom sheet is being dragged. * * @param bottomSheet The bottom sheet view. * @param slideOffset The new offset of this bottom sheet within [-1,1] range. Offset * increases as this bottom sheet is moving upward. From 0 to 1 the sheet * is between collapsed and expanded states and from -1 to 0 it is * between hidden and collapsed states. */ public abstract void onSlide(@NonNull View bottomSheet, float slideOffset); } /** * The bottom sheet is dragging. */ public static final int STATE_DRAGGING = 1; /** * The bottom sheet is settling. */ public static final int STATE_SETTLING = 2; /** * The bottom sheet is expanded. */ public static final int STATE_EXPANDED = 3; /** * The bottom sheet is collapsed. */ public static final int STATE_COLLAPSED = 4; /** * The bottom sheet is hidden. */ public static final int STATE_HIDDEN = 5; /** * @hide */ @RestrictTo(LIBRARY_GROUP) @IntDef({STATE_EXPANDED, STATE_COLLAPSED, STATE_DRAGGING, STATE_SETTLING, STATE_HIDDEN}) @Retention(RetentionPolicy.SOURCE) public @interface State { } /** * Peek at the 16:9 ratio keyline of its parent. * * \u0026lt;p\u0026gt;This can be used as a parameter for {@link #setPeekHeight(int)}. * {@link #getPeekHeight()} will return this when the value is set.\u0026lt;/p\u0026gt; */ public static final int PEEK_HEIGHT_AUTO = -1; private static final float HIDE_THRESHOLD = 0.5f; private static final float HIDE_FRICTION = 0.1f; private float mMaximumVelocity; private int mPeekHeight; private boolean mPeekHeightAuto; private int mPeekHeightMin; int mMinOffset; int mMaxOffset; boolean mHideable; private boolean mSkipCollapsed; @State int mState = STATE_COLLAPSED; ViewDragHelper mViewDragHelper; private boolean mIgnoreEvents; private int mLastNestedScrollDy; private boolean mNestedScrolled; int mParentHeight; WeakReference\u0026lt;V\u0026gt; mViewRef; WeakReference\u0026lt;View\u0026gt; mNestedScrollingChildRef; private BottomSheetCallback mCallback; private VelocityTracker mVelocityTracker; int mActivePointerId; private int mInitialY; boolean mTouchingScrollingChild; /** * Default constructor for instantiating ViewPagerBottomSheetBehaviors. */ public ViewPagerBottomSheetBehavior() { } /** * Default constructor for inflating ViewPagerBottomSheetBehaviors from layout. * * @param context The {@link Context}. * @param attrs The {@link AttributeSet}. */ public ViewPagerBottomSheetBehavior(Context context, AttributeSet attrs) { super(context, attrs); TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.BottomSheetBehavior_Layout); TypedValue value = a.peekValue(R.styleable.BottomSheetBehavior_Layout_behavior_peekHeight); if (value != null \u0026amp;\u0026amp; value.data == PEEK_HEIGHT_AUTO) { setPeekHeight(value.data); } else { setPeekHeight(a.getDimensionPixelSize( R.styleable.BottomSheetBehavior_Layout_behavior_peekHeight, PEEK_HEIGHT_AUTO)); } setHideable(a.getBoolean(R.styleable.BottomSheetBehavior_Layout_behavior_hideable, false)); setSkipCollapsed(a.getBoolean(R.styleable.BottomSheetBehavior_Layout_behavior_skipCollapsed, false)); a.recycle(); ViewConfiguration configuration = ViewConfiguration.get(context); mMaximumVelocity = configuration.getScaledMaximumFlingVelocity(); } @Override public Parcelable onSaveInstanceState(CoordinatorLayout parent, V child) { return new SavedState(super.onSaveInstanceState(parent, child), mState); } @Override public void onRestoreInstanceState(CoordinatorLayout parent, V child, Parcelable state) { SavedState ss = (SavedState) state; super.onRestoreInstanceState(parent, child, ss.getSuperState()); // Intermediate states are restored as collapsed state if (ss.state == STATE_DRAGGING || ss.state == STATE_SETTLING) { mState = STATE_COLLAPSED; } else { mState = ss.state; } } @Override public boolean onLayoutChild(CoordinatorLayout parent, V child, int layoutDirection) { if (ViewCompat.getFitsSystemWindows(parent) \u0026amp;\u0026amp; !ViewCompat.getFitsSystemWindows(child)) { ViewCompat.setFitsSystemWindows(child, true); } int savedTop = child.getTop(); // First let the parent lay it out parent.onLayoutChild(child, layoutDirection); // Offset the bottom sheet mParentHeight = parent.getHeight(); int peekHeight; if (mPeekHeightAuto) { if (mPeekHeightMin == 0) { mPeekHeightMin = parent.getResources().getDimensionPixelSize( R.dimen.design_bottom_sheet_peek_height_min); } peekHeight = Math.max(mPeekHeightMin, mParentHeight - parent.getWidth() * 9 / 16); } else { peekHeight = mPeekHeight; } mMinOffset = Math.max(0, mParentHeight - child.getHeight()); mMaxOffset = Math.max(mParentHeight - peekHeight, mMinOffset); if (mState == STATE_EXPANDED) { ViewCompat.offsetTopAndBottom(child, mMinOffset); } else if (mHideable \u0026amp;\u0026amp; mState == STATE_HIDDEN) { ViewCompat.offsetTopAndBottom(child, mParentHeight); } else if (mState == STATE_COLLAPSED) { ViewCompat.offsetTopAndBottom(child, mMaxOffset); } else if (mState == STATE_DRAGGING || mState == STATE_SETTLING) { ViewCompat.offsetTopAndBottom(child, savedTop - child.getTop()); } if (mViewDragHelper == null) { mViewDragHelper = ViewDragHelper.create(parent, mDragCallback); } mViewRef = new WeakReference\u0026lt;\u0026gt;(child); mNestedScrollingChildRef = new WeakReference\u0026lt;\u0026gt;(findScrollingChild(child)); return true; } @Override public boolean onInterceptTouchEvent(CoordinatorLayout parent, V child, MotionEvent event) { if (!child.isShown()) { mIgnoreEvents = true; return false; } int action = event.getActionMasked(); // Record the velocity if (action == MotionEvent.ACTION_DOWN) { reset(); } if (mVelocityTracker == null) { mVelocityTracker = VelocityTracker.obtain(); } mVelocityTracker.addMovement(event); switch (action) { case MotionEvent.ACTION_UP: case MotionEvent.ACTION_CANCEL: mTouchingScrollingChild = false; mActivePointerId = MotionEvent.INVALID_POINTER_ID; // Reset the ignore flag if (mIgnoreEvents) { mIgnoreEvents = false; return false; } break; case MotionEvent.ACTION_DOWN: int initialX = (int) event.getX(); mInitialY = (int) event.getY(); View scroll = mNestedScrollingChildRef != null ? mNestedScrollingChildRef.get() : null; if (scroll != null \u0026amp;\u0026amp; parent.isPointInChildBounds(scroll, initialX, mInitialY)) { mActivePointerId = event.getPointerId(event.getActionIndex()); mTouchingScrollingChild = true; } mIgnoreEvents = mActivePointerId == MotionEvent.INVALID_POINTER_ID \u0026amp;\u0026amp; !parent.isPointInChildBounds(child, initialX, mInitialY); break; } if (!mIgnoreEvents \u0026amp;\u0026amp; mViewDragHelper.shouldInterceptTouchEvent(event)) { return true; } // We have to handle cases that the ViewDragHelper does not capture the bottom sheet because // it is not the top most view of its parent. This is not necessary when the touch event is // happening over the scrolling content as nested scrolling logic handles that case. View scroll = mNestedScrollingChildRef.get(); return action == MotionEvent.ACTION_MOVE \u0026amp;\u0026amp; scroll != null \u0026amp;\u0026amp; !mIgnoreEvents \u0026amp;\u0026amp; mState != STATE_DRAGGING \u0026amp;\u0026amp; !parent.isPointInChildBounds(scroll, (int) event.getX(), (int) event.getY()) \u0026amp;\u0026amp; Math.abs(mInitialY - event.getY()) \u0026gt; mViewDragHelper.getTouchSlop(); } @Override public boolean onTouchEvent(CoordinatorLayout parent, V child, MotionEvent event) { if (!child.isShown()) { return false; } int action = event.getActionMasked(); if (mState == STATE_DRAGGING \u0026amp;\u0026amp; action == MotionEvent.ACTION_DOWN) { return true; } if (mViewDragHelper != null) { mViewDragHelper.processTouchEvent(event); } // Record the velocity if (action == MotionEvent.ACTION_DOWN) { reset(); } if (mVelocityTracker == null) { mVelocityTracker = VelocityTracker.obtain(); } mVelocityTracker.addMovement(event); // The ViewDragHelper tries to capture only the top-most View. We have to explicitly tell it // to capture the bottom sheet in case it is not captured and the touch slop is passed. if (action == MotionEvent.ACTION_MOVE \u0026amp;\u0026amp; !mIgnoreEvents) { if (Math.abs(mInitialY - event.getY()) \u0026gt; mViewDragHelper.getTouchSlop()) { mViewDragHelper.captureChildView(child, event.getPointerId(event.getActionIndex())); } } return !mIgnoreEvents; } @Override public boolean onStartNestedScroll(CoordinatorLayout coordinatorLayout, V child, View directTargetChild, View target, int nestedScrollAxes) { mLastNestedScrollDy = 0; mNestedScrolled = false; return (nestedScrollAxes \u0026amp; ViewCompat.SCROLL_AXIS_VERTICAL) != 0; } @Override public void onNestedPreScroll(CoordinatorLayout coordinatorLayout, V child, View target, int dx, int dy, int[] consumed) { View scrollingChild = mNestedScrollingChildRef.get(); if (target != scrollingChild) { return; } int currentTop = child.getTop(); int newTop = currentTop - dy; if (dy \u0026gt; 0) { // Upward if (newTop \u0026lt; mMinOffset) { consumed[1] = currentTop - mMinOffset; ViewCompat.offsetTopAndBottom(child, -consumed[1]); setStateInternal(STATE_EXPANDED); } else { consumed[1] = dy; ViewCompat.offsetTopAndBottom(child, -dy); setStateInternal(STATE_DRAGGING); } } else if (dy \u0026lt; 0) { // Downward if (!target.canScrollVertically(-1)) { if (newTop \u0026lt;= mMaxOffset || mHideable) { consumed[1] = dy; ViewCompat.offsetTopAndBottom(child, -dy); setStateInternal(STATE_DRAGGING); } else { consumed[1] = currentTop - mMaxOffset; ViewCompat.offsetTopAndBottom(child, -consumed[1]); setStateInternal(STATE_COLLAPSED); } } } dispatchOnSlide(child.getTop()); mLastNestedScrollDy = dy; mNestedScrolled = true; } @Override public void onStopNestedScroll(CoordinatorLayout coordinatorLayout, V child, View target) { if (child.getTop() == mMinOffset) { setStateInternal(STATE_EXPANDED); return; } if (mNestedScrollingChildRef == null || target != mNestedScrollingChildRef.get() || !mNestedScrolled) { return; } int top; int targetState; if (mLastNestedScrollDy \u0026gt; 0) { top = mMinOffset; targetState = STATE_EXPANDED; } else if (mHideable \u0026amp;\u0026amp; shouldHide(child, getYVelocity())) { top = mParentHeight; targetState = STATE_HIDDEN; } else if (mLastNestedScrollDy == 0) { int currentTop = child.getTop(); if (Math.abs(currentTop - mMinOffset) \u0026lt; Math.abs(currentTop - mMaxOffset)) { top = mMinOffset; targetState = STATE_EXPANDED; } else { top = mMaxOffset; targetState = STATE_COLLAPSED; } } else { top = mMaxOffset; targetState = STATE_COLLAPSED; } if (mViewDragHelper.smoothSlideViewTo(child, child.getLeft(), top)) { setStateInternal(STATE_SETTLING); ViewCompat.postOnAnimation(child, new SettleRunnable(child, targetState)); } else { setStateInternal(targetState); } mNestedScrolled = false; } @Override public boolean onNestedPreFling(CoordinatorLayout coordinatorLayout, V child, View target, float velocityX, float velocityY) { return target == mNestedScrollingChildRef.get() \u0026amp;\u0026amp; (mState != STATE_EXPANDED || super.onNestedPreFling(coordinatorLayout, child, target, velocityX, velocityY)); } void invalidateScrollingChild() { final View scrollingChild = findScrollingChild(mViewRef.get()); mNestedScrollingChildRef = new WeakReference\u0026lt;\u0026gt;(scrollingChild); } /** * Sets the height of the bottom sheet when it is collapsed. * * @param peekHeight The height of the collapsed bottom sheet in pixels, or * {@link #PEEK_HEIGHT_AUTO} to configure the sheet to peek automatically * at 16:9 ratio keyline. * @attr ref android.support.design.R.styleable#BottomSheetBehavior_Layout_behavior_peekHeight */ public final void setPeekHeight(int peekHeight) { boolean layout = false; if (peekHeight == PEEK_HEIGHT_AUTO) { if (!mPeekHeightAuto) { mPeekHeightAuto = true; layout = true; } } else if (mPeekHeightAuto || mPeekHeight != peekHeight) { mPeekHeightAuto = false; mPeekHeight = Math.max(0, peekHeight); mMaxOffset = mParentHeight - peekHeight; layout = true; } if (layout \u0026amp;\u0026amp; mState == STATE_COLLAPSED \u0026amp;\u0026amp; mViewRef != null) { V view = mViewRef.get(); if (view != null) { view.requestLayout(); } } } /** * Gets the height of the bottom sheet when it is collapsed. * * @return The height of the collapsed bottom sheet in pixels, or {@link #PEEK_HEIGHT_AUTO} * if the sheet is configured to peek automatically at 16:9 ratio keyline * @attr ref android.support.design.R.styleable#BottomSheetBehavior_Layout_behavior_peekHeight */ public final int getPeekHeight() { return mPeekHeightAuto ? PEEK_HEIGHT_AUTO : mPeekHeight; } /** * Sets whether this bottom sheet can hide when it is swiped down. * * @param hideable {@code true} to make this bottom sheet hideable. * @attr ref android.support.design.R.styleable#BottomSheetBehavior_Layout_behavior_hideable */ public void setHideable(boolean hideable) { mHideable = hideable; } /** * Gets whether this bottom sheet can hide when it is swiped down. * * @return {@code true} if this bottom sheet can hide. * @attr ref android.support.design.R.styleable#BottomSheetBehavior_Layout_behavior_hideable */ public boolean isHideable() { return mHideable; } /** * Sets whether this bottom sheet should skip the collapsed state when it is being hidden * after it is expanded once. Setting this to true has no effect unless the sheet is hideable. * * @param skipCollapsed True if the bottom sheet should skip the collapsed state. * @attr ref android.support.design.R.styleable#BottomSheetBehavior_Layout_behavior_skipCollapsed */ public void setSkipCollapsed(boolean skipCollapsed) { mSkipCollapsed = skipCollapsed; } /** * Sets whether this bottom sheet should skip the collapsed state when it is being hidden * after it is expanded once. * * @return Whether the bottom sheet should skip the collapsed state. * @attr ref android.support.design.R.styleable#BottomSheetBehavior_Layout_behavior_skipCollapsed */ public boolean getSkipCollapsed() { return mSkipCollapsed; } /** * Sets a callback to be notified of bottom sheet events. * * @param callback The callback to notify when bottom sheet events occur. */ public void setBottomSheetCallback(BottomSheetCallback callback) { mCallback = callback; } /** * Sets the state of the bottom sheet. The bottom sheet will transition to that state with * animation. * * @param state One of {@link #STATE_COLLAPSED}, {@link #STATE_EXPANDED}, or * {@link #STATE_HIDDEN}. */ public final void setState(final @State int state) { if (state == mState) { return; } if (mViewRef == null) { // The view is not laid out yet; modify mState and let onLayoutChild handle it later if (state == STATE_COLLAPSED || state == STATE_EXPANDED || (mHideable \u0026amp;\u0026amp; state == STATE_HIDDEN)) { mState = state; } return; } final V child = mViewRef.get(); if (child == null) { return; } // Start the animation; wait until a pending layout if there is one. ViewParent parent = child.getParent(); if (parent != null \u0026amp;\u0026amp; parent.isLayoutRequested() \u0026amp;\u0026amp; ViewCompat.isAttachedToWindow(child)) { child.post(new Runnable() { @Override public void run() { startSettlingAnimation(child, state); } }); } else { startSettlingAnimation(child, state); } } /** * Gets the current state of the bottom sheet. * * @return One of {@link #STATE_EXPANDED}, {@link #STATE_COLLAPSED}, {@link #STATE_DRAGGING}, * {@link #STATE_SETTLING}, and {@link #STATE_HIDDEN}. */ @State public final int getState() { return mState; } void setStateInternal(@State int state) { if (mState == state) { return; } mState = state; View bottomSheet = mViewRef.get(); if (bottomSheet != null \u0026amp;\u0026amp; mCallback != null) { mCallback.onStateChanged(bottomSheet, state); } } private void reset() { mActivePointerId = ViewDragHelper.INVALID_POINTER; if (mVelocityTracker != null) { mVelocityTracker.recycle(); mVelocityTracker = null; } } boolean shouldHide(View child, float yvel) { if (mSkipCollapsed) { return true; } if (child.getTop() \u0026lt; mMaxOffset) { // It should not hide, but collapse. return false; } final float newTop = child.getTop() + yvel * HIDE_FRICTION; return Math.abs(newTop - mMaxOffset) / (float) mPeekHeight \u0026gt; HIDE_THRESHOLD; } @VisibleForTesting private View findScrollingChild(View view) { if (ViewCompat.isNestedScrollingEnabled(view)) { return view; } if (view instanceof ViewPager) { ViewPager viewPager = (ViewPager) view; View currentViewPagerChild = ViewPagerUtils.getCurrentView(viewPager); if (currentViewPagerChild == null) { return null; } View scrollingChild = findScrollingChild(currentViewPagerChild); if (scrollingChild != null) { return scrollingChild; } } else if (view instanceof ViewGroup) { ViewGroup group = (ViewGroup) view; for (int i = 0, count = group.getChildCount(); i \u0026lt; count; i++) { View scrollingChild = findScrollingChild(group.getChildAt(i)); if (scrollingChild != null) { return scrollingChild; } } } return null; } private float getYVelocity() { mVelocityTracker.computeCurrentVelocity(1000, mMaximumVelocity); return mVelocityTracker.getYVelocity(mActivePointerId); } void startSettlingAnimation(View child, int state) { int top; if (state == STATE_COLLAPSED) { top = mMaxOffset; } else if (state == STATE_EXPANDED) { top = mMinOffset; } else if (mHideable \u0026amp;\u0026amp; state == STATE_HIDDEN) { top = mParentHeight; } else { throw new IllegalArgumentException(\u0026#34;Illegal state argument: \u0026#34; + state); } if (mViewDragHelper.smoothSlideViewTo(child, child.getLeft(), top)) { setStateInternal(STATE_SETTLING); ViewCompat.postOnAnimation(child, new SettleRunnable(child, state)); } else { setStateInternal(state); } } private final ViewDragHelper.Callback mDragCallback = new ViewDragHelper.Callback() { @Override public boolean tryCaptureView(View child, int pointerId) { if (mState == STATE_DRAGGING) { return false; } if (mTouchingScrollingChild) { return false; } if (mState == STATE_EXPANDED \u0026amp;\u0026amp; mActivePointerId == pointerId) { View scroll = mNestedScrollingChildRef.get(); if (scroll != null \u0026amp;\u0026amp; scroll.canScrollVertically(-1)) { // Let the content scroll up return false; } } return mViewRef != null \u0026amp;\u0026amp; mViewRef.get() == child; } @Override public void onViewPositionChanged(View changedView, int left, int top, int dx, int dy) { dispatchOnSlide(top); } @Override public void onViewDragStateChanged(int state) { if (state == ViewDragHelper.STATE_DRAGGING) { setStateInternal(STATE_DRAGGING); } } @Override public void onViewReleased(View releasedChild, float xvel, float yvel) { int top; @State int targetState; if (yvel \u0026lt; 0) { // Moving up top = mMinOffset; targetState = STATE_EXPANDED; } else if (mHideable \u0026amp;\u0026amp; shouldHide(releasedChild, yvel)) { top = mParentHeight; targetState = STATE_HIDDEN; } else if (yvel == 0.f) { int currentTop = releasedChild.getTop(); if (Math.abs(currentTop - mMinOffset) \u0026lt; Math.abs(currentTop - mMaxOffset)) { top = mMinOffset; targetState = STATE_EXPANDED; } else { top = mMaxOffset; targetState = STATE_COLLAPSED; } } else { top = mMaxOffset; targetState = STATE_COLLAPSED; } if (mViewDragHelper.settleCapturedViewAt(releasedChild.getLeft(), top)) { setStateInternal(STATE_SETTLING); ViewCompat.postOnAnimation(releasedChild, new SettleRunnable(releasedChild, targetState)); } else { setStateInternal(targetState); } } @Override public int clampViewPositionVertical(View child, int top, int dy) { return MathUtils.clamp(top, mMinOffset, mHideable ? mParentHeight : mMaxOffset); } @Override public int clampViewPositionHorizontal(View child, int left, int dx) { return child.getLeft(); } @Override public int getViewVerticalDragRange(View child) { if (mHideable) { return mParentHeight - mMinOffset; } else { return mMaxOffset - mMinOffset; } } }; void dispatchOnSlide(int top) { View bottomSheet = mViewRef.get(); if (bottomSheet != null \u0026amp;\u0026amp; mCallback != null) { if (top \u0026gt; mMaxOffset) { mCallback.onSlide(bottomSheet, (float) (mMaxOffset - top) / (mParentHeight - mMaxOffset)); } else { mCallback.onSlide(bottomSheet, (float) (mMaxOffset - top) / ((mMaxOffset - mMinOffset))); } } } @VisibleForTesting int getPeekHeightMin() { return mPeekHeightMin; } private class SettleRunnable implements Runnable { private final View mView; @State private final int mTargetState; SettleRunnable(View view, @State int targetState) { mView = view; mTargetState = targetState; } @Override public void run() { if (mViewDragHelper != null \u0026amp;\u0026amp; mViewDragHelper.continueSettling(true)) { ViewCompat.postOnAnimation(mView, this); } else { setStateInternal(mTargetState); } } } protected static class SavedState extends AbsSavedState { @State final int state; public SavedState(Parcel source) { this(source, null); } public SavedState(Parcel source, ClassLoader loader) { super(source, loader); //noinspection ResourceType state = source.readInt(); } public SavedState(Parcelable superState, @State int state) { super(superState); this.state = state; } @Override public void writeToParcel(Parcel out, int flags) { super.writeToParcel(out, flags); out.writeInt(state); } public static final Creator\u0026lt;SavedState\u0026gt; CREATOR = new ClassLoaderCreator\u0026lt;SavedState\u0026gt;() { @Override public SavedState createFromParcel(Parcel in, ClassLoader loader) { return new SavedState(in, loader); } @Override public SavedState createFromParcel(Parcel in) { return new SavedState(in, null); } @Override public SavedState[] newArray(int size) { return new SavedState[size]; } }; } /** * A utility function to get the {@link ViewPagerBottomSheetBehavior} associated with the {@code view}. * * @param view The {@link View} with {@link ViewPagerBottomSheetBehavior}. * @return The {@link ViewPagerBottomSheetBehavior} associated with the {@code view}. */ @SuppressWarnings(\u0026#34;unchecked\u0026#34;) public static \u0026lt;V extends View\u0026gt; ViewPagerBottomSheetBehavior\u0026lt;V\u0026gt; from(V view) { ViewGroup.LayoutParams params = view.getLayoutParams(); if (!(params instanceof CoordinatorLayout.LayoutParams)) { throw new IllegalArgumentException(\u0026#34;The view is not a child of CoordinatorLayout\u0026#34;); } CoordinatorLayout.Behavior behavior = ((CoordinatorLayout.LayoutParams) params) .getBehavior(); if (!(behavior instanceof ViewPagerBottomSheetBehavior)) { throw new IllegalArgumentException( \u0026#34;The view is not associated with ViewPagerBottomSheetBehavior\u0026#34;); } return (ViewPagerBottomSheetBehavior\u0026lt;V\u0026gt;) behavior; } } public class ViewPagerUtils { public static View getCurrentView(ViewPager viewPager) { final int currentItem = viewPager.getCurrentItem(); for (int i = 0; i \u0026lt; viewPager.getChildCount(); i++) { final View child = viewPager.getChildAt(i); final ViewPager.LayoutParams layoutParams = (ViewPager.LayoutParams) child.getLayoutParams(); try { Field field = layoutParams.getClass().getDeclaredField(\u0026#34;position\u0026#34;); field.setAccessible(true); int position = field.getInt(layoutParams); if (!layoutParams.isDecor \u0026amp;\u0026amp; currentItem == position) { return child; } } catch (NoSuchFieldException e) { e.printStackTrace(); } catch (IllegalAccessException e) { e.printStackTrace(); } } return null; } } public final class BottomSheetUtils { public static void setupViewPager(ViewPager viewPager) { final View bottomSheetParent = findBottomSheetParent(viewPager); if (bottomSheetParent != null) { viewPager.addOnPageChangeListener(new BottomSheetViewPagerListener(viewPager, bottomSheetParent)); } } private static class BottomSheetViewPagerListener extends ViewPager.SimpleOnPageChangeListener { private final ViewPager viewPager; private final ViewPagerBottomSheetBehavior\u0026lt;View\u0026gt; behavior; private BottomSheetViewPagerListener(ViewPager viewPager, View bottomSheetParent) { this.viewPager = viewPager; this.behavior = ViewPagerBottomSheetBehavior.from(bottomSheetParent); } @Override public void onPageSelected(int position) { viewPager.post(new Runnable() { @Override public void run() { behavior.invalidateScrollingChild(); } }); } } private static View findBottomSheetParent(final View view) { View current = view; while (current != null) { final ViewGroup.LayoutParams params = current.getLayoutParams(); if (params instanceof CoordinatorLayout.LayoutParams \u0026amp;\u0026amp; ((CoordinatorLayout.LayoutParams) params).getBehavior() instanceof ViewPagerBottomSheetBehavior) { return current; } final ViewParent parent = current.getParent(); current = parent == null || !(parent instanceof View) ? null : (View) parent; } return null; } } \u0026lt;!-- design_view_pager_bottom_sheet_dialog.xml --\u0026gt; \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;!-- ~ Copyright (C) 2015 The Android Open Source Project ~ ~ Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); ~ you may not use this file except in compliance with the License. ~ You may obtain a copy of the License at ~ ~ http://www.apache.org/licenses/LICENSE-2.0 ~ ~ Unless required by applicable law or agreed to in writing, software ~ distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ~ See the License for the specific language governing permissions and ~ limitations under the License. --\u0026gt; \u0026lt;androidx.coordinatorlayout.widget.CoordinatorLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; xmlns:app=\u0026#34;http://schemas.android.com/apk/res-auto\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34;\u0026gt; \u0026lt;View android:id=\u0026#34;@+id/touch_outside\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:soundEffectsEnabled=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;FrameLayout android:id=\u0026#34;@+id/design_bottom_sheet\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_gravity=\u0026#34;center_horizontal|top\u0026#34; android:clickable=\u0026#34;true\u0026#34; app:layout_behavior=\u0026#34;.behavior.ViewPagerBottomSheetBehavior\u0026#34; style=\u0026#34;?attr/bottomSheetStyle\u0026#34;/\u0026gt; \u0026lt;/androidx.coordinatorlayout.widget.CoordinatorLayout\u0026gt; 然后基于上述文件自定义BottomSheetDialog ViewPagerBottomSheetDialog.java以及ViewPagerBottomSheetDialogFragment.java\npublic class ViewPagerBottomSheetDialog extends AppCompatDialog { private ViewPagerBottomSheetBehavior\u0026lt;FrameLayout\u0026gt; mBehavior; private boolean mCancelable = true; private boolean mCanceledOnTouchOutside = true; private boolean mCanceledOnTouchOutsideSet; private boolean mCreated; // 在这个自定义的Dialog中加入了设置高度的功能 private int mPeekHeight; private int mMaxHeight; private Window mWindow; private ViewPagerBottomSheetBehavior mBottomSheetBehavior; public ViewPagerBottomSheetDialog(@NonNull Context context) { super(context, getThemeResId(context, 0)); init(1000,1000); // } public ViewPagerBottomSheetDialog(@NonNull Context context, @StyleRes int theme) { super(context, getThemeResId(context, theme)); // We hide the title bar for any style configuration. Otherwise, there will be a gap // above the bottom sheet when it is expanded. supportRequestWindowFeature(Window.FEATURE_NO_TITLE); init(1000, 1000); } public ViewPagerBottomSheetDialog(@NonNull Context context, int peekHeight, int maxHeight) { this(context, 0, peekHeight, maxHeight); init(peekHeight, maxHeight); } public ViewPagerBottomSheetDialog(@NonNull Context context, @StyleRes int theme, int peekHeight, int maxHeight) { super(context, getThemeResId(context, theme)); // We hide the title bar for any style configuration. Otherwise, there will be a gap // above the bottom sheet when it is expanded. supportRequestWindowFeature(Window.FEATURE_NO_TITLE); init(peekHeight, maxHeight); } protected ViewPagerBottomSheetDialog(@NonNull Context context, boolean cancelable, DialogInterface.OnCancelListener cancelListener, int peekHeight, int maxHeight) { super(context, cancelable, cancelListener); supportRequestWindowFeature(Window.FEATURE_NO_TITLE); mCancelable = cancelable; init(peekHeight, maxHeight); } private void init(int peekHeight, int maxHeight) { mWindow = getWindow(); mPeekHeight = peekHeight; mMaxHeight = maxHeight; } @Override public void setContentView(@LayoutRes int layoutResId) { super.setContentView(wrapInBottomSheet(layoutResId, null, null)); } @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); getWindow().setLayout( ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT); setPeekHeight(); setMaxHeight(); mCreated = true; } public void setPeekHeight(int peekHeight) { mPeekHeight = peekHeight; if (mCreated) { setPeekHeight(); } } public void setMaxHeight(int height) { mMaxHeight = height; if (mCreated) { setMaxHeight(); } } private void setPeekHeight() { if (mPeekHeight \u0026lt;= 0) { return; } if (getBottomSheetBehavior() != null) { mBottomSheetBehavior.setPeekHeight(mPeekHeight); } } private void setMaxHeight() { if (mMaxHeight \u0026lt;= 0) { return; } // 设置高度的核心函数 mWindow.setLayout(ViewGroup.LayoutParams.MATCH_PARENT, mMaxHeight); mWindow.setGravity(Gravity.BOTTOM); } private ViewPagerBottomSheetBehavior getBottomSheetBehavior() { if (mBottomSheetBehavior != null) { return mBottomSheetBehavior; } View view = mWindow.findViewById(R.id.design_bottom_sheet); // setContentView() 没有调用 if (view == null) { return null; } mBottomSheetBehavior = ViewPagerBottomSheetBehavior.from(view); return mBottomSheetBehavior; } @Override public void setContentView(View view) { super.setContentView(wrapInBottomSheet(0, view, null)); } @Override public void setContentView(View view, ViewGroup.LayoutParams params) { super.setContentView(wrapInBottomSheet(0, view, params)); } @Override public void setCancelable(boolean cancelable) { super.setCancelable(cancelable); if (mCancelable != cancelable) { mCancelable = cancelable; if (mBehavior != null) { mBehavior.setHideable(cancelable); } } } @Override public void setCanceledOnTouchOutside(boolean cancel) { super.setCanceledOnTouchOutside(cancel); if (cancel \u0026amp;\u0026amp; !mCancelable) { mCancelable = true; } mCanceledOnTouchOutside = cancel; mCanceledOnTouchOutsideSet = true; } private View wrapInBottomSheet(int layoutResId, View view, ViewGroup.LayoutParams params) { final CoordinatorLayout coordinator = (CoordinatorLayout) View.inflate(getContext(), R.layout.design_view_pager_bottom_sheet_dialog, null); if (layoutResId != 0 \u0026amp;\u0026amp; view == null) { view = getLayoutInflater().inflate(layoutResId, coordinator, false); } FrameLayout bottomSheet = (FrameLayout) coordinator.findViewById(R.id.design_bottom_sheet); mBehavior = ViewPagerBottomSheetBehavior.from(bottomSheet); mBehavior.setBottomSheetCallback(mBottomSheetCallback); mBehavior.setHideable(mCancelable); if (params == null) { bottomSheet.addView(view); } else { bottomSheet.addView(view, params); } // We treat the CoordinatorLayout as outside the dialog though it is technically inside coordinator.findViewById(R.id.touch_outside).setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { if (mCancelable \u0026amp;\u0026amp; isShowing() \u0026amp;\u0026amp; shouldWindowCloseOnTouchOutside()) { cancel(); } } }); return coordinator; } private boolean shouldWindowCloseOnTouchOutside() { if (!mCanceledOnTouchOutsideSet) { if (Build.VERSION.SDK_INT \u0026lt; 11) { mCanceledOnTouchOutside = true; } else { TypedArray a = getContext().obtainStyledAttributes( new int[]{android.R.attr.windowCloseOnTouchOutside}); mCanceledOnTouchOutside = a.getBoolean(0, true); a.recycle(); } mCanceledOnTouchOutsideSet = true; } return mCanceledOnTouchOutside; } private static int getThemeResId(Context context, int themeId) { if (themeId == 0) { // If the provided theme is 0, then retrieve the dialogTheme from our theme TypedValue outValue = new TypedValue(); if (context.getTheme().resolveAttribute( R.attr.bottomSheetDialogTheme, outValue, true)) { themeId = outValue.resourceId; } else { // bottomSheetDialogTheme is not provided; we default to our light theme themeId = R.style.Theme_Design_Light_BottomSheetDialog; } } return themeId; } private ViewPagerBottomSheetBehavior.BottomSheetCallback mBottomSheetCallback = new ViewPagerBottomSheetBehavior.BottomSheetCallback() { @Override public void onStateChanged(@NonNull View bottomSheet, @ViewPagerBottomSheetBehavior.State int newState) { if (newState == ViewPagerBottomSheetBehavior.STATE_HIDDEN) { dismiss(); } } @Override public void onSlide(@NonNull View bottomSheet, float slideOffset) { } }; } public class ViewPagerBottomSheetDialogFragment extends AppCompatDialogFragment { @Override public Dialog onCreateDialog(Bundle savedInstanceState) { return new ViewPagerBottomSheetDialog(getContext(), getTheme()); } } 在Activity中使用\npublic class FourthActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_fourth); List\u0026lt;EmojiItem\u0026gt; data = new ArrayList\u0026lt;\u0026gt;(); String[] arr = new String[]{ \u0026#34;\\uD83D\\uDC4D\u0026#34;, \u0026#34;❤️\u0026#34;, \u0026#34;\\uD83C\\uDF89\u0026#34;, \u0026#34;\\uD83D\\uDE02\u0026#34;, \u0026#34;\\uD83D\\uDC4F\u0026#34;, \u0026#34;\\uD83D\\uDE0E\u0026#34; }; for (int i = 0; i \u0026lt; arr.length; i++) { data.add(new EmojiItem(arr[i], i + 10, null)); } // 多了setMaxHeight(1600)和setPeekHeight(1000) findViewById(R.id.button4).setOnClickListener(v -\u0026gt; ListBottomSheetDialog.builder(FourthActivity.this) .setEmojiItemList(data) .setMaxHeight(1600) .setPeekHeight(1000) .setOffscreenPageLimit(5) .setEnableScroll(true) .show(getSupportFragmentManager())); } } 结果如下，但是如果BottomSheetDialog官方将这个bug修复了，那么就不需要修改这么多的文件，而且自定义的ViewPagerBottomSheetBehavior只是复制了BottomSheetBehavior中的部分代码，可能存在其他问题尚未发现。\n参考： Material Design Getting started with Material Components for Android ","permalink":"https://zhoutao822.github.io/posts/bottomsheetdialog/","summary":"BottomSheetDialog使用以及相关问题","title":"BottomSheetDialog"}]