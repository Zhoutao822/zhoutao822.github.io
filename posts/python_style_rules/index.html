<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Python风格规范 | Tao's Notes</title><meta name=keywords content="Python"><meta name=description content="Python风格规范总结"><meta name=author content="Me"><link rel=canonical href=https://zhoutao822.github.io/posts/python_style_rules/><meta name=google-site-verification content="Tao"><meta name=yandex-verification content="Tao"><meta name=msvalidate.01 content="Tao"><link crossorigin=anonymous href=/assets/css/stylesheet.min.c88963fe2d79462000fd0fb1b3737783c32855d340583e4523343f8735c787f0.css integrity="sha256-yIlj/i15RiAA/Q+xs3N3g8MoVdNAWD5FIzQ/hzXHh/A=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.b95bacdc39e37a332a9f883b1e78be4abc1fdca2bc1f2641f55e3cd3dabd4d61.js integrity="sha256-uVus3DnjejMqn4g7Hni+Srwf3KK8HyZB9V4809q9TWE=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://zhoutao822.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://zhoutao822.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://zhoutao822.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://zhoutao822.github.io/apple-touch-icon.png><link rel=mask-icon href=https://zhoutao822.github.io/favicon.ico><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.103.1"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="Python风格规范"><meta property="og:description" content="Python风格规范总结"><meta property="og:type" content="article"><meta property="og:url" content="https://zhoutao822.github.io/posts/python_style_rules/"><meta property="og:image" content="https://zhoutao822.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2019-06-14T22:04:50+08:00"><meta property="article:modified_time" content="2019-06-14T22:04:50+08:00"><meta property="og:site_name" content="Tao's Notes"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://zhoutao822.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Python风格规范"><meta name=twitter:description content="Python风格规范总结"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://zhoutao822.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Python风格规范","item":"https://zhoutao822.github.io/posts/python_style_rules/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Python风格规范","name":"Python风格规范","description":"Python风格规范总结","keywords":["Python"],"articleBody":"分号 不要在行尾加分号, 也不要用分号将两条命令放在同一行.\n行长度 每行不超过80个字符\n例外:\n长的导入模块语句 注释里的URL 不要使用反斜杠连接行.\nPython会将 圆括号, 中括号和花括号中的行隐式的连接起来 , 你可以利用这个特点. 如果需要, 你可以在表达式外围增加一对额外的圆括号.\nYes: foo_bar(self, width, height, color='black', design=None, x='foo', emphasis=None, highlight=0) if (width == 0 and height == 0 and color == 'red' and emphasis == 'strong'): 如果一个文本字符串在一行放不下, 可以使用圆括号来实现隐式行连接:\nx = ('This will build a very long long ' 'long long long long long long string') 在注释中，如果必要，将长的URL放在一行上。\nYes: # See details at # http://www.example.com/us/developer/documentation/api/content/v2.0/csv_file_name_extension_full_specification.html No: # See details at # http://www.example.com/us/developer/documentation/api/content/\\ # v2.0/csv_file_name_extension_full_specification.html 括号 Yes: if foo: bar() while x: x = bar() if x and y: bar() if not x: bar() return foo for (x, y) in dict.items(): ... No: if (x): bar() if not(x): bar() return (foo) 缩进 用4个空格来缩进代码\n绝对不要用tab, 也不要tab和空格混用. 对于行连接的情况, 你应该要么垂直对齐换行的元素, 或者使用4空格的悬挂式缩进(这时第一行不应该有参数):\nYes: # 与起始变量对齐 foo = long_function_name(var_one, var_two, var_three, var_four) # 字典中与起始值对齐 foo = { long_dictionary_key: value1 + value2, ... } # 4 个空格缩进，第一行不需要 foo = long_function_name( var_one, var_two, var_three, var_four) # 字典中 4 个空格缩进 foo = { long_dictionary_key: long_dictionary_value, ... } No: # 第一行有空格是禁止的 foo = long_function_name(var_one, var_two, var_three, var_four) # 2 个空格是禁止的 foo = long_function_name( var_one, var_two, var_three, var_four) # 字典中没有处理缩进 foo = { long_dictionary_key: long_dictionary_value, ... } 空行 顶级定义之间空两行, 方法定义之间空一行\n顶级定义之间空两行, 比如函数或者类定义. 方法定义, 类定义与第一个方法之间, 都应该空一行. 函数或方法中, 某些地方要是你觉得合适, 就空一行.\n空格 按照标准的排版规范来使用标点两边的空格\n括号内不要有空格.\n按照标准的排版规范来使用标点两边的空格\nYes: spam(ham[1], {eggs: 2}, []) No: spam( ham[ 1 ], { eggs: 2 }, [ ] ) 不要在逗号, 分号, 冒号前面加空格, 但应该在它们后面加(除了在行尾).\nYes: if x == 4: print x, y x, y = y, x No: if x == 4 : print x , y x , y = y , x 参数列表, 索引或切片的左括号前不应加空格.\nYes: spam(1) no: spam (1) Yes: dict['key'] = list[index] No: dict ['key'] = list [index] 在二元操作符两边都加上一个空格, 比如赋值(=), 比较(==, \u003c, \u003e, !=, \u003c\u003e, \u003c=, \u003e=, in, not in, is, is not), 布尔(and, or, not). 至于算术操作符两边的空格该如何使用, 需要你自己好好判断. 不过两侧务必要保持一致.\nYes: x == 1 No: x\u003c1 当=用于指示关键字参数或默认参数值时, 不要在其两侧使用空格.\nYes: def complex(real, imag=0.0): return magic(r=real, i=imag) No: def complex(real, imag = 0.0): return magic(r = real, i = imag) 不要用空格来垂直对齐多行间的标记, 因为这会成为维护的负担(适用于:, #, =等):\nYes: foo = 1000 # 注释 long_name = 2 # 注释不需要对齐 dictionary = { \"foo\": 1, \"long_name\": 2, } No: foo = 1000 # 注释 long_name = 2 # 注释不需要对齐 dictionary = { \"foo\" : 1, \"long_name\": 2, } Hashbang 大部分.py文件不必以#!作为文件的开始. 根据 PEP-394 , 程序的main文件应该以 #!/usr/bin/python2或者 #!/usr/bin/python3开始.\n注释 确保对模块, 函数, 方法和行内注释使用正确的风格\n文档字符串\nPython有一种独一无二的的注释方式: 使用文档字符串. 文档字符串是包, 模块, 类或函数里的第一个语句. 这些字符串可以通过对象的__doc__成员被自动提取, 并且被pydoc所用. (你可以在你的模块上运行pydoc试一把, 看看它长什么样). 我们对文档字符串的惯例是使用三重双引号\"\"\"( PEP-257 ). 一个文档字符串应该这样组织: 首先是一行以句号, 问号或惊叹号结尾的概述(或者该文档字符串单纯只有一行). 接着是一个空行. 接着是文档字符串剩下的部分, 它应该与文档字符串的第一行的第一个引号对齐. 下面有更多文档字符串的格式化规范. 模块\n每个文件应该包含一个许可样板. 根据项目使用的许可(例如, Apache 2.0, BSD, LGPL, GPL), 选择合适的样板. 函数和方法\n下文所指的函数,包括函数, 方法, 以及生成器. 一个函数必须要有文档字符串, 除非它满足以下条件: 1. 外部不可见 2. 非常短小 3. 简单明了 文档字符串应该包含函数做什么, 以及输入和输出的详细描述. 通常, 不应该描述\"怎么做\", 除非是一些复杂的算法. 文档字符串应该提供足够的信息, 当别人编写代码调用该函数时, 他不需要看一行代码, 只要看文档字符串就可以了. 对于复杂的代码, 在代码旁边加注释会比使用文档字符串更有意义. 关于函数的几个方面应该在特定的小节中进行描述记录， 这几个方面如下文所述. 每节应该以一个标题行开始. 标题行以冒号结尾. 除标题行外, 节的其他内容应被缩进2个空格. Args: 列出每个参数的名字, 并在名字后使用一个冒号和一个空格, 分隔对该参数的描述.如果描述太长超过了单行80字符,使用2或者4个空格的悬挂缩进(与文件其他部分保持一致). 描述应该包括所需的类型和含义. 如果一个函数接受*foo(可变长度参数列表)或者**bar (任意关键字参数), 应该详细列出*foo和**bar. Returns: (或者 Yields: 用于生成器) 描述返回值的类型和语义. 如果函数返回None, 这一部分可以省略. Raises: 列出与接口有关的所有异常. def fetch_bigtable_rows(big_table, keys, other_silly_variable=None): \"\"\"Fetches rows from a Bigtable. Retrieves rows pertaining to the given keys from the Table instance represented by big_table. Silly things may happen if other_silly_variable is not None. Args: big_table: An open Bigtable Table instance. keys: A sequence of strings representing the key of each table row to fetch. other_silly_variable: Another optional variable, that has a much longer name than the other args, and which does nothing. Returns: A dict mapping keys to the corresponding table row data fetched. Each row is represented as a tuple of strings. For example: {'Serak': ('Rigel VII', 'Preparer'), 'Zim': ('Irk', 'Invader'), 'Lrrr': ('Omicron Persei 8', 'Emperor')} If a key from the keys argument is missing from the dictionary, then that row was not found in the table. Raises: IOError: An error occurred accessing the bigtable.Table object. \"\"\" pass 类\n类应该在其定义下有一个用于描述该类的文档字符串. 如果你的类有公共属性(Attributes), 那么文档中应该有一个属性(Attributes)段. 并且应该遵守和函数参数相同的格式. class SampleClass(object): \"\"\"Summary of class here. Longer class information.... Longer class information.... Attributes: likes_spam: A boolean indicating if we like SPAM or not. eggs: An integer count of the eggs we have laid. \"\"\" def __init__(self, likes_spam=False): \"\"\"Inits SampleClass with blah.\"\"\" self.likes_spam = likes_spam self.eggs = 0 def public_method(self): \"\"\"Performs operation blah.\"\"\" 块注释和行注释\n最需要写注释的是代码中那些技巧性的部分. 如果你在下次 代码审查 的时候必须解释一下, 那么你应该现在就给它写注释. 对于复杂的操作, 应该在其操作开始前写上若干行注释. 对于不是一目了然的代码, 应在其行尾添加注释. # We use a weighted dictionary search to find out where i is in # the array. We extrapolate position based on the largest num # in the array and the array size and then do binary search to # get the exact number. if i \u0026 (i-1) == 0: # true iff i is a power of 2 为了提高可读性, 注释应该至少离开代码2个空格. 另一方面, 绝不要描述代码. 假设阅读代码的人比你更懂Python, 他只是不知道你的代码要做什么. # BAD COMMENT: Now go through the b array and make sure whenever i occurs # the next element is i+1 类 如果一个类不继承自其它类, 就显式的从object继承. 嵌套类也一样.\nYes: class SampleClass(object): pass class OuterClass(object): class InnerClass(object): pass class ChildClass(ParentClass): \"\"\"Explicitly inherits from another class already.\"\"\" No: class SampleClass: pass class OuterClass: class InnerClass: pass 继承自 object 是为了使属性(properties)正常工作, 并且这样可以保护你的代码, 使其不受Python 3000的一个特殊的潜在不兼容性影响. 这样做也定义了一些特殊的方法, 这些方法实现了对象的默认语义, 包括 __new__, __init__, __delattr__, __getattribute__, __setattr__, __hash__, __repr__, and __str__ .\n字符串 Yes: x = a + b x = '%s, %s!' % (imperative, expletive) x = '{}, {}!'.format(imperative, expletive) x = 'name: %s; score: %d' % (name, n) x = 'name: {}; score: {}'.format(name, n) No: x = '%s%s' % (a, b) # use + in this case x = '{}{}'.format(a, b) # use + in this case x = imperative + ', ' + expletive + '!' x = 'name: ' + name + '; score: ' + str(n) 避免在循环中用+和+=操作符来累加字符串. 由于字符串是不可变的, 这样做会创建不必要的临时对象, 并且导致二次方而不是线性的运行时间. 作为替代方案, 你可以将每个子串加入列表, 然后在循环结束后用 .join 连接列表. (也可以将每个子串写入一个 cStringIO.StringIO 缓存中.)\nYes: items = [''] for last_name, first_name in employee_list: items.append('%s, %s' % (last_name, first_name)) items.append('') employee_table = ''.join(items) No: employee_table = '' for last_name, first_name in employee_list: employee_table += '%s, %s' % (last_name, first_name) employee_table += '' 在同一个文件中, 保持使用字符串引号的一致性. 使用单引号’或者双引号\"之一用以引用字符串, 并在同一文件中沿用. 在字符串内可以使用另外一种引号, 以避免在字符串中使用. PyLint已经加入了这一检查.\nYes: Python('Why are you hiding your eyes?') Gollum(\"I'm scared of lint errors.\") Narrator('\"Good!\" thought a happy Python reviewer.') No: Python(\"Why are you hiding your eyes?\") Gollum('The lint. It burns. It burns us.') Gollum(\"Always the great lint. Watching. Watching.\") 为多行字符串使用三重双引号\"““而非三重单引号’’’. 当且仅当项目中使用单引号’来引用字符串时, 才可能会使用三重’‘‘为非文档字符串的多行字符串来标识引用. 文档字符串必须使用三重双引号””\". 不过要注意, 通常用隐式行连接更清晰, 因为多行字符串与程序其他部分的缩进方式不一致.\nYes: print (\"This is much nicer.\\n\" \"Do it this way.\\n\") No: print \"\"\"This is pretty ugly. Don't do this. \"\"\" 文件和sockets 在文件和sockets结束时, 显式的关闭它.\n除文件外, sockets或其他类似文件的对象在没有必要的情况下打开, 会有许多副作用, 例如:\n它们可能会消耗有限的系统资源, 如文件描述符. 如果这些资源在使用后没有及时归还系统, 那么用于处理这些对象的代码会将资源消耗殆尽. 持有文件将会阻止对于文件的其他诸如移动、删除之类的操作. 仅仅是从逻辑上关闭文件和sockets, 那么它们仍然可能会被其共享的程序在无意中进行读或者写操作. 只有当它们真正被关闭后, 对于它们尝试进行读或者写操作将会跑出异常, 并使得问题快速显现出来. 而且, 幻想当文件对象析构时, 文件和sockets会自动关闭, 试图将文件对象的生命周期和文件的状态绑定在一起的想法, 都是不现实的. 因为有如下原因:\n没有任何方法可以确保运行环境会真正的执行文件的析构. 不同的Python实现采用不同的内存管理技术, 比如延时垃圾处理机制. 延时垃圾处理机制可能会导致对象生命周期被任意无限制的延长. 对于文件意外的引用,会导致对于文件的持有时间超出预期(比如对于异常的跟踪, 包含有全局变量等). 推荐使用 with语句 以管理文件:\nwith open(\"hello.txt\") as hello_file: for line in hello_file: print line 对于不支持使用with语句的类似文件的对象,使用 contextlib.closing():\nimport contextlib with contextlib.closing(urllib.urlopen(\"http://www.python.org/\")) as front_page: for line in front_page: print line TODO注释 为临时代码使用TODO注释, 它是一种短期解决方案. 不算完美, 但够好了.\nTODO注释应该在所有开头处包含\"TODO\"字符串, 紧跟着是用括号括起来的你的名字, email地址或其它标识符. 然后是一个可选的冒号. 接着必须有一行注释, 解释要做什么. 主要目的是为了有一个统一的TODO格式, 这样添加注释的人就可以搜索到(并可以按需提供更多细节). 写了TODO注释并不保证写的人会亲自解决问题. 当你写了一个TODO, 请注上你的名字.\n# TODO(kl@gmail.com): Use a \"*\" here for string repetition. # TODO(Zeke) Change this to use relations. 如果你的TODO是\"将来做某事\"的形式, 那么请确保你包含了一个指定的日期(“2009年11月解决”)或者一个特定的事件(“等到所有的客户都可以处理XML请求就移除这些代码”).\n导入格式 每个导入应该独占一行\nYes: import os import sys No: import os, sys 导入总应该放在文件顶部, 位于模块注释和文档字符串之后, 模块全局变量和常量之前. 导入应该按照从最通用到最不通用的顺序分组:\n标准库导入 第三方库导入 应用程序指定导入 每种分组中, 应该根据每个模块的完整包路径按字典序排序, 忽略大小写.\nimport foo from foo import bar from foo.bar import baz from foo.bar import Quux from Foob import ar 语句 通常每个语句应该独占一行\n不过, 如果测试结果与测试语句在一行放得下, 你也可以将它们放在同一行. 如果是if语句, 只有在没有else时才能这样做. 特别地, 绝不要对 try/except 这样做, 因为try和except不能放在同一行.\nYes: if foo: bar(foo) No: if foo: bar(foo) else: baz(foo) try: bar(foo) except ValueError: baz(foo) try: bar(foo) except ValueError: baz(foo) 访问控制 在Python中, 对于琐碎又不太重要的访问函数, 你应该直接使用公有变量来取代它们, 这样可以避免额外的函数调用开销. 当添加更多功能时, 你可以用属性(property)来保持语法的一致性.\n(译者注: 重视封装的面向对象程序员看到这个可能会很反感, 因为他们一直被教育: 所有成员变量都必须是私有的! 其实, 那真的是有点麻烦啊. 试着去接受Pythonic哲学吧)\n另一方面, 如果访问更复杂, 或者变量的访问开销很显著, 那么你应该使用像 get_foo() 和 set_foo() 这样的函数调用. 如果之前的代码行为允许通过属性(property)访问 , 那么就不要将新的访问函数与属性绑定. 这样, 任何试图通过老方法访问变量的代码就没法运行, 使用者也就会意识到复杂性发生了变化.\n命名 应该避免的名称\n单字符名称, 除了计数器和迭代器. 包/模块名中的连字符(-) 双下划线开头并结尾的名称(Python保留, 例如__init__) 命名约定\n所谓\"内部(Internal)“表示仅模块内可用, 或者, 在类内是保护或私有的. 用单下划线(_)开头表示模块变量或函数是protected的(使用import * from时不会包含). 用双下划线(__)开头的实例变量或方法表示类内私有. 将相关的类和顶级函数放在同一个模块里. 不像Java, 没必要限制一个类一个模块. 对类名使用大写字母开头的单词(如CapWords, 即Pascal风格), 但是模块名应该用小写加下划线的方式(如lower_with_under.py). 尽管已经有很多现存的模块使用类似于CapWords.py这样的命名, 但现在已经不鼓励这样做, 因为如果模块名碰巧和类名一致, 这会让人困扰. Main 即使是一个打算被用作脚本的文件, 也应该是可导入的. 并且简单的导入不应该导致这个脚本的主功能(main functionality)被执行, 这是一种副作用. 主功能应该放在一个main()函数中.\n在Python中, pydoc以及单元测试要求模块必须是可导入的. 你的代码应该在执行主程序前总是检查 if __name__ == '__main__' , 这样当模块被导入时主程序就不会被执行.\ndef main(): ... if __name__ == '__main__': main() 所有的顶级代码在模块导入时都会被执行. 要小心不要去调用函数, 创建对象, 或者执行那些不应该在使用pydoc时执行的操作.\n参考： Google Python风格规范 ","wordCount":"1237","inLanguage":"en","datePublished":"2019-06-14T22:04:50+08:00","dateModified":"2019-06-14T22:04:50+08:00","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://zhoutao822.github.io/posts/python_style_rules/"},"publisher":{"@type":"Organization","name":"Tao's Notes","logo":{"@type":"ImageObject","url":"https://zhoutao822.github.io/favicon.ico"}}}</script></head><body class=dark id=top><header class=header><nav class=nav><div class=logo><a href=https://zhoutao822.github.io/ accesskey=h title="Home (Alt + H)">Home</a>
<span class=logo-switches></span></div><ul id=menu><li><a href=https://zhoutao822.github.io/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://zhoutao822.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://zhoutao822.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://zhoutao822.github.io/series/ title=Series><span>Series</span></a></li><li><a href=https://zhoutao822.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://zhoutao822.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://zhoutao822.github.io/posts/>Posts</a></div><h1 class=post-title>Python风格规范</h1><div class=post-meta><span title='2019-06-14 22:04:50 +0800 +0800'>June 14, 2019</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/Zhoutao822/zhoutao822.github.io/tree/main/content//posts/python_style_rules.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e5%88%86%e5%8f%b7 aria-label=分号>分号</a></li><li><a href=#%e8%a1%8c%e9%95%bf%e5%ba%a6 aria-label=行长度>行长度</a></li><li><a href=#%e6%8b%ac%e5%8f%b7 aria-label=括号>括号</a></li><li><a href=#%e7%bc%a9%e8%bf%9b aria-label=缩进>缩进</a></li><li><a href=#%e7%a9%ba%e8%a1%8c aria-label=空行>空行</a></li><li><a href=#%e7%a9%ba%e6%a0%bc aria-label=空格>空格</a></li><li><a href=#hashbang aria-label=Hashbang>Hashbang</a></li><li><a href=#%e6%b3%a8%e9%87%8a aria-label=注释>注释</a></li><li><a href=#%e7%b1%bb aria-label=类>类</a></li><li><a href=#%e5%ad%97%e7%ac%a6%e4%b8%b2 aria-label=字符串>字符串</a></li><li><a href=#%e6%96%87%e4%bb%b6%e5%92%8csockets aria-label=文件和sockets>文件和sockets</a></li><li><a href=#todo%e6%b3%a8%e9%87%8a aria-label=TODO注释>TODO注释</a></li><li><a href=#%e5%af%bc%e5%85%a5%e6%a0%bc%e5%bc%8f aria-label=导入格式>导入格式</a></li><li><a href=#%e8%af%ad%e5%8f%a5 aria-label=语句>语句</a></li><li><a href=#%e8%ae%bf%e9%97%ae%e6%8e%a7%e5%88%b6 aria-label=访问控制>访问控制</a></li><li><a href=#%e5%91%bd%e5%90%8d aria-label=命名>命名</a></li><li><a href=#main aria-label=Main>Main</a></li><li><a href=#%e5%8f%82%e8%80%83 aria-label=参考：>参考：</a></li></ul></div></details></div><div class=post-content><h2 id=分号>分号<a hidden class=anchor aria-hidden=true href=#分号>#</a></h2><p>不要在行尾加分号, 也不要用分号将两条命令放在同一行.</p><h2 id=行长度>行长度<a hidden class=anchor aria-hidden=true href=#行长度>#</a></h2><p>每行不超过80个字符</p><p>例外:</p><ol><li>长的导入模块语句</li><li>注释里的URL</li></ol><p>不要使用反斜杠连接行.</p><p>Python会将 <code>圆括号, 中括号和花括号中的行隐式的连接起来</code> , 你可以利用这个特点. 如果需要, 你可以在表达式外围增加一对额外的圆括号.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>Yes: foo_bar(self, width, height, color<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;black&#39;</span>, design<span style=color:#f92672>=</span><span style=color:#66d9ef>None</span>, x<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;foo&#39;</span>,
</span></span><span style=display:flex><span>             emphasis<span style=color:#f92672>=</span><span style=color:#66d9ef>None</span>, highlight<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>     <span style=color:#66d9ef>if</span> (width <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>and</span> height <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>and</span>
</span></span><span style=display:flex><span>         color <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;red&#39;</span> <span style=color:#f92672>and</span> emphasis <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;strong&#39;</span>):
</span></span></code></pre></div><p>如果一个文本字符串在一行放不下, 可以使用圆括号来实现隐式行连接:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>x <span style=color:#f92672>=</span> (<span style=color:#e6db74>&#39;This will build a very long long &#39;</span>
</span></span><span style=display:flex><span>     <span style=color:#e6db74>&#39;long long long long long long string&#39;</span>)
</span></span></code></pre></div><p>在注释中，如果必要，将长的URL放在一行上。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>Yes:  <span style=color:#75715e># See details at</span>
</span></span><span style=display:flex><span>      <span style=color:#75715e># http://www.example.com/us/developer/documentation/api/content/v2.0/csv_file_name_extension_full_specification.html</span>
</span></span><span style=display:flex><span>No:  <span style=color:#75715e># See details at</span>
</span></span><span style=display:flex><span>     <span style=color:#75715e># http://www.example.com/us/developer/documentation/api/content/\</span>
</span></span><span style=display:flex><span>     <span style=color:#75715e># v2.0/csv_file_name_extension_full_specification.html</span>
</span></span></code></pre></div><h2 id=括号>括号<a hidden class=anchor aria-hidden=true href=#括号>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>Yes: <span style=color:#66d9ef>if</span> foo:
</span></span><span style=display:flex><span>         bar()
</span></span><span style=display:flex><span>     <span style=color:#66d9ef>while</span> x:
</span></span><span style=display:flex><span>         x <span style=color:#f92672>=</span> bar()
</span></span><span style=display:flex><span>     <span style=color:#66d9ef>if</span> x <span style=color:#f92672>and</span> y:
</span></span><span style=display:flex><span>         bar()
</span></span><span style=display:flex><span>     <span style=color:#66d9ef>if</span> <span style=color:#f92672>not</span> x:
</span></span><span style=display:flex><span>         bar()
</span></span><span style=display:flex><span>     <span style=color:#66d9ef>return</span> foo
</span></span><span style=display:flex><span>     <span style=color:#66d9ef>for</span> (x, y) <span style=color:#f92672>in</span> dict<span style=color:#f92672>.</span>items(): <span style=color:#f92672>...</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>No:  <span style=color:#66d9ef>if</span> (x):
</span></span><span style=display:flex><span>         bar()
</span></span><span style=display:flex><span>     <span style=color:#66d9ef>if</span> <span style=color:#f92672>not</span>(x):
</span></span><span style=display:flex><span>         bar()
</span></span><span style=display:flex><span>     <span style=color:#66d9ef>return</span> (foo)
</span></span></code></pre></div><h2 id=缩进>缩进<a hidden class=anchor aria-hidden=true href=#缩进>#</a></h2><p>用4个空格来缩进代码</p><p>绝对不要用tab, 也不要tab和空格混用. 对于行连接的情况, 你应该要么垂直对齐换行的元素, 或者使用4空格的悬挂式缩进(这时第一行不应该有参数):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>Yes:   <span style=color:#75715e># 与起始变量对齐</span>
</span></span><span style=display:flex><span>       foo <span style=color:#f92672>=</span> long_function_name(var_one, var_two,
</span></span><span style=display:flex><span>                                var_three, var_four)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>       <span style=color:#75715e># 字典中与起始值对齐</span>
</span></span><span style=display:flex><span>       foo <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>           long_dictionary_key: value1 <span style=color:#f92672>+</span>
</span></span><span style=display:flex><span>                                value2,
</span></span><span style=display:flex><span>           <span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>       }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>       <span style=color:#75715e># 4 个空格缩进，第一行不需要</span>
</span></span><span style=display:flex><span>       foo <span style=color:#f92672>=</span> long_function_name(
</span></span><span style=display:flex><span>           var_one, var_two, var_three,
</span></span><span style=display:flex><span>           var_four)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>       <span style=color:#75715e># 字典中 4 个空格缩进</span>
</span></span><span style=display:flex><span>       foo <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>           long_dictionary_key:
</span></span><span style=display:flex><span>               long_dictionary_value,
</span></span><span style=display:flex><span>           <span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>       }
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>No:    <span style=color:#75715e># 第一行有空格是禁止的</span>
</span></span><span style=display:flex><span>      foo <span style=color:#f92672>=</span> long_function_name(var_one, var_two,
</span></span><span style=display:flex><span>          var_three, var_four)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#75715e># 2 个空格是禁止的</span>
</span></span><span style=display:flex><span>      foo <span style=color:#f92672>=</span> long_function_name(
</span></span><span style=display:flex><span>        var_one, var_two, var_three,
</span></span><span style=display:flex><span>        var_four)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#75715e># 字典中没有处理缩进</span>
</span></span><span style=display:flex><span>      foo <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>          long_dictionary_key:
</span></span><span style=display:flex><span>              long_dictionary_value,
</span></span><span style=display:flex><span>              <span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>      }
</span></span></code></pre></div><h2 id=空行>空行<a hidden class=anchor aria-hidden=true href=#空行>#</a></h2><p>顶级定义之间空两行, 方法定义之间空一行</p><p>顶级定义之间空两行, 比如函数或者类定义. 方法定义, 类定义与第一个方法之间, 都应该空一行. 函数或方法中, 某些地方要是你觉得合适, 就空一行.</p><h2 id=空格>空格<a hidden class=anchor aria-hidden=true href=#空格>#</a></h2><p>按照标准的排版规范来使用标点两边的空格</p><p>括号内不要有空格.</p><p>按照标准的排版规范来使用标点两边的空格</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>Yes: spam(ham[<span style=color:#ae81ff>1</span>], {eggs: <span style=color:#ae81ff>2</span>}, [])
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>No:  spam( ham[ <span style=color:#ae81ff>1</span> ], { eggs: <span style=color:#ae81ff>2</span> }, [ ] )
</span></span></code></pre></div><p>不要在逗号, 分号, 冒号前面加空格, 但应该在它们后面加(除了在行尾).</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>Yes: <span style=color:#66d9ef>if</span> x <span style=color:#f92672>==</span> <span style=color:#ae81ff>4</span>:
</span></span><span style=display:flex><span>         print x, y
</span></span><span style=display:flex><span>     x, y <span style=color:#f92672>=</span> y, x
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>No:  <span style=color:#66d9ef>if</span> x <span style=color:#f92672>==</span> <span style=color:#ae81ff>4</span> :
</span></span><span style=display:flex><span>         print x , y
</span></span><span style=display:flex><span>     x , y <span style=color:#f92672>=</span> y , x
</span></span></code></pre></div><p>参数列表, 索引或切片的左括号前不应加空格.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>Yes: spam(<span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>no: spam (<span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>Yes: dict[<span style=color:#e6db74>&#39;key&#39;</span>] <span style=color:#f92672>=</span> list[index]
</span></span><span style=display:flex><span>No:  dict [<span style=color:#e6db74>&#39;key&#39;</span>] <span style=color:#f92672>=</span> list [index]
</span></span></code></pre></div><p>在二元操作符两边都加上一个空格, 比如赋值(<code>=</code>), 比较(<code>==</code>, <code>&lt;</code>, <code>></code>, <code>!=</code>, <code>&lt;></code>, <code>&lt;=</code>, <code>>=</code>, <code>in</code>, <code>not in</code>, <code>is</code>, <code>is not</code>), 布尔(<code>and</code>, <code>or</code>, <code>not</code>). 至于算术操作符两边的空格该如何使用, 需要你自己好好判断. 不过两侧务必要保持一致.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>Yes: x <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>No:  x<span style=color:#f92672>&lt;</span><span style=color:#ae81ff>1</span>
</span></span></code></pre></div><p>当<code>=</code>用于指示关键字参数或默认参数值时, 不要在其两侧使用空格.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>Yes: <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>complex</span>(real, imag<span style=color:#f92672>=</span><span style=color:#ae81ff>0.0</span>): <span style=color:#66d9ef>return</span> magic(r<span style=color:#f92672>=</span>real, i<span style=color:#f92672>=</span>imag)
</span></span><span style=display:flex><span>No:  <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>complex</span>(real, imag <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.0</span>): <span style=color:#66d9ef>return</span> magic(r <span style=color:#f92672>=</span> real, i <span style=color:#f92672>=</span> imag)
</span></span></code></pre></div><p>不要用空格来垂直对齐多行间的标记, 因为这会成为维护的负担(适用于<code>:</code>, <code>#</code>, <code>=</code>等):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>Yes:
</span></span><span style=display:flex><span>     foo <span style=color:#f92672>=</span> <span style=color:#ae81ff>1000</span>  <span style=color:#75715e># 注释</span>
</span></span><span style=display:flex><span>     long_name <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>  <span style=color:#75715e># 注释不需要对齐</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>     dictionary <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>         <span style=color:#e6db74>&#34;foo&#34;</span>: <span style=color:#ae81ff>1</span>,
</span></span><span style=display:flex><span>         <span style=color:#e6db74>&#34;long_name&#34;</span>: <span style=color:#ae81ff>2</span>,
</span></span><span style=display:flex><span>         }
</span></span><span style=display:flex><span>No:
</span></span><span style=display:flex><span>     foo       <span style=color:#f92672>=</span> <span style=color:#ae81ff>1000</span>  <span style=color:#75715e># 注释</span>
</span></span><span style=display:flex><span>     long_name <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>     <span style=color:#75715e># 注释不需要对齐</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>     dictionary <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>         <span style=color:#e6db74>&#34;foo&#34;</span>      : <span style=color:#ae81ff>1</span>,
</span></span><span style=display:flex><span>         <span style=color:#e6db74>&#34;long_name&#34;</span>: <span style=color:#ae81ff>2</span>,
</span></span><span style=display:flex><span>         }
</span></span></code></pre></div><h2 id=hashbang>Hashbang<a hidden class=anchor aria-hidden=true href=#hashbang>#</a></h2><p>大部分.py文件不必以#!作为文件的开始. 根据 <code>PEP-394</code> , 程序的main文件应该以 <code>#!/usr/bin/python2</code>或者 <code>#!/usr/bin/python3</code>开始.</p><h2 id=注释>注释<a hidden class=anchor aria-hidden=true href=#注释>#</a></h2><p>确保对模块, 函数, 方法和行内注释使用正确的风格</p><p><strong>文档字符串</strong></p><pre tabindex=0><code>Python有一种独一无二的的注释方式: 使用文档字符串. 文档字符串是包, 模块, 类或函数里的第一个语句. 这些字符串可以通过对象的__doc__成员被自动提取, 并且被pydoc所用. (你可以在你的模块上运行pydoc试一把, 看看它长什么样). 我们对文档字符串的惯例是使用三重双引号&#34;&#34;&#34;( PEP-257 ). 一个文档字符串应该这样组织: 首先是一行以句号, 问号或惊叹号结尾的概述(或者该文档字符串单纯只有一行). 接着是一个空行. 接着是文档字符串剩下的部分, 它应该与文档字符串的第一行的第一个引号对齐. 下面有更多文档字符串的格式化规范.
</code></pre><p><strong>模块</strong></p><pre tabindex=0><code>每个文件应该包含一个许可样板. 根据项目使用的许可(例如, Apache 2.0, BSD, LGPL, GPL), 选择合适的样板.
</code></pre><p><strong>函数和方法</strong></p><pre tabindex=0><code>下文所指的函数,包括函数, 方法, 以及生成器.

一个函数必须要有文档字符串, 除非它满足以下条件:

1. 外部不可见
2. 非常短小
3. 简单明了
文档字符串应该包含函数做什么, 以及输入和输出的详细描述. 通常, 不应该描述&#34;怎么做&#34;, 除非是一些复杂的算法. 文档字符串应该提供足够的信息, 当别人编写代码调用该函数时, 他不需要看一行代码, 只要看文档字符串就可以了. 对于复杂的代码, 在代码旁边加注释会比使用文档字符串更有意义.

关于函数的几个方面应该在特定的小节中进行描述记录， 这几个方面如下文所述. 每节应该以一个标题行开始. 标题行以冒号结尾. 除标题行外, 节的其他内容应被缩进2个空格.

Args:
列出每个参数的名字, 并在名字后使用一个冒号和一个空格, 分隔对该参数的描述.如果描述太长超过了单行80字符,使用2或者4个空格的悬挂缩进(与文件其他部分保持一致). 描述应该包括所需的类型和含义. 如果一个函数接受*foo(可变长度参数列表)或者**bar (任意关键字参数), 应该详细列出*foo和**bar.

Returns: (或者 Yields: 用于生成器)
描述返回值的类型和语义. 如果函数返回None, 这一部分可以省略.

Raises:
列出与接口有关的所有异常.
</code></pre><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>fetch_bigtable_rows</span>(big_table, keys, other_silly_variable<span style=color:#f92672>=</span><span style=color:#66d9ef>None</span>):
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;&#34;&#34;Fetches rows from a Bigtable.
</span></span></span><span style=display:flex><span><span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    Retrieves rows pertaining to the given keys from the Table instance
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    represented by big_table.  Silly things may happen if
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    other_silly_variable is not None.
</span></span></span><span style=display:flex><span><span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    Args:
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        big_table: An open Bigtable Table instance.
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        keys: A sequence of strings representing the key of each table row
</span></span></span><span style=display:flex><span><span style=color:#e6db74>            to fetch.
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        other_silly_variable: Another optional variable, that has a much
</span></span></span><span style=display:flex><span><span style=color:#e6db74>            longer name than the other args, and which does nothing.
</span></span></span><span style=display:flex><span><span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    Returns:
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        A dict mapping keys to the corresponding table row data
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        fetched. Each row is represented as a tuple of strings. For
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        example:
</span></span></span><span style=display:flex><span><span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        {&#39;Serak&#39;: (&#39;Rigel VII&#39;, &#39;Preparer&#39;),
</span></span></span><span style=display:flex><span><span style=color:#e6db74>         &#39;Zim&#39;: (&#39;Irk&#39;, &#39;Invader&#39;),
</span></span></span><span style=display:flex><span><span style=color:#e6db74>         &#39;Lrrr&#39;: (&#39;Omicron Persei 8&#39;, &#39;Emperor&#39;)}
</span></span></span><span style=display:flex><span><span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        If a key from the keys argument is missing from the dictionary,
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        then that row was not found in the table.
</span></span></span><span style=display:flex><span><span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    Raises:
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        IOError: An error occurred accessing the bigtable.Table object.
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    &#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pass</span>
</span></span></code></pre></div><p><strong>类</strong></p><pre tabindex=0><code>类应该在其定义下有一个用于描述该类的文档字符串. 如果你的类有公共属性(Attributes), 那么文档中应该有一个属性(Attributes)段. 并且应该遵守和函数参数相同的格式.
</code></pre><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>SampleClass</span>(object):
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;&#34;&#34;Summary of class here.
</span></span></span><span style=display:flex><span><span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    Longer class information....
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    Longer class information....
</span></span></span><span style=display:flex><span><span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    Attributes:
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        likes_spam: A boolean indicating if we like SPAM or not.
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        eggs: An integer count of the eggs we have laid.
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    &#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> __init__(self, likes_spam<span style=color:#f92672>=</span><span style=color:#66d9ef>False</span>):
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;&#34;&#34;Inits SampleClass with blah.&#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>likes_spam <span style=color:#f92672>=</span> likes_spam
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>eggs <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>public_method</span>(self):
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;&#34;&#34;Performs operation blah.&#34;&#34;&#34;</span>
</span></span></code></pre></div><p><strong>块注释和行注释</strong></p><pre tabindex=0><code>最需要写注释的是代码中那些技巧性的部分. 如果你在下次 代码审查 的时候必须解释一下, 那么你应该现在就给它写注释. 对于复杂的操作, 应该在其操作开始前写上若干行注释. 对于不是一目了然的代码, 应在其行尾添加注释.
</code></pre><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e># We use a weighted dictionary search to find out where i is in</span>
</span></span><span style=display:flex><span><span style=color:#75715e># the array.  We extrapolate position based on the largest num</span>
</span></span><span style=display:flex><span><span style=color:#75715e># in the array and the array size and then do binary search to</span>
</span></span><span style=display:flex><span><span style=color:#75715e># get the exact number.</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> i <span style=color:#f92672>&amp;</span> (i<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>:        <span style=color:#75715e># true iff i is a power of 2</span>
</span></span></code></pre></div><pre tabindex=0><code>为了提高可读性, 注释应该至少离开代码2个空格.

另一方面, 绝不要描述代码. 假设阅读代码的人比你更懂Python, 他只是不知道你的代码要做什么.
</code></pre><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e># BAD COMMENT: Now go through the b array and make sure whenever i occurs</span>
</span></span><span style=display:flex><span><span style=color:#75715e># the next element is i+1</span>
</span></span></code></pre></div><h2 id=类>类<a hidden class=anchor aria-hidden=true href=#类>#</a></h2><p>如果一个类不继承自其它类, 就显式的从object继承. 嵌套类也一样.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>Yes: <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>SampleClass</span>(object):
</span></span><span style=display:flex><span>         <span style=color:#66d9ef>pass</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>     <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>OuterClass</span>(object):
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>         <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>InnerClass</span>(object):
</span></span><span style=display:flex><span>             <span style=color:#66d9ef>pass</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>     <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ChildClass</span>(ParentClass):
</span></span><span style=display:flex><span>         <span style=color:#e6db74>&#34;&#34;&#34;Explicitly inherits from another class already.&#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>No: <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>SampleClass</span>:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>pass</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>OuterClass</span>:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>InnerClass</span>:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>pass</span>
</span></span></code></pre></div><p>继承自 <code>object</code> 是为了使属性(<code>properties</code>)正常工作, 并且这样可以保护你的代码, 使其不受Python 3000的一个特殊的潜在不兼容性影响. 这样做也定义了一些特殊的方法, 这些方法实现了对象的默认语义, 包括 <code>__new__</code>, <code>__init__</code>, <code>__delattr__</code>, <code>__getattribute__</code>, <code>__setattr__</code>, <code>__hash__</code>, <code>__repr__</code>, and <code>__str__</code> .</p><h2 id=字符串>字符串<a hidden class=anchor aria-hidden=true href=#字符串>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>Yes: x <span style=color:#f92672>=</span> a <span style=color:#f92672>+</span> b
</span></span><span style=display:flex><span>     x <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;</span><span style=color:#e6db74>%s</span><span style=color:#e6db74>, </span><span style=color:#e6db74>%s</span><span style=color:#e6db74>!&#39;</span> <span style=color:#f92672>%</span> (imperative, expletive)
</span></span><span style=display:flex><span>     x <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;</span><span style=color:#e6db74>{}</span><span style=color:#e6db74>, </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>!&#39;</span><span style=color:#f92672>.</span>format(imperative, expletive)
</span></span><span style=display:flex><span>     x <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;name: </span><span style=color:#e6db74>%s</span><span style=color:#e6db74>; score: </span><span style=color:#e6db74>%d</span><span style=color:#e6db74>&#39;</span> <span style=color:#f92672>%</span> (name, n)
</span></span><span style=display:flex><span>     x <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;name: </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>; score: </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#39;</span><span style=color:#f92672>.</span>format(name, n)
</span></span><span style=display:flex><span>No: x <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;</span><span style=color:#e6db74>%s%s</span><span style=color:#e6db74>&#39;</span> <span style=color:#f92672>%</span> (a, b)  <span style=color:#75715e># use + in this case</span>
</span></span><span style=display:flex><span>    x <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;</span><span style=color:#e6db74>{}{}</span><span style=color:#e6db74>&#39;</span><span style=color:#f92672>.</span>format(a, b)  <span style=color:#75715e># use + in this case</span>
</span></span><span style=display:flex><span>    x <span style=color:#f92672>=</span> imperative <span style=color:#f92672>+</span> <span style=color:#e6db74>&#39;, &#39;</span> <span style=color:#f92672>+</span> expletive <span style=color:#f92672>+</span> <span style=color:#e6db74>&#39;!&#39;</span>
</span></span><span style=display:flex><span>    x <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;name: &#39;</span> <span style=color:#f92672>+</span> name <span style=color:#f92672>+</span> <span style=color:#e6db74>&#39;; score: &#39;</span> <span style=color:#f92672>+</span> str(n)
</span></span></code></pre></div><p>避免在循环中用+和+=操作符来累加字符串. 由于字符串是不可变的, 这样做会创建不必要的临时对象, 并且导致二次方而不是线性的运行时间. 作为替代方案, 你可以将每个子串加入列表, 然后在循环结束后用 .join 连接列表. (也可以将每个子串写入一个 cStringIO.StringIO 缓存中.)</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>Yes: items <span style=color:#f92672>=</span> [<span style=color:#e6db74>&#39;&lt;table&gt;&#39;</span>]
</span></span><span style=display:flex><span>     <span style=color:#66d9ef>for</span> last_name, first_name <span style=color:#f92672>in</span> employee_list:
</span></span><span style=display:flex><span>         items<span style=color:#f92672>.</span>append(<span style=color:#e6db74>&#39;&lt;tr&gt;&lt;td&gt;</span><span style=color:#e6db74>%s</span><span style=color:#e6db74>, </span><span style=color:#e6db74>%s</span><span style=color:#e6db74>&lt;/td&gt;&lt;/tr&gt;&#39;</span> <span style=color:#f92672>%</span> (last_name, first_name))
</span></span><span style=display:flex><span>     items<span style=color:#f92672>.</span>append(<span style=color:#e6db74>&#39;&lt;/table&gt;&#39;</span>)
</span></span><span style=display:flex><span>     employee_table <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;&#39;</span><span style=color:#f92672>.</span>join(items)
</span></span><span style=display:flex><span>No: employee_table <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;&lt;table&gt;&#39;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> last_name, first_name <span style=color:#f92672>in</span> employee_list:
</span></span><span style=display:flex><span>        employee_table <span style=color:#f92672>+=</span> <span style=color:#e6db74>&#39;&lt;tr&gt;&lt;td&gt;</span><span style=color:#e6db74>%s</span><span style=color:#e6db74>, </span><span style=color:#e6db74>%s</span><span style=color:#e6db74>&lt;/td&gt;&lt;/tr&gt;&#39;</span> <span style=color:#f92672>%</span> (last_name, first_name)
</span></span><span style=display:flex><span>    employee_table <span style=color:#f92672>+=</span> <span style=color:#e6db74>&#39;&lt;/table&gt;&#39;</span>
</span></span></code></pre></div><p>在同一个文件中, 保持使用字符串引号的一致性. 使用单引号&rsquo;或者双引号"之一用以引用字符串, 并在同一文件中沿用. 在字符串内可以使用另外一种引号, 以避免在字符串中使用. PyLint已经加入了这一检查.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>Yes:
</span></span><span style=display:flex><span>     Python(<span style=color:#e6db74>&#39;Why are you hiding your eyes?&#39;</span>)
</span></span><span style=display:flex><span>     Gollum(<span style=color:#e6db74>&#34;I&#39;m scared of lint errors.&#34;</span>)
</span></span><span style=display:flex><span>     Narrator(<span style=color:#e6db74>&#39;&#34;Good!&#34; thought a happy Python reviewer.&#39;</span>)
</span></span><span style=display:flex><span>No:
</span></span><span style=display:flex><span>     Python(<span style=color:#e6db74>&#34;Why are you hiding your eyes?&#34;</span>)
</span></span><span style=display:flex><span>     Gollum(<span style=color:#e6db74>&#39;The lint. It burns. It burns us.&#39;</span>)
</span></span><span style=display:flex><span>     Gollum(<span style=color:#e6db74>&#34;Always the great lint. Watching. Watching.&#34;</span>)
</span></span></code></pre></div><p>为多行字符串使用三重双引号"&ldquo;&ldquo;而非三重单引号&rsquo;&rsquo;&rsquo;. 当且仅当项目中使用单引号&rsquo;来引用字符串时, 才可能会使用三重&rsquo;&lsquo;&lsquo;为非文档字符串的多行字符串来标识引用. 文档字符串必须使用三重双引号&rdquo;&rdquo;". 不过要注意, 通常用隐式行连接更清晰, 因为多行字符串与程序其他部分的缩进方式不一致.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>Yes:
</span></span><span style=display:flex><span>    print (<span style=color:#e6db74>&#34;This is much nicer.</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>           <span style=color:#e6db74>&#34;Do it this way.</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>No:
</span></span><span style=display:flex><span>      print <span style=color:#e6db74>&#34;&#34;&#34;This is pretty ugly.
</span></span></span><span style=display:flex><span><span style=color:#e6db74>  Don&#39;t do this.
</span></span></span><span style=display:flex><span><span style=color:#e6db74>  &#34;&#34;&#34;</span>
</span></span></code></pre></div><h2 id=文件和sockets>文件和sockets<a hidden class=anchor aria-hidden=true href=#文件和sockets>#</a></h2><p>在文件和sockets结束时, 显式的关闭它.</p><p>除文件外, sockets或其他类似文件的对象在没有必要的情况下打开, 会有许多副作用, 例如:</p><ol><li>它们可能会消耗有限的系统资源, 如文件描述符. 如果这些资源在使用后没有及时归还系统, 那么用于处理这些对象的代码会将资源消耗殆尽.</li><li>持有文件将会阻止对于文件的其他诸如移动、删除之类的操作.</li><li>仅仅是从逻辑上关闭文件和sockets, 那么它们仍然可能会被其共享的程序在无意中进行读或者写操作. 只有当它们真正被关闭后, 对于它们尝试进行读或者写操作将会跑出异常, 并使得问题快速显现出来.</li><li></li></ol><p>而且, 幻想当文件对象析构时, 文件和sockets会自动关闭, 试图将文件对象的生命周期和文件的状态绑定在一起的想法, 都是不现实的. 因为有如下原因:</p><ol><li>没有任何方法可以确保运行环境会真正的执行文件的析构. 不同的Python实现采用不同的内存管理技术, 比如延时垃圾处理机制. 延时垃圾处理机制可能会导致对象生命周期被任意无限制的延长.</li><li>对于文件意外的引用,会导致对于文件的持有时间超出预期(比如对于异常的跟踪, 包含有全局变量等).</li><li></li></ol><p>推荐使用 <code>with</code>语句 以管理文件:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>with</span> open(<span style=color:#e6db74>&#34;hello.txt&#34;</span>) <span style=color:#66d9ef>as</span> hello_file:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> line <span style=color:#f92672>in</span> hello_file:
</span></span><span style=display:flex><span>        print line
</span></span></code></pre></div><p>对于不支持使用<code>with</code>语句的类似文件的对象,使用 <code>contextlib.closing()</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> contextlib
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>with</span> contextlib<span style=color:#f92672>.</span>closing(urllib<span style=color:#f92672>.</span>urlopen(<span style=color:#e6db74>&#34;http://www.python.org/&#34;</span>)) <span style=color:#66d9ef>as</span> front_page:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> line <span style=color:#f92672>in</span> front_page:
</span></span><span style=display:flex><span>        print line
</span></span></code></pre></div><h2 id=todo注释>TODO注释<a hidden class=anchor aria-hidden=true href=#todo注释>#</a></h2><p>为临时代码使用TODO注释, 它是一种短期解决方案. 不算完美, 但够好了.</p><p>TODO注释应该在所有开头处包含"TODO"字符串, 紧跟着是用括号括起来的你的名字, email地址或其它标识符. 然后是一个可选的冒号. 接着必须有一行注释, 解释要做什么. 主要目的是为了有一个统一的TODO格式, 这样添加注释的人就可以搜索到(并可以按需提供更多细节). 写了TODO注释并不保证写的人会亲自解决问题. 当你写了一个TODO, 请注上你的名字.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e># TODO(kl@gmail.com): Use a &#34;*&#34; here for string repetition.</span>
</span></span><span style=display:flex><span><span style=color:#75715e># TODO(Zeke) Change this to use relations.</span>
</span></span></code></pre></div><p>如果你的TODO是"将来做某事"的形式, 那么请确保你包含了一个指定的日期(&ldquo;2009年11月解决&rdquo;)或者一个特定的事件(&ldquo;等到所有的客户都可以处理XML请求就移除这些代码&rdquo;).</p><h2 id=导入格式>导入格式<a hidden class=anchor aria-hidden=true href=#导入格式>#</a></h2><p>每个导入应该独占一行</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>Yes: <span style=color:#f92672>import</span> os
</span></span><span style=display:flex><span>     <span style=color:#f92672>import</span> sys
</span></span><span style=display:flex><span>No:  <span style=color:#f92672>import</span> os<span style=color:#f92672>,</span> sys
</span></span></code></pre></div><p>导入总应该放在文件顶部, 位于模块注释和文档字符串之后, 模块全局变量和常量之前. 导入应该按照从最通用到最不通用的顺序分组:</p><ol><li>标准库导入</li><li>第三方库导入</li><li>应用程序指定导入</li></ol><p>每种分组中, 应该根据每个模块的完整包路径按字典序排序, 忽略大小写.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> foo
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> foo <span style=color:#f92672>import</span> bar
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> foo.bar <span style=color:#f92672>import</span> baz
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> foo.bar <span style=color:#f92672>import</span> Quux
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> Foob <span style=color:#f92672>import</span> ar
</span></span></code></pre></div><h2 id=语句>语句<a hidden class=anchor aria-hidden=true href=#语句>#</a></h2><p>通常每个语句应该独占一行</p><p>不过, 如果测试结果与测试语句在一行放得下, 你也可以将它们放在同一行. 如果是<code>if</code>语句, 只有在没有<code>else</code>时才能这样做. 特别地, 绝不要对 <code>try/except</code> 这样做, 因为<code>try</code>和<code>except</code>不能放在同一行.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>Yes:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> foo: bar(foo)
</span></span><span style=display:flex><span>No:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> foo: bar(foo)
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>else</span>:   baz(foo)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>try</span>:               bar(foo)
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>except</span> <span style=color:#a6e22e>ValueError</span>: baz(foo)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>try</span>:
</span></span><span style=display:flex><span>      bar(foo)
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>except</span> <span style=color:#a6e22e>ValueError</span>: baz(foo)
</span></span></code></pre></div><h2 id=访问控制>访问控制<a hidden class=anchor aria-hidden=true href=#访问控制>#</a></h2><p>在Python中, 对于琐碎又不太重要的访问函数, 你应该直接使用公有变量来取代它们, 这样可以避免额外的函数调用开销. 当添加更多功能时, 你可以用属性(<code>property</code>)来保持语法的一致性.</p><p>(译者注: 重视封装的面向对象程序员看到这个可能会很反感, 因为他们一直被教育: 所有成员变量都必须是私有的! 其实, 那真的是有点麻烦啊. 试着去接受Pythonic哲学吧)</p><p>另一方面, 如果访问更复杂, 或者变量的访问开销很显著, 那么你应该使用像 <code>get_foo()</code> 和 <code>set_foo()</code> 这样的函数调用. 如果之前的代码行为允许通过属性(<code>property</code>)访问 , 那么就不要将新的访问函数与属性绑定. 这样, 任何试图通过老方法访问变量的代码就没法运行, 使用者也就会意识到复杂性发生了变化.</p><h2 id=命名>命名<a hidden class=anchor aria-hidden=true href=#命名>#</a></h2><p><strong>应该避免的名称</strong></p><ol><li>单字符名称, 除了计数器和迭代器.</li><li>包/模块名中的连字符(-)</li><li>双下划线开头并结尾的名称(Python保留, 例如<code>__init__</code>)</li></ol><p><strong>命名约定</strong></p><ol><li>所谓"内部(<code>Internal</code>)&ldquo;表示仅模块内可用, 或者, 在类内是保护或私有的.</li><li>用单下划线(_)开头表示模块变量或函数是<code>protected</code>的(使用<code>import * from</code>时不会包含).</li><li>用双下划线(__)开头的实例变量或方法表示类内私有.</li><li>将相关的类和顶级函数放在同一个模块里. 不像Java, 没必要限制一个类一个模块.</li><li>对类名使用大写字母开头的单词(如CapWords, 即Pascal风格), 但是模块名应该用小写加下划线的方式(如lower_with_under.py). 尽管已经有很多现存的模块使用类似于CapWords.py这样的命名, 但现在已经不鼓励这样做, 因为如果模块名碰巧和类名一致, 这会让人困扰.</li></ol><h2 id=main>Main<a hidden class=anchor aria-hidden=true href=#main>#</a></h2><p>即使是一个打算被用作脚本的文件, 也应该是可导入的. 并且简单的导入不应该导致这个脚本的主功能(main functionality)被执行, 这是一种副作用. 主功能应该放在一个<code>main()</code>函数中.</p><p>在Python中, pydoc以及单元测试要求模块必须是可导入的. 你的代码应该在执行主程序前总是检查 <code>if __name__ == '__main__'</code> , 这样当模块被导入时主程序就不会被执行.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>main</span>():
</span></span><span style=display:flex><span>      <span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> __name__ <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;__main__&#39;</span>:
</span></span><span style=display:flex><span>    main()
</span></span></code></pre></div><p>所有的顶级代码在模块导入时都会被执行. 要小心不要去调用函数, 创建对象, 或者执行那些不应该在使用pydoc时执行的操作.</p><h2 id=参考>参考：<a hidden class=anchor aria-hidden=true href=#参考>#</a></h2><ol><li><a href=https://zh-google-styleguide.readthedocs.io/en/latest/google-python-styleguide/python_style_rules/>Google Python风格规范</a></li></ol></div><footer class=post-footer><ul class=post-tags><li><a href=https://zhoutao822.github.io/tags/python/>Python</a></li></ul><nav class=paginav><a class=prev href=https://zhoutao822.github.io/posts/menu/><span class=title>« Prev Page</span><br><span>Material组件-Menu</span></a>
<a class=next href=https://zhoutao822.github.io/posts/python_language_rules/><span class=title>Next Page »</span><br><span>Python语言规范</span></a></nav></footer><script src=https://utteranc.es/client.js repo=zhoutao822/zhoutao822.github.io issue-term=title theme=github-dark crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2022 <a href=https://zhoutao822.github.io/>Tao's Notes</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="copy";function s(){t.innerText="copied!",setTimeout(()=>{t.innerText="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>