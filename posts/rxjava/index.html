<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Android框架-RxJava | Tao's Notes</title><meta name=keywords content="Handler,AsyncTask,EventBus,RxJava"><meta name=description content="Android中很多地方都需要跨线程通信，这是由于Android主线程不允许进行复杂的网络请求或者其他非常耗时的操作，否则会导致ANR，主线程只能进行UI操作，比如修改某个控件的text、设置某个控件不可见等等，因此网络请求等操作需要在其他线程中完成，当数据在其他线程中获取完毕时，通过跨线程通信将数据传到主线程中，主线程就可以直接根据数据进行UI操作。常见的跨线程通信的方式有Handler、AsyncTask、EventBus以及RxJava等，前两个是Android自带，后两者是封装好的第三方库。"><meta name=author content="Me"><link rel=canonical href=https://zhoutao822.github.io/posts/rxjava/><meta name=google-site-verification content="Tao"><meta name=yandex-verification content="Tao"><meta name=msvalidate.01 content="Tao"><link crossorigin=anonymous href=/assets/css/stylesheet.min.c88963fe2d79462000fd0fb1b3737783c32855d340583e4523343f8735c787f0.css integrity="sha256-yIlj/i15RiAA/Q+xs3N3g8MoVdNAWD5FIzQ/hzXHh/A=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.b95bacdc39e37a332a9f883b1e78be4abc1fdca2bc1f2641f55e3cd3dabd4d61.js integrity="sha256-uVus3DnjejMqn4g7Hni+Srwf3KK8HyZB9V4809q9TWE=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://zhoutao822.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://zhoutao822.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://zhoutao822.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://zhoutao822.github.io/apple-touch-icon.png><link rel=mask-icon href=https://zhoutao822.github.io/favicon.ico><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.103.1"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="Android框架-RxJava"><meta property="og:description" content="Android中很多地方都需要跨线程通信，这是由于Android主线程不允许进行复杂的网络请求或者其他非常耗时的操作，否则会导致ANR，主线程只能进行UI操作，比如修改某个控件的text、设置某个控件不可见等等，因此网络请求等操作需要在其他线程中完成，当数据在其他线程中获取完毕时，通过跨线程通信将数据传到主线程中，主线程就可以直接根据数据进行UI操作。常见的跨线程通信的方式有Handler、AsyncTask、EventBus以及RxJava等，前两个是Android自带，后两者是封装好的第三方库。"><meta property="og:type" content="article"><meta property="og:url" content="https://zhoutao822.github.io/posts/rxjava/"><meta property="og:image" content="https://zhoutao822.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2019-07-25T20:32:26+08:00"><meta property="article:modified_time" content="2019-07-25T20:32:26+08:00"><meta property="og:site_name" content="Tao's Notes"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://zhoutao822.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Android框架-RxJava"><meta name=twitter:description content="Android中很多地方都需要跨线程通信，这是由于Android主线程不允许进行复杂的网络请求或者其他非常耗时的操作，否则会导致ANR，主线程只能进行UI操作，比如修改某个控件的text、设置某个控件不可见等等，因此网络请求等操作需要在其他线程中完成，当数据在其他线程中获取完毕时，通过跨线程通信将数据传到主线程中，主线程就可以直接根据数据进行UI操作。常见的跨线程通信的方式有Handler、AsyncTask、EventBus以及RxJava等，前两个是Android自带，后两者是封装好的第三方库。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://zhoutao822.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Android框架-RxJava","item":"https://zhoutao822.github.io/posts/rxjava/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Android框架-RxJava","name":"Android框架-RxJava","description":"Android中很多地方都需要跨线程通信，这是由于Android主线程不允许进行复杂的网络请求或者其他非常耗时的操作，否则会导致ANR，主线程只能进行UI操作，比如修改某个控件的text、设置某个控件不可见等等，因此网络请求等操作需要在其他线程中完成，当数据在其他线程中获取完毕时，通过跨线程通信将数据传到主线程中，主线程就可以直接根据数据进行UI操作。常见的跨线程通信的方式有Handler、AsyncTask、EventBus以及RxJava等，前两个是Android自带，后两者是封装好的第三方库。","keywords":["Handler","AsyncTask","EventBus","RxJava"],"articleBody":"Android中很多地方都需要跨线程通信，这是由于Android主线程不允许进行复杂的网络请求或者其他非常耗时的操作，否则会导致ANR，主线程只能进行UI操作，比如修改某个控件的text、设置某个控件不可见等等，因此网络请求等操作需要在其他线程中完成，当数据在其他线程中获取完毕时，通过跨线程通信将数据传到主线程中，主线程就可以直接根据数据进行UI操作。常见的跨线程通信的方式有Handler、AsyncTask、EventBus以及RxJava等，前两个是Android自带，后两者是封装好的第三方库。\n1. Handler Handler是Android中最简单的线程间通信方式，同时也可以在同一个线程中发送消息，但是使用时需要注意内存泄漏的问题。\n1.1 Handler简单使用 还是以和风天气请求为例，我们的目标是在子线程中请求数据，然后通过Handler将数据传到主线程中并显示出来。\npublic class MainActivity extends AppCompatActivity { private final static String KEY = \"XXXXXXXXXX\"; private final static String URL = \"https://free-api.heweather.net/s6/weather/\"; private TextView textView; private Handler handler; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); textView = findViewById(R.id.textView); // Handler的实例化，重写handleMessage方法用于等待处理msg， // handleMessage方法是回调，在回调中更新UI，此时执行在主线程， // 在Android Studio中会提示这里存在内存泄漏问题 handler = new Handler() { @Override public void handleMessage(Message msg) { super.handleMessage(msg); textView.setText(msg.obj.toString()); } }; // 在子线程开启一个网络请求 new Thread(new Runnable() { @Override public void run() { // Retrofit通用代码 Retrofit retrofit = new Retrofit.Builder() .baseUrl(URL) // 设置网络请求的公共Url地址 .addConverterFactory(GsonConverterFactory.create()) // 设置数据解析器 .build(); Api api = retrofit.create(Api.class); Call\u003cWeatherEntity\u003e call = api.getNowWeather(\"beijing\", KEY); try { // 为了在当前子线程获取数据，这里直接使用execute WeatherEntity result = call.execute().body(); // Message的实例化方法Message.obtain Message message = Message.obtain(); // 可以通过Message附加很多数据，这里仅用obj，保存我们网络请求得到的实例 message.obj = result; // 通过handler.sendMessage(message)实现调用回调方法，完成数据传输 // 这种操作有点类似于接口回调 handler.sendMessage(message); } catch (IOException e) { e.printStackTrace(); } } }).start(); } } 这里的内存泄露的原因可以参考其他资料，主要是Java 中非静态内部类和匿名内部类会持有外部类的引用同时Handler 的生命周期比外部类长导致的。如何解决，肯定就是让Handler是静态内部类就完事了\npublic class MainActivity extends AppCompatActivity { private final static String KEY = \"XXXXXXXXXX\"; private final static String URL = \"https://free-api.heweather.net/s6/weather/\"; private TextView textView; private Handler handler; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); textView = findViewById(R.id.textView); // 使用自定义的静态内部类 handler = new MyHandler(this); // 子线程请求没有变化 new Thread(new Runnable() { @Override public void run() { Retrofit retrofit = new Retrofit.Builder() .baseUrl(URL) // 设置网络请求的公共Url地址 .addConverterFactory(GsonConverterFactory.create()) // 设置数据解析器 .build(); Api api = retrofit.create(Api.class); Call\u003cWeatherEntity\u003e call = api.getNowWeather(\"beijing\", KEY); try { WeatherEntity result = call.execute().body(); Message message = Message.obtain(); message.obj = result; handler.sendMessage(message); } catch (IOException e) { e.printStackTrace(); } } }).start(); } @Override protected void onDestroy() { handler.removeCallbacksAndMessages(null); super.onDestroy(); } // public void handleMessage(Message msg) { textView.setText(msg.obj.toString()); } // 自定义静态内部类，与onDestroy中removeCallbacksAndMessages一起使用 public static class MyHandler extends Handler { private WeakReference\u003cMainActivity\u003e reference; public MyHandler(MainActivity mainActivity) { // 同时需要持有对MainActivity的弱引用 this.reference = new WeakReference\u003c\u003e(mainActivity); } @Override public void handleMessage(Message msg) { super.handleMessage(msg); MainActivity mainActivity = reference.get(); if (mainActivity != null) { // 将msg传给MainActivity处理 mainActivity.handleMessage(msg); } } } } 1.2 Handler线程间通信 上面的例子仅演示了从子线程传数据给主线程，那么如果同时需要从主线程传数据给子线程，怎么办\n// 首先需要自定义MyThread，完成Looper的初始化，否则子线程不会自动初始化Looper private class MyThread extends Thread { private Looper looper; @Override public void run() { super.run(); Looper.prepare(); looper = Looper.myLooper(); Looper.loop(); } } // 然后在onCreate方法中 Log.i(\"aaaa\", String.valueOf(Thread.currentThread())); MyThread thread = new MyThread(); thread.start(); // 必须先启动子线程 while (true) { // 确保子线程中的Looper初始化完成 if (thread.looper != null) { // 此时handler的handleMessage方法是在子线程MyThread中执行的 // 两处log中线程的值是不一样的，通过Handler的构造方法实现子线程的调用 handler = new Handler(thread.looper) { @Override public void handleMessage(Message msg) { Log.i(\"aaaa\", String.valueOf(msg.what) + Thread.currentThread()); } }; handler.sendEmptyMessage(12321); break; } } // 如果使用定义好的HandlerThread，则不需要继承Thread，直接使用， // HandlerThread默认帮我们完成了Looper的初始化 Log.i(\"aaaa\", String.valueOf(Thread.currentThread())); // HandlerThread需要用String的构造方法，我们在log中也可以看到 HandlerThread thread = new HandlerThread(\"new thread\"); thread.start(); while (true) { if (thread.getLooper() != null) { handler = new Handler(thread.getLooper()) { @Override public void handleMessage(Message msg) { Log.i(\"aaaa\", String.valueOf(msg.what) + Thread.currentThread()); } }; handler.sendEmptyMessage(12321); break; } } 为什么子线程需要初始化Looper，而主线程不需要？\n首先需要明白的是，只有需要处理消息的线程才需要Looper，即哪个线程执行了handleMessage方法，则线程需要Looper，原因在源码分析中解释；主线程以及HandlerThread会自动进行Looper的初始化，而new Thread()不会，因此在第二个例子中，子线程需要处理消息，所以需要初始化Looper而第一个例子中主线程不需要。\nHandler的初始化，其构造方法依赖于什么，为什么第二个例子中Handler不是在主线程中初始化的吗？\n首先需要知道的是Handler是可以被跨线程调用的，而View是不可以的，举个例子，如果在第一个例子中我们在子线程中调用textView.setText(result.toString());，则会报错CalledFromWrongThreadException: Only the original thread that created a view hierarchy can touch its views.，而Handler没问题，Handler默认构造方法new Handler()会将当前线程的Looper保存在自己这个实例中，即将主线程中的Looper保存，而带参数的构造方法new Handler(thread.looper)会保存thread的looper在实例中，又因为Handler是可以跨线程调用的，所以区分Handler属于哪个线程其实是根据构造方法传入的参数决定的，至于Handler归属于不同的线程会有什么影响，在源码分析中解释。\n1.3 Handler源码分析 以从子线程向主线程发送消息为例，首先从ActivityThread的main方法开始，前面说过主线程中的Looper是自动初始化的，其初始化的位置就在ActivityThread的main方法中\n// ActivityThread.java 核心就两个Looper.prepareMainLooper()和Looper.loop() public static void main(String[] args) { // ... Looper.prepareMainLooper(); // ... // 显然这里是不会执行的 if (false) { Looper.myLooper().setMessageLogging(new LogPrinter(Log.DEBUG, \"ActivityThread\")); } // End of event ActivityThreadMain. Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); Looper.loop(); throw new RuntimeException(\"Main thread loop unexpectedly exited\"); } 再看看Looper.prepareMainLooper()的作用\n// Looper.java 看注释就知道是是为主线程初始化Looper，关键还是看prepare方法，再看myLooper /** * Initialize the current thread as a looper, marking it as an * application's main looper. The main looper for your application * is created by the Android environment, so you should never need * to call this function yourself. See also: {@link #prepare()} */ public static void prepareMainLooper() { prepare(false); synchronized (Looper.class) { if (sMainLooper != null) { throw new IllegalStateException(\"The main Looper has already been prepared.\"); } sMainLooper = myLooper(); } } // prepare方法通过sThreadLocal set了一个Looper实例， // 一个Looper实例保存了MessageQueue和Thread.currentThread() private static void prepare(boolean quitAllowed) { if (sThreadLocal.get() != null) { throw new RuntimeException(\"Only one Looper may be created per thread\"); } sThreadLocal.set(new Looper(quitAllowed)); } // myLooper方法从sThreadLocal get到Looper，那正好对应上面prepare set的Looper， // ThreadLocal的作用是可以保存线程内的变量，简而言之就是通过ThreadLocal的set和get方法 // 处理的变量仅属于某个线程，以Looper为例，在某个线程中有且仅有一个 /** * Return the Looper object associated with the current thread. Returns * null if the calling thread is not associated with a Looper. */ public static @Nullable Looper myLooper() { return sThreadLocal.get(); } // 最后调用了Looper.loop() /** * Run the message queue in this thread. Be sure to call * {@link #quit()} to end the loop. */ public static void loop() { // Looper.loop()会进入一个死循环，但是这个循环并不会导致卡死， // 涉及到Linux pipe/epoll机制，简单说就是在主线程的MessageQueue没有消息时， // 便阻塞在loop的queue.next()中的nativePollOnce()方法里，此时主线程会释放CPU资源进入休眠状态， // 直到下个消息到达或者有事务发生，通过往pipe管道写端写入数据来唤醒主线程工作。 // 这里采用的epoll机制，是一种IO多路复用机制，可以同时监控多个描述符， // 当某个描述符就绪(读或写就绪)，则立刻通知相应程序进行读或写操作，本质同步I/O，即读写是阻塞的。 // 所以说，主线程大多数时候都是处于休眠状态，并不会消耗大量CPU资源。 // 先拿到当前线程的Looper，然后拿到Looper中的MessageQueue final Looper me = myLooper(); if (me == null) { throw new RuntimeException(\"No Looper; Looper.prepare() wasn't called on this thread.\"); } final MessageQueue queue = me.mQueue; // ... // 开启循环，Android中主线程上所有的点击事件、UI绘制都是通过Message发送到MessageQueue中等待执行 // 所以这里必须是死循环，因为如果跳出了这个循环说明已经无法再继续处理任何Message，那么随之而来的肯定就是 // 应用崩溃或者重启Looper，但是这里的循环并不会导致卡死，理由在上面已经简要说明了 for (;;) { // 循环的作用就是通过queue.next()不断地从MessageQueue取出Message，next方法中也是一个死循环， // 正常情况下queue.next()应该返回一个有效的Message，或者休眠不返回任何值，如果返回null， // 说明出了问题 Message msg = queue.next(); // might block if (msg == null) { // 当取出的message为空时说明MessageQueue被终止了，因此跳出循环，执行其他操作，比如重启Looper或者崩溃？ // No message indicates that the message queue is quitting. return; } // ... // 当我们取到有效的Message后，就需要知道这个Message应该由谁来处理，即Target，从Message源码中可知， // 这个Target实际上就是Handler，最终调用的就是Handler的dispatchMessage方法，从这里我们就知道了 // 只要其他线程能够将Message发送到主线程的MessageQueue中，那么这个Message就可以被主线程的Handler处理 try { msg.target.dispatchMessage(msg); dispatchEnd = needEndTime ? SystemClock.uptimeMillis() : 0; } finally { if (traceTag != 0) { Trace.traceEnd(traceTag); } } // ... // 最后需要对Message对象进行回收 msg.recycleUnchecked(); } } ActivityThread的main方法中对主线程的Looper进行初始化，同样的主线程的MessageQueue也准备好对其中的Message进行分发，这都是通过死循环实现的，相当于MessageQueue是一个等待队列，有消息来了，他就取消息并调用Message对应的Handler的dispatchMessage方法，如果没有就休眠，然后我们看看Handler的初始化以及Message的发送是如何实现的\n// Handler.java Handler的构造方法分为两类，一类是参数带Looper的，另一类是不带Looper // 不带Looper的构造函数最终会调用到最后一个构造函数，并进行Looper的初始化； // 带Looper的构造函数会直接保存参数中的Looper实例 public Handler() { this(null, false); } public Handler(Callback callback) { this(callback, false); } public Handler(Looper looper) { this(looper, null, false); } public Handler(Looper looper, Callback callback) { this(looper, callback, false); } public Handler(boolean async) { this(null, async); } public Handler(Looper looper, Callback callback, boolean async) { mLooper = looper; mQueue = looper.mQueue; mCallback = callback; mAsynchronous = async; } public Handler(Callback callback, boolean async) { if (FIND_POTENTIAL_LEAKS) { final Class\u003c? extends Handler\u003e klass = getClass(); if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) \u0026\u0026 (klass.getModifiers() \u0026 Modifier.STATIC) == 0) { Log.w(TAG, \"The following Handler class should be static or leaks might occur: \" + klass.getCanonicalName()); } } // Looper的myLooper方法会初始化当前线程的Looper mLooper = Looper.myLooper(); if (mLooper == null) { throw new RuntimeException( \"Can't create handler inside thread \" + Thread.currentThread() + \" that has not called Looper.prepare()\"); } mQueue = mLooper.mQueue; mCallback = callback; mAsynchronous = async; } 然后调用handler.sendMessage(message);\n// Handler.java sendMessage方法会直接调用sendMessageDelayed // sendMessageDelayed就是多个延时的效果 public final boolean sendMessage(Message msg) { return sendMessageDelayed(msg, 0); } public final boolean sendMessageDelayed(Message msg, long delayMillis) { if (delayMillis \u003c 0) { delayMillis = 0; } // 通过加上SystemClock.uptimeMillis()可以直接得到执行的具体时间 return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis); } public boolean sendMessageAtTime(Message msg, long uptimeMillis) { MessageQueue queue = mQueue; if (queue == null) { RuntimeException e = new RuntimeException( this + \" sendMessageAtTime() called with no mQueue\"); Log.w(\"Looper\", e.getMessage(), e); return false; } // 最终还是使用Handler的MessageQueue return enqueueMessage(queue, msg, uptimeMillis); } private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) { // 注意这里将Message的target设置为当前handler msg.target = this; if (mAsynchronous) { msg.setAsynchronous(true); } // 然后调用MessageQueue的enqueueMessage方法 return queue.enqueueMessage(msg, uptimeMillis); } // MessageQueue.java enqueueMessage将Message加入链表中 boolean enqueueMessage(Message msg, long when) { if (msg.target == null) { throw new IllegalArgumentException(\"Message must have a target.\"); } if (msg.isInUse()) { throw new IllegalStateException(msg + \" This message is already in use.\"); } synchronized (this) { // 如果MessageQueue被终止了，那么Message还需要回收 if (mQuitting) { IllegalStateException e = new IllegalStateException( msg.target + \" sending message to a Handler on a dead thread\"); Log.w(TAG, e.getMessage(), e); msg.recycle(); return false; } msg.markInUse(); msg.when = when; Message p = mMessages; boolean needWake; // 根据msg.next基本可以发现Message是一个链表中的节点，也就是说MessageQueue中的mMessages // 是一种链表形式的结构，其中mMessages是表头，当执行next方法时就会将表头也就是mMessages表示的 // Message返回，当我们传入的Message满足以下任意条件时，可以将此Message作为表头： // 1. 表头本身为空，很明显当没有任何Message传入的时候； // 2. 当我们传入的Message没有任何延迟，这也很显然，立即执行的Message当然要放第一个； // 3. 当我们传入的Message的执行时间在表头的执行时间之前，这也很显然，按照时间排序。 if (p == null || when == 0 || when \u003c p.when) { // New head, wake up the event queue if blocked. msg.next = p; mMessages = msg; needWake = mBlocked; } else { // 如果Message不是表头位置，那么肯定就是链表中的某个位置 // Inserted within the middle of the queue. Usually we don't have to wake // up the event queue unless there is a barrier at the head of the queue // and the message is the earliest asynchronous message in the queue. needWake = mBlocked \u0026\u0026 p.target == null \u0026\u0026 msg.isAsynchronous(); Message prev; for (;;) { // 链表的遍历，还要判断时间when prev = p; p = p.next; if (p == null || when \u003c p.when) { break; } if (needWake \u0026\u0026 p.isAsynchronous()) { needWake = false; } } // 这就很简单了，有序链表中加入某个节点，排序方式为when的值 msg.next = p; // invariant: p == prev.next prev.next = msg; } // We can assume mPtr != 0 because mQuitting is false. if (needWake) { nativeWake(mPtr); } } return true; } 到这里我们就知道了Message被Handler加到了Handler线程的MessageQueue中，而Handler线程中的Looper一直在等待Message进入MessageQueue，通过queue.next()取出Message，然后调用Handler的dispatchMessage方法\n/** * Handle system messages here. */ public void dispatchMessage(Message msg) { // dispatchMessage处理Message的方式也很简单 // 首先判断Message是否设置了Callback，如果有 // 则执行message.callback.run() if (msg.callback != null) { handleCallback(msg); } else { // 如果没有，则判断Handler是否初始化设置了Callback， // 这个和Handler的构造函数相关 if (mCallback != null) { if (mCallback.handleMessage(msg)) { return; } } // 否则就执行handler重写的handleMessage方法， // 这个方法是在我们继承Handler时重写的，或者 // 在使用Handler匿名内部类时重写的 handleMessage(msg); } } 以上就是完整的通过Handler从子线程发送消息到主线程并执行的过程，也解决了我的一些问题：\n1.为什么要设计Handler来传输消息？\n因为多线程的情况下并不确定子线程何时能够执行完毕获取数据，所以需要设计Handler实现一种回调机制，即当子线程数据获取完成后将数据传到主线程中，通过主线程中的回调决定如何处理传来的数据。\n2.为什么要用MessageQueue和Looper这种工具？\n我想是因为既然子线程并不确定何时结束，其次如果存在多个子线程向主线程传递消息，那干脆将这些消息都放在一个队列MessageQueue中，因为多个子线程之间的执行顺序我们也无法确定，如果放在队列中，那么根据消息附加的时间来进行排序我们就可以按照顺序读取从各个子线程发送过来的消息了，与此同时，需要一个能够不停地读取队列中消息的工具Looper，Looper可以循环取数据但是不会阻塞卡死。\n1.4 Handler进阶 Handler除了可以发送Message外，还可以post Runnable，Runnable是接口，提供run方法，Thread类实现了Runnable接口，所以Thread需要实现run方法，run方法中的内容就是执行在Thread线程中，如果Runnable是通过Handler post，那么根据Message的原理，应该明白此Runnable就是运行在Handler归属的线程中\n@Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); textView = findViewById(R.id.textView); // handler不重写handleMessage方法 handler = new Handler(); new Thread(new Runnable() { @Override public void run() { // Retrofit通用代码 Retrofit retrofit = new Retrofit.Builder() .baseUrl(URL) // 设置网络请求的公共Url地址 .addConverterFactory(GsonConverterFactory.create()) // 设置数据解析器 .build(); Api api = retrofit.create(Api.class); Call\u003cWeatherEntity\u003e call = api.getNowWeather(\"beijing\", KEY); try { // 为了在当前子线程获取数据，这里直接使用execute final WeatherEntity result = call.execute().body(); // 通过post直接修改textView的text handler.post(new Runnable() { @Override public void run() { textView.setText(result.toString()); } }); } catch (IOException e) { e.printStackTrace(); } } }).start(); } 因为textView只能在主线程进行设置，所以很显然handler post的Runnable是在主线程运行的，这样就不需要传递数据，而是直接处理数据了，下面看看Runnable是如何被处理的\n// Handler.java public final boolean post(Runnable r) { // sendMessageDelayed之前分析过，这里是将Runnable放入Message中了 return sendMessageDelayed(getPostMessage(r), 0); } // 通过Message保存了这个Runnable，保存在callback，这个之前在dispatchMessage中见过 private static Message getPostMessage(Runnable r) { Message m = Message.obtain(); m.callback = r; return m; } public void dispatchMessage(Message msg) { // 之前sendMessage都是走的第二个判断，post走的就是第一个判断， // 我们的Runnable现在不为空 if (msg.callback != null) { handleCallback(msg); } else { if (mCallback != null) { if (mCallback.handleMessage(msg)) { return; } } handleMessage(msg); } } // 结果很明显了，就是执行了Runnable的run方法 private static void handleCallback(Message message) { message.callback.run(); } 下面演示一下多个线程向主线程发送消息会产生怎样的结果，自定义线程MessageThread用于发送Message，普通的Thread用于post Runnable\n@Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); textView = findViewById(R.id.textView); // handler根据传过来的Message的what值进行不同的操作 handler = new Handler() { @Override public void handleMessage(Message msg) { switch (msg.what) { case 0: Log.i(\"aaaa\", \"Thread 0: \" + msg.obj.toString()); break; case 1: Log.i(\"aaaa\", \"Thread 1: \" + msg.obj.toString()); break; case 2: Log.i(\"aaaa\", \"Thread 2: \" + msg.obj.toString()); break; } } }; // 开启三个线程发送Message，加上延时 new MessageThread(0, \"thread 0 hahaha\", 3000).start(); new MessageThread(1, \"thread 1 oooooo\", 1000).start(); new MessageThread(2, \"thread 2 yyyyyy\", 2000).start(); // post Runnable也加上延时，注意这里的postDelayed并不会阻塞主线程， // 原理同Looper.loop()，所以不会引起ANR，这个延时只会影响此Message在MessageQueue // 中的位置 new Thread(new Runnable() { @Override public void run() { handler.postDelayed(new Runnable() { @Override public void run() { Log.i(\"aaaa\", \"MainThread\"); } }, 10000); } }).start(); } private class MessageThread extends Thread { private int what; private String text; private long delay; public MessageThread(int what, String text, long delay) { this.what = what; this.text = text; this.delay = delay; } @Override public void run() { Message message = Message.obtain(); message.what = what; message.obj = text; handler.sendMessageDelayed(message, delay); } } log结果为\nThread 1: thread 1 oooooo Thread 2: thread 2 yyyyyy Thread 0: thread 0 hahaha MainThread 2. AsyncTask 通过Handler实现的多线程通信在使用上还是有很多不方便的地方，比如需要显示的创建子线程，每次创建子线程都是对资源的消耗，当然也可以使用线程池来减少线程资源的创建与销毁，同时需要定义Handler的处理方式，对于每一个需要处理消息的线程都需要定义其Handler，这样就显得比较乱，因此可以使用AsyncTask来替代，先看一下如何使用。\n2.1 AsyncTask简单使用 // 依然以请求和风天气数据为例，现在我们为加载数据时显示进度，为什么要显示进度呢 // 从设计理念来看，当我们给某些需要长时间等待的操作加上进度条时，用户对这个操作的 // 容忍度会增加，比如常见的进入游戏的界面，会显示进度条，这样的话就算耗时相对较长， // 但是用户可以根据进度有一个心理预期，从而提升容忍度；如果你的耗时操作没有任何进度 // 提示，那么用户很容易觉得你的应用是不是卡死了，从而降低了体验 public class MainActivity extends AppCompatActivity { private static final String KEY = \"XXXXXXXXXXXX\"; private static final String URL = \"https://free-api.heweather.net/s6/weather/\"; private TextView textView; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); textView = findViewById(R.id.textView); MyTask task = new MyTask(); // execute的参数等价于doInBackground的参数 task.execute(\"beijing\", 50L); } // AsyncTask是抽象类，需要自定义Task并实现doInBackground方法，除了doInBackground之外 // 还有几个方法用于初始化、显示进度、输出结果等功能，三个参数Object, Integer, WeatherEntity为泛型参数 private class MyTask extends AsyncTask\u003cObject, Integer, WeatherEntity\u003e { // onPreExecute在主线程执行，用于做一些提前的初始化 @Override protected void onPreExecute() { textView.setText(\"Start!!\"); } // doInBackground在子线程执行，不需要显示地创建Thread，这里的参数params // 是一个泛型参数，也就是说可以传入多个参数，相当于参数数组，参数的传入是 // task.execute传入，返回值由AsyncTask第三个泛型参数决定，同时也是 // onPostExecute的输入参数 @Override protected WeatherEntity doInBackground(Object... params) { // 根据传入的顺序读取，location就是beijing，delay就是50L， // 为了模拟进度，这里传入一个延时，正式使用时需要根据数据实际传输的进度 // 展示进度 String location = (String) params[0]; long delay = (long) params[1]; WeatherEntity result = null; try { // 先获取数据，我们知道这里取数据的速度其实是很快的 result = getData(location); } catch (IOException e) { e.printStackTrace(); } // 然后显示进度，这里仅模拟 try { int count = 0; int length = 1; while (count \u003c 99) { count += length; // 可调用publishProgress（）显示进度, 之后将执行onProgressUpdate（） publishProgress(count); // 模拟耗时任务 Thread.sleep(delay); } } catch (InterruptedException e) { e.printStackTrace(); } // 最后返回取到的数据 return result; } // onProgressUpdate在主线程执行，显示进度 @Override protected void onProgressUpdate(Integer... values) { textView.setText(String.format(Locale.CHINA, \"加载进度：%d%%\", values[0])); } // onPostExecute在主线程执行，用于处理doInBackground返回的数据 @Override protected void onPostExecute(WeatherEntity weatherEntity) { textView.setText(weatherEntity.toString()); } // AsyncTask可以通过调用isCancelled主动终止 @Override protected void onCancelled() { textView.setText(\"Cancel!!!\"); } private WeatherEntity getData(String location) throws IOException { Retrofit retrofit = new Retrofit.Builder() .baseUrl(URL) .addConverterFactory(GsonConverterFactory.create()) .build(); Api api = retrofit.create(Api.class); Call\u003cWeatherEntity\u003e call = api.getNowWeather(location, KEY); return call.execute().body(); } } } 2.2 AsyncTask源码分析 首先从task.execute开始\n// AsyncTask.java @MainThread public final AsyncTask\u003cParams, Progress, Result\u003e execute(Params... params) { // executeOnExecutor传入两个参数sDefaultExecutor和params， // sDefaultExecutor看名字就知道是一个Executor，Executor提供execute方法， // 用于消耗Runnable，我们先看看sDefaultExecutor是什么 return executeOnExecutor(sDefaultExecutor, params); } // sDefaultExecutor实际上是new SerialExecutor()，static修饰加上 // synchronized修饰execute方法，保证多个Task启动execute时是按照顺序执行的 private static class SerialExecutor implements Executor { // SerialExecutor提供一个队列mTasks用于保存Runnable // mActive表示当前需要执行的Runnable final ArrayDeque\u003cRunnable\u003e mTasks = new ArrayDeque\u003cRunnable\u003e(); Runnable mActive; // execute方法把传入的Runnable加入到队列中，但是不是直接加入的， // 而是通过new Runnable改造了，让其在执行了run之后会执行scheduleNext public synchronized void execute(final Runnable r) { mTasks.offer(new Runnable() { public void run() { try { r.run(); } finally { scheduleNext(); } } }); if (mActive == null) { scheduleNext(); } } // scheduleNext从mTasks的对头取Runnable，通过THREAD_POOL_EXECUTOR // 执行Runnable，联系SerialExecutor的execute方法，就知道了一旦调用了 // SerialExecutor的execute方法，就会不断从mTasks取任务，然后交给线程池 // THREAD_POOL_EXECUTOR去执行，至于线程池是如何execute暂时不解释， // 只需要知道线程池会分配空闲的线程并执行传入的mFuture的run方法即可 protected synchronized void scheduleNext() { if ((mActive = mTasks.poll()) != null) { THREAD_POOL_EXECUTOR.execute(mActive); } } } // THREAD_POOL_EXECUTOR就是传说中的线程池，THREAD_POOL_EXECUTOR.execute // 会自动使用线程池中空闲的线程完成mActive的任务 /** * An {@link Executor} that can be used to execute tasks in parallel. */ public static final Executor THREAD_POOL_EXECUTOR; static { ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor( CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE_SECONDS, TimeUnit.SECONDS, sPoolWorkQueue, sThreadFactory); threadPoolExecutor.allowCoreThreadTimeOut(true); THREAD_POOL_EXECUTOR = threadPoolExecutor; } // 明白了sDefaultExecutor本质上是线程池，接下来看executeOnExecutor怎么调用线程池 @MainThread public final AsyncTask\u003cParams, Progress, Result\u003e executeOnExecutor(Executor exec, Params... params) { if (mStatus != Status.PENDING) { switch (mStatus) { case RUNNING: throw new IllegalStateException(\"Cannot execute task:\" + \" the task is already running.\"); case FINISHED: throw new IllegalStateException(\"Cannot execute task:\" + \" the task has already been executed \" + \"(a task can be executed only once)\"); } } // 首先设置了状态为RUNNING mStatus = Status.RUNNING; // 这里是不是很熟悉，我们继承AsyncTask时重写的onPreExecute方法 onPreExecute(); // 然后将参数保存在mWorker.mParams mWorker.mParams = params; // 调用exec.execute，这里的exec就是上面的SerialExecutor exec.execute(mFuture); return this; } // 此时我们需要明白mWorker和mFuture是什么，这里就要了解子类继承父类时，构造方法的执行了 // 在我们MyTask task = new MyTask();时，其实完成了父类的无参构造方法的执行，也就是AsyncTask // 的无参构造方法 /** * Creates a new asynchronous task. This constructor must be invoked on the UI thread. */ public AsyncTask() { this((Looper) null); } // 也就是说mWorker和mFuture在new MyTask()时已经完成了初始化 public AsyncTask(@Nullable Looper callbackLooper) { // callbackLooper为null，所以mHandler为getMainHandler方法的返回值， // 看名字就知道返回的是主线程的Handler，但是这个Handler有点东西 mHandler = callbackLooper == null || callbackLooper == Looper.getMainLooper() ? getMainHandler() : new Handler(callbackLooper); // mWorker提供了一个对象WorkerRunnable，WorkerRunnable实现了Callable接口的call方法 // 当mWorker的call方法被执行时，我们就可以得到结果 mWorker = new WorkerRunnable\u003cParams, Result\u003e() { public Result call() throws Exception { mTaskInvoked.set(true); Result result = null; try { Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND); //noinspection unchecked // 很熟悉的doInBackground方法，传入的参数为mWorker的mParams，即我们 // 在task.execute(\"beijing\", 50L);传入的参数 result = doInBackground(mParams); Binder.flushPendingCommands(); } catch (Throwable tr) { mCancelled.set(true); throw tr; } finally { postResult(result); } return result; } }; // mFuture以mWorker为参数实现了FutureTask，这里的FutureTask可以被SerialExecutor execute， // 会调用FutureTask的run方法，run方法中会执行mWorker的call方法，最终会调用FutureTask的done方法 mFuture = new FutureTask\u003cResult\u003e(mWorker) { @Override protected void done() { try { // get方法得到的是FutureTask执行run方法后得到的result postResultIfNotInvoked(get()); } catch (InterruptedException e) { android.util.Log.w(LOG_TAG, e); } catch (ExecutionException e) { throw new RuntimeException(\"An error occurred while executing doInBackground()\", e.getCause()); } catch (CancellationException e) { postResultIfNotInvoked(null); } } }; } // postResultIfNotInvoked会进一步处理结果 private void postResultIfNotInvoked(Result result) { final boolean wasTaskInvoked = mTaskInvoked.get(); if (!wasTaskInvoked) { postResult(result); } } // postResult通过主线程的Handler发送了数据result，并标记MESSAGE_POST_RESULT // 表示数据已经获取完毕，应该交给主线程处理 private Result postResult(Result result) { @SuppressWarnings(\"unchecked\") Message message = getHandler().obtainMessage(MESSAGE_POST_RESULT, new AsyncTaskResult\u003cResult\u003e(this, result)); message.sendToTarget(); return result; } // 还是记得上文介绍的Handler吗，它还有额外的功能 private static class InternalHandler extends Handler { public InternalHandler(Looper looper) { super(looper); } @SuppressWarnings({\"unchecked\", \"RawUseOfParameterizedType\"}) @Override public void handleMessage(Message msg) { // 在处理Message时，还可以判断并选择执行onProgressUpdate AsyncTaskResult\u003c?\u003e result = (AsyncTaskResult\u003c?\u003e) msg.obj; switch (msg.what) { // 上面说的数据获取完毕会标记MESSAGE_POST_RESULT case MESSAGE_POST_RESULT: // There is only one result // 调用mTask，这里就是AsyncTask的finish方法 result.mTask.finish(result.mData[0]); break; case MESSAGE_POST_PROGRESS: result.mTask.onProgressUpdate(result.mData); break; } } } // 熟悉的重写isCancelled和onPostExecute private void finish(Result result) { if (isCancelled()) { // 如果主动调用isCancelled则走onCancelled onCancelled(result); } else { // 或者最终回到我们重写的onPostExecute onPostExecute(result); } mStatus = Status.FINISHED; } // 以上就是正常的AsyncTask执行流程，但是别忘了我们有一个进度显示的功能 @WorkerThread protected final void publishProgress(Progress... values) { if (!isCancelled()) { // 通过Handler发送进度数据values // 这里就对应了上面的主线程的Handler的另一个功能，显示进度 getHandler().obtainMessage(MESSAGE_POST_PROGRESS, new AsyncTaskResult\u003cProgress\u003e(this, values)).sendToTarget(); } } 整理一下流程，很显然的是AsyncTask本质上还是基于Handler，但是在对线程的处理上采用了线程池，具体的执行过程：\n在new MyTask()时初始化了主线程的Handler和线程池，构造了FutureTask并提供了doInBackground的回调，并提供了通过sendToTarget的方式处理result和progress的方式； 当我们执行task.execute(\"beijing\", 50L);的方法时，提供了onPreExecute的回调，并将参数传给第1步中的FutureTask，然后使用SerialExecutor execute第1步构造的的FutureTask，本质上还是线程池，只是附加了功能：连续处理队列中的所有任务； 最后将得到结果通过上面sendToTarget后Handler的回调handleMessage处理发送的数据 仔细思考一下就会发现，AsyncTask提供了一个显示进度的方法，比较适用于上传下载文件的场景，因为下载进度与下载文件的大小是可知的，但是很多http框架比如Retrofit，可以很方便在接受Response的时候监听下载进度，导致AsyncTask无用武之处；同时对于登录注册功能来说，登录进度并不是很适合量化，所以也不适用；还有其他的场景我暂时也没有想到。这就导致了AsyncTask的作用被弱化了，除了集成doInBackground和onPostExecute方法就没有什么亮眼之处。\nAsyncTask也提供了带Looper或者Handler参数的构造函数，此时会影响的只有postResult和publishProgress方法，即这两个方法会发送消息到Looper的线程中，但是子线程的Handler需要自定义handleMessage并自行判断msg.what，包括MESSAGE_POST_RESULT和MESSAGE_POST_PROGRESS，实现从子线程到子线程的消息传递。\n3. EventBus EventBus比上面介绍的两种方式更加强大，除了线程间通信之外，还可以在Activity间传递消息，同时兼具灵活的线程切换功能，先直接上一个简单的例子，依然是请求和风天气数据\n1.首先使用EventBus需要自定义MessageEvent，即通过EventBus传递的消息载体\npublic class MessageEvent { private Object msg; public MessageEvent(Object msg) { this.msg = msg; } public Object getMsg() { return msg; } public void setMsg(Object msg) { this.msg = msg; } @Override public String toString() { return \"MessageEvent{\" + \"msg=\" + msg + '}'; } } 2.在需要处理消息的地方（Activity）中定义Subscribe方法，这个方法可以自动接收其他地方传来的消息\n// Subscribe注解修饰处理MessageEvent的方法，有几个参数threadMode、sticky、priority /** 首先是threadMode： POSTING：默认，表示事件处理函数的线程跟发布事件的线程在同一个线程。 MAIN：表示事件处理函数的线程在主线程(UI)线程，因此在这里不能进行耗时操作。 BACKGROUND：表示事件处理函数的线程在后台线程，因此不能进行UI操作。 如果发布事件的线程是主线程(UI线程)，那么事件处理函数将会开启一个后台线程， 如果果发布事件的线程是在后台线程，那么事件处理函数就使用该线程。 ASYNC：表示无论事件发布的线程是哪一个，事件处理函数始终会新建一个子线程运行，同样不能进行UI操作。 然后是sticky，sticky用于表示是否接收粘性事件 最后是priority，priority决定不同的Subscribe方法接收事件的优先级，数值越大越早接收， 先接受的Subscribe方法还可以禁止事件继续传递下去 1. 只有当两个订阅方法使用相同的ThreadMode参数的时候，它们的优先级才会与priority指定的值一致； 2. 只有当某个订阅方法的ThreadMode参数为POSTING的时候，它才能停止该事件的继续分发。 **/ // requestData方法用于处理发送的消息是String，其他则打印log @Subscribe(threadMode = ThreadMode.BACKGROUND) public void requestData(MessageEvent message) { if (message.getMsg() instanceof String) { Retrofit retrofit = new Retrofit.Builder() .baseUrl(URL) .addConverterFactory(GsonConverterFactory.create()) .build(); Api api = retrofit.create(Api.class); Call\u003cWeatherEntity\u003e call = api.getNowWeather(message.getMsg().toString(), KEY); try { // 通过EventBus把请求得到的天气发送出去 EventBus.getDefault().post(new MessageEvent(call.execute().body())); } catch (IOException e) { e.printStackTrace(); } } else if (message.getMsg() instanceof WeatherEntity) { Log.i(\"aaaa\", \"ThreadMode.BACKGROUND: \" + message.getMsg().toString()); } } // showMessage方法用于处理发送的消息是WeatherEntity，将其显示到TextView上，其他类型则打印log @Subscribe(threadMode = ThreadMode.MAIN) public void showMessage(MessageEvent message) { if (message.getMsg() instanceof WeatherEntity) { textView.setText(message.getMsg().toString()); } else if (message.getMsg() instanceof String) { Log.i(\"aaaa\", \"ThreadMode.MAIN: \" + message.getMsg().toString()); } } 3.在onStart和onStop中注册和取消注册\n@Override protected void onStart() { EventBus.getDefault().register(this); super.onStart(); } @Override protected void onStop() { EventBus.getDefault().unregister(this); super.onStop(); } 4.发送消息\n@Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); textView = findViewById(R.id.textView); textView.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { // 发送的消息本体是String，即请求的location EventBus.getDefault().post(new MessageEvent(\"beijing\")); } }); } 当我们点击textView的时候就会发送消息new MessageEvent(\"beijing\")出去，如果打断点观察消息发送的流程就会清楚：\n我们在主线程发送的消息会首先由ThreadMode.MAIN的方法处理，此时就会打印log： 然后消息会发送到requestData方法，而requestData方法是ThreadMode.BACKGROUND，所以它会在子线程中执行，我们在子线程中又发了new MessageEvent(call.execute().body())，因此消息会首先由ThreadMode.BACKGROUND的方法处理，即requestData方法自身，此时打印log； 最后消息又传到了showMessage方法中，而showMessage方法是ThreadMode.MAIN，所以可以执行在主线程，因此textView被设置了text，整个消息传递流程结束。 根据上面的例子基本可以了解了EventBus发送消息的机制，类似于广播，不同的threadMode参数决定这个方法的执行线程，而消息发送时会首先发到当前线程的方法中，如果在这个方法中消息没有被取消，则会继续广播到其他线程的方法中，具体顺序可以测试一下，直到没有可以处理此消息的方法，整个消息传播的流程就结束了。\n// 以下列方法处理从主线程发送的MessageEvent，我们观察一下log的顺序 @Subscribe(threadMode = ThreadMode.MAIN) public void broadcastMessage1(MessageEvent message) { Log.i(\"aaaa\", \"ThreadMode.MAIN: \" + message.getMsg().toString()); } @Subscribe(threadMode = ThreadMode.BACKGROUND) public void broadcastMessage2(MessageEvent message) { Log.i(\"aaaa\", \"ThreadMode.BACKGROUND: \" + message.getMsg().toString()); } @Subscribe(threadMode = ThreadMode.POSTING) public void broadcastMessage3(MessageEvent message) { Log.i(\"aaaa\", \"ThreadMode.POSTING: \" + message.getMsg().toString()); } @Subscribe(threadMode = ThreadMode.ASYNC) public void broadcastMessage4(MessageEvent message) { Log.i(\"aaaa\", \"ThreadMode.ASYNC: \" + message.getMsg().toString()); } 依次是MAIN -\u003e POSTING -\u003e BACKGROUND -\u003e ASYNC\n2019-07-28 20:40:38.419 28604-28604/com.example.gsondemo I/aaaa: ThreadMode.MAIN: beijing 2019-07-28 20:40:38.420 28604-28604/com.example.gsondemo I/aaaa: ThreadMode.POSTING: beijing 2019-07-28 20:40:38.421 28604-28765/com.example.gsondemo I/aaaa: ThreadMode.BACKGROUND: beijing 2019-07-28 20:40:38.422 28604-28766/com.example.gsondemo I/aaaa: ThreadMode.ASYNC: beijing 在看一下从BACKGROUND子线程发送的MessageEvent，依次是BACKGROUND -\u003e POSTING -\u003e MAIN -\u003e ASYNC\n2019-07-28 20:53:27.151 30433-30481/com.example.gsondemo I/aaaa: ThreadMode.BACKGROUND: shanghai 2019-07-28 20:53:27.151 30433-30481/com.example.gsondemo I/aaaa: ThreadMode.POSTING: shanghai 2019-07-28 20:53:27.152 30433-30433/com.example.gsondemo I/aaaa: ThreadMode.MAIN: shanghai 2019-07-28 20:53:27.152 30433-30482/com.example.gsondemo I/aaaa: ThreadMode.ASYNC: shanghai 消息广播的规则应该是首先是发送到post所在的线程，然后是POSTING，然后是其他线程，最后是ASYNC，因此我们可以在POSTING方法中取消消息的广播，那么消息就会被中断。\n普通事件删除 EventBus.getDefault().cancelEventDelivery(event); 粘性事件删除 //指定粘性事件删除 T stickyEvent = EventBus.getDefault().getStickyEvent(eventType); if (stickyEvent != null) { EventBus.getDefault().removeStickyEvent(stickyEvent); } //删除所有粘性事件 EventBus.getDefault().removeAllStickyEvents(); 除了普通事件之外，EventBus还可以发送粘性事件，解释起来比较复杂，简而言之就是让消息“飞一会”，在我们主动注册时才处理消息，用代码来解释\n// 代码是类似的，只是这次不在onStart方法内注册，而是通过button点击注册 @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); textView = findViewById(R.id.textView); button = findViewById(R.id.button); textView.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { // postSticky替代post EventBus.getDefault().postSticky(new MessageEvent(\"beijing\")); } }); button.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { EventBus.getDefault().register(MainActivity.this); } }); } // 增加sticky = true @Subscribe(threadMode = ThreadMode.BACKGROUND, sticky = true) public void requestData(MessageEvent message) { if (message.getMsg() instanceof String) { Retrofit retrofit = new Retrofit.Builder() .baseUrl(URL) .addConverterFactory(GsonConverterFactory.create()) .build(); Api api = retrofit.create(Api.class); Call\u003cWeatherEntity\u003e call = api.getNowWeather(message.getMsg().toString(), KEY); try { EventBus.getDefault().post(new MessageEvent(call.execute().body())); } catch (IOException e) { e.printStackTrace(); } } else if (message.getMsg() instanceof WeatherEntity) { Log.i(\"aaaa\", \"ThreadMode.BACKGROUND: \" + message.getMsg().toString()); } } // 增加sticky = true @Subscribe(threadMode = ThreadMode.MAIN, sticky = true) public void showMessage(MessageEvent message) { if (message.getMsg() instanceof WeatherEntity) { textView.setText(message.getMsg().toString()); } else if (message.getMsg() instanceof String) { Log.i(\"aaaa\", \"ThreadMode.MAIN: \" + message.getMsg().toString()); } } @Override protected void onStart() { super.onStart(); } @Override protected void onStop() { EventBus.getDefault().unregister(this); super.onStop(); } 这样的结果就是当我们点击textView时，事件就会发出，但是Subscribe方法没有接收，当且仅当我们点击了button时，事件才开始被接收，即我们让消息在运行时“飞了一会”，消息并不会丢失，当我们主动去注册时才开始处理，这就是粘性事件。\npriority就不详细解释了，对于有相同threadMode的方法，priority值越大越先接收到消息。\nEventBus源码解析暂时留个坑。\n4. RxJava RxJava – Reactive Extensions for the JVM – a library for composing asynchronous and event-based programs using observable sequences for the Java VM.\nRxJava也是一个可以用于处理线程间通信的工具，但是功能非常强大（不仅限于线程间通信），不仅可以用于Java Web项目也可以在Android项目中使用，RxJava的使用方式与上述各种工具或者框架不太一样，它是通过流式调用的形式使用的。目前有三个版本分别是Version 1.x、Version 2.x以及最新的Version 3.x，新版本加入新的特性比如背压、Java 8等等，这里仅演示RxJava2\nimplementation \"io.reactivex.rxjava2:rxjava:2.2.8\" // 必要rxjava2依赖 implementation \"io.reactivex.rxjava2:rxandroid:2.1.0\" // 必要rxandrroid依赖，切线程时需要用到AndroidSchedulers.mainThread() 4.1 RxJava结合Retrofit 还是以请求和风天气数据为例，这是Retrofit与RxJava的结合使用，RxJava使用的是观察者模式，这里就不详细解释\nRetrofit retrofit = new Retrofit.Builder() .baseUrl(URL) .addConverterFactory(GsonConverterFactory.create()) .addCallAdapterFactory(RxJava2CallAdapterFactory.create()) .build(); Api api = retrofit.create(Api.class); // 这里的getNowWeather方法在Api.java中返回的是Observable api.getNowWeather(\"beijing\", KEY) .subscribeOn(Schedulers.io()) // subscribeOn参数为io线程，表明getNowWeather请求数据执行在io线程 .observeOn(AndroidSchedulers.mainThread()) // observeOn参数为主线程，表明请求结束传递的数据在主线程处理 .subscribe(new Consumer\u003cWeatherEntity\u003e() { // subscribe定义上面observeOn进行的方法，RxJava2中以Consumer代理处理，一般来说有两个Consumer，一个用于处理请求成功的数据，另一个处理异常 @Override public void accept(WeatherEntity weatherEntity) throws Exception { textView.setText(weatherEntity.toString()); } }, new Consumer\u003cThrowable\u003e() { @Override public void accept(Throwable throwable) throws Exception { Log.i(\"aaaa\", throwable.getMessage()); } }); 4.2 RxJava源码分析 虽然上面的代码只演示了RxJava的线程切换功能，但是实际上RxJava的功能非常强大，在处理大量数据的情况下能够更加简洁有效的代码完成，同时兼具数据变换的功能，这里三言两语很难表述清除，需要实战演练就能够明白，与此同时，基于RxJava我们也可以自定义更多的工具函数，以RxJava流式调用的方式来使用。\nObservable警告：RxJava提供的各种方法比如subscribeOn、observeOn以及doOnNext等都会创建新的Observable和Observer，Observable是数据的被观察者，它保存了我们需要的数据；Observer是数据的观察者，数据如何发送、在哪个线程处理、如何处理异常等都是通过Observer处理的，一般来说每一个自定义的Observable都有一个内部类Observer，只是这个Observer是给上一级的Observable调用\n首先我们需要知道retrofit.create(Api.class)创建了什么，这个在Retrofit框架分析中已经做过了，在这种情况下是通过RxJava2CallAdapterFactory的RxJava2CallAdapter调用adapt方法返回的Observable\n// RxJava2CallAdapter.java @Override public Object adapt(Call\u003cR\u003e call) { // 首先是创建CallExecuteObservable Observable\u003cResponse\u003cR\u003e\u003e responseObservable = isAsync ? new CallEnqueueObservable\u003c\u003e(call) : new CallExecuteObservable\u003c\u003e(call); Observable\u003c?\u003e observable; if (isResult) { observable = new ResultObservable\u003c\u003e(responseObservable); } else if (isBody) { // 然后根据参数，返回的是BodyObservable observable = new BodyObservable\u003c\u003e(responseObservable); } else { observable = responseObservable; } if (scheduler != null) { observable = observable.subscribeOn(scheduler); } if (isFlowable) { return observable.toFlowable(BackpressureStrategy.LATEST); } if (isSingle) { return observable.singleOrError(); } if (isMaybe) { return observable.singleElement(); } if (isCompletable) { return observable.ignoreElements(); } return RxJavaPlugins.onAssembly(observable); } 而BodyObservable继承自Observable，并且有一个内部类BodyObserver\n// BodyObservable.java final class BodyObservable\u003cT\u003e extends Observable\u003cT\u003e { private final Observable\u003cResponse\u003cT\u003e\u003e upstream; BodyObservable(Observable\u003cResponse\u003cT\u003e\u003e upstream) { this.upstream = upstream; } // subscribeActual方法会在Observable调用subscribe方法时被调用 @Override protected void subscribeActual(Observer\u003c? super T\u003e observer) { upstream.subscribe(new BodyObserver\u003cT\u003e(observer)); } private static class BodyObserver\u003cR\u003e implements Observer\u003cResponse\u003cR\u003e\u003e { private final Observer\u003c? super R\u003e observer; private boolean terminated; BodyObserver(Observer\u003c? super R\u003e observer) { this.observer = observer; } // BodyObserver实现了Observer的4个方法onSubscribe、onNext、onComplete、onError， // 但是不是BodyObserver自己完成的，而是通过传入的observer代替完成大部分功能，而BodyObserver // 只对传过来的Response进行简单判断就交给observer了 @Override public void onSubscribe(Disposable disposable) { observer.onSubscribe(disposable); } @Override public void onNext(Response\u003cR\u003e response) { if (response.isSuccessful()) { // 比如判断response是否是成功从服务器返回的，然后交给observer的onNext方法， // 此时传给observer的就是response的body了，对应我们使用的GsonConverterFactory， // 那这个body就是WeatherEntity实例 observer.onNext(response.body()); } else { terminated = true; Throwable t = new HttpException(response); try { observer.onError(t); } catch (Throwable inner) { Exceptions.throwIfFatal(inner); RxJavaPlugins.onError(new CompositeException(t, inner)); } } } @Override public void onComplete() { if (!terminated) { observer.onComplete(); } } @Override public void onError(Throwable throwable) { if (!terminated) { observer.onError(throwable); } else { // This should never happen! onNext handles and forwards errors automatically. Throwable broken = new AssertionError( \"This should never happen! Report as a bug with the full stacktrace.\"); //noinspection UnnecessaryInitCause Two-arg AssertionError constructor is 1.7+ only. broken.initCause(throwable); RxJavaPlugins.onError(broken); } } } } 创建完Observable后紧接着是subscribeOn、observeOn以及subscribe方法，很显然这些方法都是Observable的方法\n// Observable.java @CheckReturnValue @SchedulerSupport(SchedulerSupport.CUSTOM) public final Observable\u003cT\u003e subscribeOn(Scheduler scheduler) { ObjectHelper.requireNonNull(scheduler, \"scheduler is null\"); return RxJavaPlugins.onAssembly(new ObservableSubscribeOn\u003cT\u003e(this, scheduler)); } // Observable.java @NonNull public static \u003cT\u003e Observable\u003cT\u003e onAssembly(@NonNull Observable\u003cT\u003e source) { // 一般来说onObservableAssembly在没有调用reset方法的情况下为空，所以这里肯定为空 Function\u003c? super Observable, ? extends Observable\u003e f = onObservableAssembly; if (f != null) { return apply(f, source); } // 也就是说这个onAssembly方法直接返回了source，所以上面的subscribeOn方法返回的是ObservableSubscribeOn return source; } subscribeOn方法之后我们得到了一个新的ObservableSubscribeOn，它保存了BodyObservable以及加入的参数Schedulers.io()，接下来继续调用observeOn\n// Observable.java @CheckReturnValue @SchedulerSupport(SchedulerSupport.CUSTOM) public final Observable\u003cT\u003e observeOn(Scheduler scheduler) { return observeOn(scheduler, false, bufferSize()); } @CheckReturnValue @SchedulerSupport(SchedulerSupport.CUSTOM) public final Observable\u003cT\u003e observeOn(Scheduler scheduler, boolean delayError, int bufferSize) { ObjectHelper.requireNonNull(scheduler, \"scheduler is null\"); ObjectHelper.verifyPositive(bufferSize, \"bufferSize\"); // observeOn显然又返回了一个ObservableObserveOn return RxJavaPlugins.onAssembly(new ObservableObserveOn\u003cT\u003e(this, scheduler, delayError, bufferSize)); } observeOn方法之后我们得到了新的ObservableObserveOn，它保存了ObservableSubscribeOn以及参数AndroidSchedulers.mainThread()，最后调用subscribe方法\n// Observable.java @CheckReturnValue @SchedulerSupport(SchedulerSupport.NONE) public final Disposable subscribe(Consumer\u003c? super T\u003e onNext, Consumer\u003c? super Throwable\u003e onError) { // subscribe方法可以接受多种参数，比如我这里对应上面的两个Consumer参数，其中第一个Consumer名字是onNext， // 第二个Consumer名字是onError，看到这里基本上明白了这两个Consumer的功能，就是执行处理onNext传入的数据以及处理 // onError传入的异常 return subscribe(onNext, onError, Functions.EMPTY_ACTION, Functions.emptyConsumer()); } @CheckReturnValue @SchedulerSupport(SchedulerSupport.NONE) public final Disposable subscribe(Consumer\u003c? super T\u003e onNext, Consumer\u003c? super Throwable\u003e onError, Action onComplete, Consumer\u003c? super Disposable\u003e onSubscribe) { ObjectHelper.requireNonNull(onNext, \"onNext is null\"); ObjectHelper.requireNonNull(onError, \"onError is null\"); ObjectHelper.requireNonNull(onComplete, \"onComplete is null\"); ObjectHelper.requireNonNull(onSubscribe, \"onSubscribe is null\"); // 然后对onNext、onError、onComplete、onSubscribe四个Consumer进行封装， // 整合成一个LambdaObserver，也就是说，本质上我们subscribe的参数最终还是Observer LambdaObserver\u003cT\u003e ls = new LambdaObserver\u003cT\u003e(onNext, onError, onComplete, onSubscribe); subscribe(ls); return ls; } @SchedulerSupport(SchedulerSupport.NONE) @Override public final void subscribe(Observer\u003c? super T\u003e observer) { ObjectHelper.requireNonNull(observer, \"observer is null\"); try { // RxJavaPlugins.onSubscribe类似上面的onAssembly方法，这里没有做任何操作 // 等价于observer = observer observer = RxJavaPlugins.onSubscribe(this, observer); ObjectHelper.requireNonNull(observer, \"The RxJavaPlugins.onSubscribe hook returned a null Observer. Please change the handler provided to RxJavaPlugins.setOnObservableSubscribe for invalid null returns. Further reading: https://github.com/ReactiveX/RxJava/wiki/Plugins\"); // 然后调用subscribeActual，要知道ObservableObserveOn中重写了subscribeActual方法，所以我们再回到 // ObservableObserveOn中，需要记住的是这个observer保存了我们定义的两个Consumer subscribeActual(observer); } catch (NullPointerException e) { // NOPMD throw e; } catch (Throwable e) { Exceptions.throwIfFatal(e); // can't call onError because no way to know if a Disposable has been set or not // can't call onSubscribe because the call might have set a Subscription already RxJavaPlugins.onError(e); NullPointerException npe = new NullPointerException(\"Actually not, but can't throw other exceptions due to RS\"); npe.initCause(e); throw npe; } } 前面的构造Observable的顺序是：CallExecuteObservable -\u003e BodyObservable -\u003e ObservableSubscribeOn -\u003e ObservableObserveOn，每一级Observable都是以上一级Observable作为参数够早的，CallExecuteObservable和BodyObservable是没有设置Scheduler参数的，ObservableSubscribeOn和ObservableObserveOn有Scheduler参数，Scheduler参数决定了Observer执行的线程；当我们调用subscribe方法会自底向上依次调用Observable的subscribeActual方法，在调用subscribeActual方法是会调用上一级的subscribe方法，传入的参数就是Observer，Observer的构造顺序是：自定义Consumer -\u003e LambdaObserver -\u003e ObserveOnObserver -\u003e SubscribeOnObserver -\u003e BodyObserver，最顶层的CallExecuteObservable是没有Observer的，每一级的Observer都会以下一级的Observer作为参数\n// ObservableObserveOn.java @Override protected void subscribeActual(Observer\u003c? super T\u003e observer) { // source就是ObservableObserveOn构造时传入的第一个参数，对应ObservableSubscribeOn， // 由于scheduler对应AndroidSchedulers.mainThread()，本质上是HandlerScheduler if (scheduler instanceof TrampolineScheduler) { source.subscribe(observer); } else { // 调用的是HandlerScheduler的createWorker方法,返回的是HandlerWorker， // HandlerWorker保存了两个参数，一个是Handler，另一个bool async， // 因为AndroidSchedulers.mainThread()，所以此处的Handler是new Handler(Looper.getMainLooper())， // 即主线程中的Handler，async为false Scheduler.Worker w = scheduler.createWorker(); // 构造新的ObserveOnObserver，传入的参数有LambdaObserver和HandlerWorker // 然后调用ObservableSubscribeOn的subscribe方法，这是一个递归调用，subscribe就是上面的， // 又因为subscribeActual，所以还是调用ObservableSubscribeOn的subscribeActual方法 source.subscribe(new ObserveOnObserver\u003cT\u003e(observer, w, delayError, bufferSize)); } } 当我们走到了ObservableSubscribeOn的subscribeActual方法时，需要开始使用observer（上一级Observable的内部类Observer）进行预处理或者发送数据，因为RxJava的onSubscribe是最先被调用的，所以我们需要先调用onSubscribe方法，会依次向上调用Observer的onSubscribe方法，由于Observer保存了如何发送数据的方法onNext以及处理异常的方法onError以及表示已完成的onComplete，所以如果传到最上级的Observable，那么就可以在CallExecuteObservable的subscribeActual方法中调用传入的Observer的各种方法，从而对数据进行发送、处理等\n// ObservableSubscribeOn.java @Override public void subscribeActual(final Observer\u003c? super T\u003e observer) { // observer是上面构造的ObserveOnObserver，将其转换为SubscribeOnObserver // 将上一级传进来的订阅者包装为线程安全的原子变量 final SubscribeOnObserver\u003cT\u003e parent = new SubscribeOnObserver\u003cT\u003e(observer); // 然后调用ObserveOnObserver的onSubscribe，调用onSubscribe即开始预处理，onSubscribe会调用 // 我们定义的Consumer（本示例未使用onSubscribe的Consumer，所以没有做任何操作） observer.onSubscribe(parent); // ObservableSubscribeOn的scheduler对应Schedulers.io()，即IoScheduler // SubscribeTask会被放在BlockingQueue队列中，这里就是开始执行我们实际请求的关键转折了， // 之前都是铺垫，然后在指定的线程中执行source(上一级)的subscribe，即IO线程的工作 // source.subscribe(parent)，这里的source实际就是BodyObservable parent.setDisposable(scheduler.scheduleDirect(new SubscribeTask(parent))); } final class SubscribeTask implements Runnable { private final SubscribeOnObserver\u003cT\u003e parent; SubscribeTask(SubscribeOnObserver\u003cT\u003e parent) { this.parent = parent; } @Override public void run() { // 这里的source是BodyObservable source.subscribe(parent); } } scheduler的作用就是通过内部Worker将task交给线程池进行处理，因为ObservableSubscribeOn是通过调用subscribeOn方法生成的，因此很大程度上会运行在其他线程，也就是说SubscribeTask的run方法是执行在Worker的线程池中，即从现在开始的subscribe都是在Worker线程中而不是主线程了\n// Scheduler.java @NonNull public Disposable scheduleDirect(@NonNull Runnable run) { return scheduleDirect(run, 0L, TimeUnit.NANOSECONDS); } @NonNull public Disposable scheduleDirect(@NonNull Runnable run, long delay, @NonNull TimeUnit unit) { // 这个createWorker就是IoScheduler的createWorker，返回的是EventLoopWorker，此EventLoopWorker // 运行的线程通过线程池CachedWorkerPool提供 final Worker w = createWorker(); final Runnable decoratedRun = RxJavaPlugins.onSchedule(run); DisposeTask task = new DisposeTask(decoratedRun, w); // w.schedule会在ScheduledThreadPoolExecutor中安排task被执行，task会被放在队列中 w.schedule(task, delay, unit); return task; } 在看BodyObservable的subscribe方法前先看一下onSubscribe做了些什么\n// ObservableObserveOn.java 内部类ObserveOnObserver的onSubscribe方法 @Override public void onSubscribe(Disposable d) { if (DisposableHelper.validate(this.upstream, d)) { this.upstream = d; // 这里的d是SubscribeOnObserver，所以跳过 if (d instanceof QueueDisposable) { @SuppressWarnings(\"unchecked\") QueueDisposable\u003cT\u003e qd = (QueueDisposable\u003cT\u003e) d; int m = qd.requestFusion(QueueDisposable.ANY | QueueDisposable.BOUNDARY); if (m == QueueDisposable.SYNC) { sourceMode = m; queue = qd; done = true; downstream.onSubscribe(this); schedule(); return; } if (m == QueueDisposable.ASYNC) { sourceMode = m; queue = qd; downstream.onSubscribe(this); return; } } // 这个队列用于保存数据，之后会用，bufferSize大小默认是128 queue = new SpscLinkedArrayQueue\u003cT\u003e(bufferSize); // 而downstream是ObserveOnObserver构造函数的第一个参数，即我们调用subscribe方法时 // 传入的LambdaObserver（但是通过Consumer实现的） downstream.onSubscribe(this); } } // LambdaObserver.java @Override public void onSubscribe(Disposable d) { if (DisposableHelper.setOnce(this, d)) { try { // onSubscribe也只是调用onSubscribe.accept，还记得上面我们的LambdaObserver构造时仅使用了 // onNext和onError，所以onSubscribe其实是空的，这里没有任何作用 onSubscribe.accept(this); } catch (Throwable ex) { Exceptions.throwIfFatal(ex); d.dispose(); onError(ex); } } } 回到subscribe的调用链，在子线程（线程池）\n// BodyObservable.java @Override protected void subscribeActual(Observer\u003c? super T\u003e observer) { // 这里的upstream是CallExecuteObservable upstream.subscribe(new BodyObserver\u003cT\u003e(observer)); } 通过subscribe最终调用到了最顶层的Observable的subscribeActual方法，且传入的下一级的内部类Observer，用于提供onXXX方法传递数据，执行在子线程（线程池）\n// CallExecuteObservable.java @Override protected void subscribeActual(Observer\u003c? super Response\u003cT\u003e\u003e observer) { // Since Call is a one-shot type, clone it for each new observer. Call\u003cT\u003e call = originalCall.clone(); CallDisposable disposable = new CallDisposable(call); // CallExecuteObservable是我们实际开始调用Retrofit请求数据的开始 // 首先需要调用observer的onSubscribe，这里是BodyObserver， // 还记得上面的LambdaObserver的onSubscribe， // 这里其实什么事情都没有做 observer.onSubscribe(disposable); if (disposable.isDisposed()) { return; } boolean terminated = false; try { // 然后调用call.execute()，如果记得Retrofit，那么就知道这里发出了请求，也就是说这个方法执行在IO线程 Response\u003cT\u003e response = call.execute(); if (!disposable.isDisposed()) { // 然后通过onNext方法将结果发射出去，这个observer就是BodyObserver observer.onNext(response); } if (!disposable.isDisposed()) { terminated = true; observer.onComplete(); } } catch (Throwable t) { Exceptions.throwIfFatal(t); if (terminated) { RxJavaPlugins.onError(t); } else if (!disposable.isDisposed()) { try { observer.onError(t); } catch (Throwable inner) { Exceptions.throwIfFatal(inner); RxJavaPlugins.onError(new CompositeException(t, inner)); } } } } onNext方法的向下一级传递\n// BodyObservable.java 内部类BodyObserver的onNext方法 @Override public void onNext(Response\u003cR\u003e response) { if (response.isSuccessful()) { // BodyObserver判断了一下请求结果response，然后将body发射出去 // 这里的observer就是SubscribeOnObserver observer.onNext(response.body()); } else { terminated = true; Throwable t = new HttpException(response); try { observer.onError(t); } catch (Throwable inner) { Exceptions.throwIfFatal(inner); RxJavaPlugins.onError(new CompositeException(t, inner)); } } } // ObservableSubscribeOn.java 内部类SubscribeOnObserver @Override public void onNext(T t) { // 这里的downstream是ObserveOnObserver downstream.onNext(t); } 这里因为ObservableObserveOn是通过observeOn创建的，而这里发生了线程切换，我们的例子中是主线程，所以需要通过Handler将后续的任务切换到主线程中\n// ObservableObserveOn.java 内部类ObserveOnObserver @Override public void onNext(T t) { if (done) { return; } if (sourceMode != QueueDisposable.ASYNC) { // 这里的queue是SpscLinkedArrayQueue，我们把传出来的数据保存在队列中了 queue.offer(t); } // 最终调用schedule schedule(); } void schedule() { if (getAndIncrement() == 0) { // worker是初始化时调用observeOn传入的主线程的HandlerScheduler的内部类HandlerWorker， // 这里的schedule方法传入this，即ObserveOnObserver，与此同时ObserveOnObserver // 实现了Runnable的接口，可以作为Runnable，它的run方法会在下面被执行 worker.schedule(this); } } // HandlerScheduler.java 内部类HandlerWorker @Override @SuppressLint(\"NewApi\") // Async will only be true when the API is available to call. public Disposable schedule(Runnable run, long delay, TimeUnit unit) { if (run == null) throw new NullPointerException(\"run == null\"); if (unit == null) throw new NullPointerException(\"unit == null\"); if (disposed) { return Disposables.disposed(); } run = RxJavaPlugins.onSchedule(run); // HandlerWorker的schedule方法，我们传入的run即上面的ObserveOnObserver // ScheduledRunnable也是Runnable，但是它的run方法仅仅是调用了传入的run的run方法 // 也就是说如果我们执行了scheduled的run方法等价于执行了run的方法，也就是 // ObserveOnObserver的run方法 ScheduledRunnable scheduled = new ScheduledRunnable(handler, run); // scheduled的run方法执行是通过handler处理的，通过sendMessageDelayed实现的 Message message = Message.obtain(handler, scheduled); message.obj = this; // Used as token for batch disposal of this worker's runnables. if (async) { message.setAsynchronous(true); } // 也就是在这里我们将在主线程执行ObserveOnObserver的run方法 handler.sendMessageDelayed(message, unit.toMillis(delay)); // Re-check disposed state for removing in case we were racing a call to dispose(). if (disposed) { handler.removeCallbacks(scheduled); return Disposables.disposed(); } return scheduled; } // ObservableObserveOn.java 内部类ObserveOnObserver @Override public void run() { if (outputFused) { drainFused(); } else { // 这里执行的是drainNormal drainNormal(); } } void drainNormal() { int missed = 1; // 还记得上面的SpscLinkedArrayQueue，之前我们在onNext方法中把传过来的数据保存在队列中 // 接下来需要从队列中取出数据 final SimpleQueue\u003cT\u003e q = queue; // downstream即LambdaObserver final Observer\u003c? super T\u003e a = downstream; // 这里用循环是因为RxJava支持连续发送多个数据，那么最终数据都保存在队列中 // 所以取数据的时候就可以通过循环来一次性获取队列中的所有数据，而SpscLinkedArrayQueue // 的最大容量，根据之前的代码我们知道是128 for (;;) { if (checkTerminated(done, q.isEmpty(), a)) { return; } for (;;) { boolean d = done; T v; try { // q.poll从队列中取出数据 v = q.poll(); } catch (Throwable ex) { Exceptions.throwIfFatal(ex); disposed = true; upstream.dispose(); q.clear(); a.onError(ex); worker.dispose(); return; } boolean empty = v == null; if (checkTerminated(d, empty, a)) { return; } if (empty) { break; } // a即为LambdaObserver，v为我们从队列中取出来的数据，也是 // 我们通过handler传入的数据，通过onNext发出，而这个onNext // 就是我们定义的第一个Consumer，通过这个Consumer的accept方法 // 在主线程实现TextView的设置 a.onNext(v); } missed = addAndGet(-missed); if (missed == 0) { break; } } } // LambdaObserver.java @Override public void onNext(T t) { if (!isDisposed()) { try { // 我们定义的Consumer的accept方法 onNext.accept(t); } catch (Throwable e) { Exceptions.throwIfFatal(e); get().dispose(); onError(e); } } } 综上，RxJava的简单源码分析流程就完成了，整个RxJava调用流程可以分为两个阶段：构造阶段和subscribe阶段，在调用subscribe方法前的步骤我称之为构造阶段，这个过程中主要工作是创建被观察者Observable，每一次使用RxJava的方法时都会创建新的Observable，每个新的Observable都会以上一级的Observable作为参数，其中部分Observable还需要Scheduler参数，用于切换线程，构造阶段仅仅是将Observable连接起来；在调用subscribe方法时开始了subscribe阶段，这个阶段的任务是将我们自定义的Consumer（或者可以当作观察者Observer）通过Observable的subscribe方法连接起来（subscribe的过程中可能会调用onSubscribe方法进行预处理，初始化一些队列什么的，onSubscribe方法与onNext、onError、onComplete方法有点区别），当我们的subscribe方法走到最顶层时会开始启动Observer的onXXX方法传递数据或者传出异常等等，因为之前已经将Observer连接起来，所以此时onXXX方法的调用也是链式的，层层向下传递，直到调用我们自定义的Consumer（在此过程中会通过在构造阶段传入的Scheduler实现线程切换）。\n如果完整的看过一遍分析流程就会发现其实Observable和Observer的调用链是很简单的，但是随之也有几个疑问：\n1.为什么要用Observable和Observer的形式？\n首先需要明白的是，RxJava的目的是提供一个便于进行数据处理的框架，通过流式调用实现线程切换、数据类型转换等，也就是说数据从A -\u003e B -\u003e C可以是不同类型的数据或者是在不同线程处理，最适合的模式就是观察者模式，比如我们常见的OnClickListener，它传递的是点击事件，再比如我们自定义的传递数据的接口回调，都是观察者模式。简而言之就是，A通过B提供的接口将数据传到B中进行处理，B通过C提供的接口将数传到C中进行处理，由此可以进行数据的传递，当然这只是数据传递的流程，具体的调用流程就是上面的总结。使用Observable和Observer的形式，一是便于我们自定义数据转换的Observable和Observer，二是可以实现流式调用，三是这里面实现了这种接口回调的功能。\n2.subscribeOn和observeOn是如何切换线程的？\nsubscribeOn会指定我们在调用subscribeOn之前的Observable中数据处理的线程，observeOn会指定我们在调用observeOn之后的Observable中数据处理的线程。这是因为两者切换线程的位置不同，subscribeOn会在subscribeActual的方法中切换线程，导致后续所有的调用都是在subscribeOn指定的线程中，而subscribeActual方法是自底向上调用的，因此会影响subscribeOn之前的所有方法；而observeOn是在ObserveOnObserver的onNext方法中进行线程切换的，因此会影响observeOn后面数据传递的方法。\n参考： RxJava2 EventBus Android Handler 消息机制详述 Android 多线程：手把手教你使用AsyncTask EventBus使用详解 Rxjava这一篇就够了，墙裂推荐 精彩的RxJava源码剖析 给 Android 开发者的 RxJava 详解 ","wordCount":"4459","inLanguage":"en","datePublished":"2019-07-25T20:32:26+08:00","dateModified":"2019-07-25T20:32:26+08:00","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://zhoutao822.github.io/posts/rxjava/"},"publisher":{"@type":"Organization","name":"Tao's Notes","logo":{"@type":"ImageObject","url":"https://zhoutao822.github.io/favicon.ico"}}}</script></head><body class=dark id=top><header class=header><nav class=nav><div class=logo><a href=https://zhoutao822.github.io/ accesskey=h title="Home (Alt + H)">Home</a>
<span class=logo-switches></span></div><ul id=menu><li><a href=https://zhoutao822.github.io/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://zhoutao822.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://zhoutao822.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://zhoutao822.github.io/series/ title=Series><span>Series</span></a></li><li><a href=https://zhoutao822.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://zhoutao822.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://zhoutao822.github.io/posts/>Posts</a></div><h1 class=post-title>Android框架-RxJava</h1><div class=post-meta><span title='2019-07-25 20:32:26 +0800 +0800'>July 25, 2019</span>&nbsp;·&nbsp;21 min&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/Zhoutao822/zhoutao822.github.io/tree/main/content//posts/RxJava.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#1-handler aria-label="1. Handler">1. Handler</a><ul><li><a href=#11-handler%e7%ae%80%e5%8d%95%e4%bd%bf%e7%94%a8 aria-label="1.1 Handler简单使用">1.1 Handler简单使用</a></li><li><a href=#12-handler%e7%ba%bf%e7%a8%8b%e9%97%b4%e9%80%9a%e4%bf%a1 aria-label="1.2 Handler线程间通信">1.2 Handler线程间通信</a></li><li><a href=#13-handler%e6%ba%90%e7%a0%81%e5%88%86%e6%9e%90 aria-label="1.3 Handler源码分析">1.3 Handler源码分析</a></li><li><a href=#14-handler%e8%bf%9b%e9%98%b6 aria-label="1.4 Handler进阶">1.4 Handler进阶</a></li></ul></li><li><a href=#2-asynctask aria-label="2. AsyncTask">2. AsyncTask</a><ul><li><a href=#21-asynctask%e7%ae%80%e5%8d%95%e4%bd%bf%e7%94%a8 aria-label="2.1 AsyncTask简单使用">2.1 AsyncTask简单使用</a></li><li><a href=#22-asynctask%e6%ba%90%e7%a0%81%e5%88%86%e6%9e%90 aria-label="2.2 AsyncTask源码分析">2.2 AsyncTask源码分析</a></li></ul></li><li><a href=#3-eventbus aria-label="3. EventBus">3. EventBus</a></li><li><a href=#4-rxjava aria-label="4. RxJava">4. RxJava</a><ul><li><a href=#41-rxjava%e7%bb%93%e5%90%88retrofit aria-label="4.1 RxJava结合Retrofit">4.1 RxJava结合Retrofit</a></li><li><a href=#42-rxjava%e6%ba%90%e7%a0%81%e5%88%86%e6%9e%90 aria-label="4.2 RxJava源码分析">4.2 RxJava源码分析</a></li></ul></li><li><a href=#%e5%8f%82%e8%80%83 aria-label=参考：>参考：</a></li></ul></div></details></div><div class=post-content><p>Android中很多地方都需要跨线程通信，这是由于Android主线程不允许进行复杂的网络请求或者其他非常耗时的操作，否则会导致ANR，主线程只能进行UI操作，比如修改某个控件的text、设置某个控件不可见等等，因此网络请求等操作需要在其他线程中完成，当数据在其他线程中获取完毕时，通过跨线程通信将数据传到主线程中，主线程就可以直接根据数据进行UI操作。常见的跨线程通信的方式有Handler、AsyncTask、EventBus以及RxJava等，前两个是Android自带，后两者是封装好的第三方库。</p><h2 id=1-handler>1. Handler<a hidden class=anchor aria-hidden=true href=#1-handler>#</a></h2><p>Handler是Android中最简单的线程间通信方式，同时也可以在同一个线程中发送消息，但是使用时需要注意内存泄漏的问题。</p><h3 id=11-handler简单使用>1.1 Handler简单使用<a hidden class=anchor aria-hidden=true href=#11-handler简单使用>#</a></h3><p>还是以和风天气请求为例，我们的目标是在子线程中请求数据，然后通过Handler将数据传到主线程中并显示出来。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MainActivity</span> <span style=color:#66d9ef>extends</span> AppCompatActivity <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>static</span> String KEY <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;XXXXXXXXXX&#34;</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>static</span> String URL <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;https://free-api.heweather.net/s6/weather/&#34;</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> TextView textView<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> Handler handler<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>onCreate</span><span style=color:#f92672>(</span>Bundle savedInstanceState<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>super</span><span style=color:#f92672>.</span><span style=color:#a6e22e>onCreate</span><span style=color:#f92672>(</span>savedInstanceState<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        setContentView<span style=color:#f92672>(</span>R<span style=color:#f92672>.</span><span style=color:#a6e22e>layout</span><span style=color:#f92672>.</span><span style=color:#a6e22e>activity_main</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        textView <span style=color:#f92672>=</span> findViewById<span style=color:#f92672>(</span>R<span style=color:#f92672>.</span><span style=color:#a6e22e>id</span><span style=color:#f92672>.</span><span style=color:#a6e22e>textView</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Handler的实例化，重写handleMessage方法用于等待处理msg，
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// handleMessage方法是回调，在回调中更新UI，此时执行在主线程，
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// 在Android Studio中会提示这里存在内存泄漏问题
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        handler <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Handler<span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>handleMessage</span><span style=color:#f92672>(</span>Message msg<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>super</span><span style=color:#f92672>.</span><span style=color:#a6e22e>handleMessage</span><span style=color:#f92672>(</span>msg<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>                textView<span style=color:#f92672>.</span><span style=color:#a6e22e>setText</span><span style=color:#f92672>(</span>msg<span style=color:#f92672>.</span><span style=color:#a6e22e>obj</span><span style=color:#f92672>.</span><span style=color:#a6e22e>toString</span><span style=color:#f92672>());</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>};</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 在子线程开启一个网络请求
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>new</span> Thread<span style=color:#f92672>(</span><span style=color:#66d9ef>new</span> Runnable<span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>run</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// Retrofit通用代码
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                Retrofit retrofit <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Retrofit<span style=color:#f92672>.</span><span style=color:#a6e22e>Builder</span><span style=color:#f92672>()</span>
</span></span><span style=display:flex><span>                        <span style=color:#f92672>.</span><span style=color:#a6e22e>baseUrl</span><span style=color:#f92672>(</span>URL<span style=color:#f92672>)</span> <span style=color:#75715e>// 设置网络请求的公共Url地址
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                        <span style=color:#f92672>.</span><span style=color:#a6e22e>addConverterFactory</span><span style=color:#f92672>(</span>GsonConverterFactory<span style=color:#f92672>.</span><span style=color:#a6e22e>create</span><span style=color:#f92672>())</span> <span style=color:#75715e>// 设置数据解析器
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                        <span style=color:#f92672>.</span><span style=color:#a6e22e>build</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                Api api <span style=color:#f92672>=</span> retrofit<span style=color:#f92672>.</span><span style=color:#a6e22e>create</span><span style=color:#f92672>(</span>Api<span style=color:#f92672>.</span><span style=color:#a6e22e>class</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>                Call<span style=color:#f92672>&lt;</span>WeatherEntity<span style=color:#f92672>&gt;</span> call <span style=color:#f92672>=</span> api<span style=color:#f92672>.</span><span style=color:#a6e22e>getNowWeather</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;beijing&#34;</span><span style=color:#f92672>,</span> KEY<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>try</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// 为了在当前子线程获取数据，这里直接使用execute
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    WeatherEntity result <span style=color:#f92672>=</span> call<span style=color:#f92672>.</span><span style=color:#a6e22e>execute</span><span style=color:#f92672>().</span><span style=color:#a6e22e>body</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// Message的实例化方法Message.obtain
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    Message message <span style=color:#f92672>=</span> Message<span style=color:#f92672>.</span><span style=color:#a6e22e>obtain</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// 可以通过Message附加很多数据，这里仅用obj，保存我们网络请求得到的实例
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    message<span style=color:#f92672>.</span><span style=color:#a6e22e>obj</span> <span style=color:#f92672>=</span> result<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// 通过handler.sendMessage(message)实现调用回调方法，完成数据传输
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#75715e>// 这种操作有点类似于接口回调
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    handler<span style=color:#f92672>.</span><span style=color:#a6e22e>sendMessage</span><span style=color:#f92672>(</span>message<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>                <span style=color:#f92672>}</span> <span style=color:#66d9ef>catch</span> <span style=color:#f92672>(</span>IOException e<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                    e<span style=color:#f92672>.</span><span style=color:#a6e22e>printStackTrace</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>                <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}).</span><span style=color:#a6e22e>start</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p>这里的内存泄露的原因可以参考其他资料，主要是<strong>Java 中非静态内部类和匿名内部类会持有外部类的引用</strong>同时<strong>Handler 的生命周期比外部类长</strong>导致的。如何解决，肯定就是让Handler是静态内部类就完事了</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MainActivity</span> <span style=color:#66d9ef>extends</span> AppCompatActivity <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>static</span> String KEY <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;XXXXXXXXXX&#34;</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>static</span> String URL <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;https://free-api.heweather.net/s6/weather/&#34;</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> TextView textView<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> Handler handler<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>onCreate</span><span style=color:#f92672>(</span>Bundle savedInstanceState<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>super</span><span style=color:#f92672>.</span><span style=color:#a6e22e>onCreate</span><span style=color:#f92672>(</span>savedInstanceState<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        setContentView<span style=color:#f92672>(</span>R<span style=color:#f92672>.</span><span style=color:#a6e22e>layout</span><span style=color:#f92672>.</span><span style=color:#a6e22e>activity_main</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        textView <span style=color:#f92672>=</span> findViewById<span style=color:#f92672>(</span>R<span style=color:#f92672>.</span><span style=color:#a6e22e>id</span><span style=color:#f92672>.</span><span style=color:#a6e22e>textView</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 使用自定义的静态内部类
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        handler <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> MyHandler<span style=color:#f92672>(</span><span style=color:#66d9ef>this</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 子线程请求没有变化
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>new</span> Thread<span style=color:#f92672>(</span><span style=color:#66d9ef>new</span> Runnable<span style=color:#f92672>()</span> <span style=color:#f92672>{</span> 
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>run</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                Retrofit retrofit <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Retrofit<span style=color:#f92672>.</span><span style=color:#a6e22e>Builder</span><span style=color:#f92672>()</span>
</span></span><span style=display:flex><span>                        <span style=color:#f92672>.</span><span style=color:#a6e22e>baseUrl</span><span style=color:#f92672>(</span>URL<span style=color:#f92672>)</span> <span style=color:#75715e>// 设置网络请求的公共Url地址
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                        <span style=color:#f92672>.</span><span style=color:#a6e22e>addConverterFactory</span><span style=color:#f92672>(</span>GsonConverterFactory<span style=color:#f92672>.</span><span style=color:#a6e22e>create</span><span style=color:#f92672>())</span> <span style=color:#75715e>// 设置数据解析器
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                        <span style=color:#f92672>.</span><span style=color:#a6e22e>build</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                Api api <span style=color:#f92672>=</span> retrofit<span style=color:#f92672>.</span><span style=color:#a6e22e>create</span><span style=color:#f92672>(</span>Api<span style=color:#f92672>.</span><span style=color:#a6e22e>class</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>                Call<span style=color:#f92672>&lt;</span>WeatherEntity<span style=color:#f92672>&gt;</span> call <span style=color:#f92672>=</span> api<span style=color:#f92672>.</span><span style=color:#a6e22e>getNowWeather</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;beijing&#34;</span><span style=color:#f92672>,</span> KEY<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>try</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                    WeatherEntity result <span style=color:#f92672>=</span> call<span style=color:#f92672>.</span><span style=color:#a6e22e>execute</span><span style=color:#f92672>().</span><span style=color:#a6e22e>body</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>                    Message message <span style=color:#f92672>=</span> Message<span style=color:#f92672>.</span><span style=color:#a6e22e>obtain</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>                    message<span style=color:#f92672>.</span><span style=color:#a6e22e>obj</span> <span style=color:#f92672>=</span> result<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>                    handler<span style=color:#f92672>.</span><span style=color:#a6e22e>sendMessage</span><span style=color:#f92672>(</span>message<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>                <span style=color:#f92672>}</span> <span style=color:#66d9ef>catch</span> <span style=color:#f92672>(</span>IOException e<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                    e<span style=color:#f92672>.</span><span style=color:#a6e22e>printStackTrace</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>                <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}).</span><span style=color:#a6e22e>start</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>onDestroy</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        handler<span style=color:#f92672>.</span><span style=color:#a6e22e>removeCallbacksAndMessages</span><span style=color:#f92672>(</span><span style=color:#66d9ef>null</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>super</span><span style=color:#f92672>.</span><span style=color:#a6e22e>onDestroy</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>handleMessage</span><span style=color:#f92672>(</span>Message msg<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        textView<span style=color:#f92672>.</span><span style=color:#a6e22e>setText</span><span style=color:#f92672>(</span>msg<span style=color:#f92672>.</span><span style=color:#a6e22e>obj</span><span style=color:#f92672>.</span><span style=color:#a6e22e>toString</span><span style=color:#f92672>());</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 自定义静态内部类，与onDestroy中removeCallbacksAndMessages一起使用
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyHandler</span> <span style=color:#66d9ef>extends</span> Handler <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> WeakReference<span style=color:#f92672>&lt;</span>MainActivity<span style=color:#f92672>&gt;</span> reference<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>MyHandler</span><span style=color:#f92672>(</span>MainActivity mainActivity<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 同时需要持有对MainActivity的弱引用
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>reference</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> WeakReference<span style=color:#f92672>&lt;&gt;(</span>mainActivity<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>handleMessage</span><span style=color:#f92672>(</span>Message msg<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>super</span><span style=color:#f92672>.</span><span style=color:#a6e22e>handleMessage</span><span style=color:#f92672>(</span>msg<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>            MainActivity mainActivity <span style=color:#f92672>=</span> reference<span style=color:#f92672>.</span><span style=color:#a6e22e>get</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>mainActivity <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 将msg传给MainActivity处理
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                mainActivity<span style=color:#f92672>.</span><span style=color:#a6e22e>handleMessage</span><span style=color:#f92672>(</span>msg<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><h3 id=12-handler线程间通信>1.2 Handler线程间通信<a hidden class=anchor aria-hidden=true href=#12-handler线程间通信>#</a></h3><p>上面的例子仅演示了从子线程传数据给主线程，那么如果同时需要从主线程传数据给子线程，怎么办</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// 首先需要自定义MyThread，完成Looper的初始化，否则子线程不会自动初始化Looper
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyThread</span> <span style=color:#66d9ef>extends</span> Thread <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> Looper looper<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>run</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>super</span><span style=color:#f92672>.</span><span style=color:#a6e22e>run</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>            Looper<span style=color:#f92672>.</span><span style=color:#a6e22e>prepare</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>            looper <span style=color:#f92672>=</span> Looper<span style=color:#f92672>.</span><span style=color:#a6e22e>myLooper</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>            Looper<span style=color:#f92672>.</span><span style=color:#a6e22e>loop</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 然后在onCreate方法中
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    Log<span style=color:#f92672>.</span><span style=color:#a6e22e>i</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;aaaa&#34;</span><span style=color:#f92672>,</span> String<span style=color:#f92672>.</span><span style=color:#a6e22e>valueOf</span><span style=color:#f92672>(</span>Thread<span style=color:#f92672>.</span><span style=color:#a6e22e>currentThread</span><span style=color:#f92672>()));</span>
</span></span><span style=display:flex><span>    MyThread thread <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> MyThread<span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>    thread<span style=color:#f92672>.</span><span style=color:#a6e22e>start</span><span style=color:#f92672>();</span> <span style=color:#75715e>// 必须先启动子线程
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>while</span> <span style=color:#f92672>(</span><span style=color:#66d9ef>true</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 确保子线程中的Looper初始化完成
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>thread<span style=color:#f92672>.</span><span style=color:#a6e22e>looper</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 此时handler的handleMessage方法是在子线程MyThread中执行的
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// 两处log中线程的值是不一样的，通过Handler的构造方法实现子线程的调用
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            handler <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Handler<span style=color:#f92672>(</span>thread<span style=color:#f92672>.</span><span style=color:#a6e22e>looper</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>handleMessage</span><span style=color:#f92672>(</span>Message msg<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                    Log<span style=color:#f92672>.</span><span style=color:#a6e22e>i</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;aaaa&#34;</span><span style=color:#f92672>,</span> String<span style=color:#f92672>.</span><span style=color:#a6e22e>valueOf</span><span style=color:#f92672>(</span>msg<span style=color:#f92672>.</span><span style=color:#a6e22e>what</span><span style=color:#f92672>)</span> <span style=color:#f92672>+</span> Thread<span style=color:#f92672>.</span><span style=color:#a6e22e>currentThread</span><span style=color:#f92672>());</span>
</span></span><span style=display:flex><span>                <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>};</span>
</span></span><span style=display:flex><span>            handler<span style=color:#f92672>.</span><span style=color:#a6e22e>sendEmptyMessage</span><span style=color:#f92672>(</span>12321<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>break</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 如果使用定义好的HandlerThread，则不需要继承Thread，直接使用，
</span></span></span><span style=display:flex><span><span style=color:#75715e>// HandlerThread默认帮我们完成了Looper的初始化
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    Log<span style=color:#f92672>.</span><span style=color:#a6e22e>i</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;aaaa&#34;</span><span style=color:#f92672>,</span> String<span style=color:#f92672>.</span><span style=color:#a6e22e>valueOf</span><span style=color:#f92672>(</span>Thread<span style=color:#f92672>.</span><span style=color:#a6e22e>currentThread</span><span style=color:#f92672>()));</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// HandlerThread需要用String的构造方法，我们在log中也可以看到
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    HandlerThread thread <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> HandlerThread<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;new thread&#34;</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    thread<span style=color:#f92672>.</span><span style=color:#a6e22e>start</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> <span style=color:#f92672>(</span><span style=color:#66d9ef>true</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>thread<span style=color:#f92672>.</span><span style=color:#a6e22e>getLooper</span><span style=color:#f92672>()</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            handler <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Handler<span style=color:#f92672>(</span>thread<span style=color:#f92672>.</span><span style=color:#a6e22e>getLooper</span><span style=color:#f92672>())</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>handleMessage</span><span style=color:#f92672>(</span>Message msg<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                    Log<span style=color:#f92672>.</span><span style=color:#a6e22e>i</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;aaaa&#34;</span><span style=color:#f92672>,</span> String<span style=color:#f92672>.</span><span style=color:#a6e22e>valueOf</span><span style=color:#f92672>(</span>msg<span style=color:#f92672>.</span><span style=color:#a6e22e>what</span><span style=color:#f92672>)</span> <span style=color:#f92672>+</span> Thread<span style=color:#f92672>.</span><span style=color:#a6e22e>currentThread</span><span style=color:#f92672>());</span>
</span></span><span style=display:flex><span>                <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>};</span>
</span></span><span style=display:flex><span>            handler<span style=color:#f92672>.</span><span style=color:#a6e22e>sendEmptyMessage</span><span style=color:#f92672>(</span>12321<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>break</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span></code></pre></div><blockquote><p>为什么子线程需要初始化Looper，而主线程不需要？</p></blockquote><p>首先需要明白的是，只有需要处理消息的线程才需要Looper，即哪个线程执行了handleMessage方法，则线程需要Looper，原因在源码分析中解释；主线程以及HandlerThread会自动进行Looper的初始化，而<code>new Thread()</code>不会，因此在第二个例子中，子线程需要处理消息，所以需要初始化Looper而第一个例子中主线程不需要。</p><blockquote><p>Handler的初始化，其构造方法依赖于什么，为什么第二个例子中Handler不是在主线程中初始化的吗？</p></blockquote><p>首先需要知道的是Handler是可以被跨线程调用的，而View是不可以的，举个例子，如果在第一个例子中我们在子线程中调用<code>textView.setText(result.toString());</code>，则会报错<code>CalledFromWrongThreadException: Only the original thread that created a view hierarchy can touch its views.</code>，而Handler没问题，Handler默认构造方法<code>new Handler()</code>会将当前线程的Looper保存在自己这个实例中，即将主线程中的Looper保存，而带参数的构造方法<code>new Handler(thread.looper)</code>会保存thread的looper在实例中，又因为Handler是可以跨线程调用的，所以区分Handler属于哪个线程其实是根据构造方法传入的参数决定的，至于Handler归属于不同的线程会有什么影响，在源码分析中解释。</p><h3 id=13-handler源码分析>1.3 Handler源码分析<a hidden class=anchor aria-hidden=true href=#13-handler源码分析>#</a></h3><p>以从子线程向主线程发送消息为例，首先从ActivityThread的main方法开始，前面说过主线程中的Looper是自动初始化的，其初始化的位置就在ActivityThread的main方法中</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// ActivityThread.java 核心就两个Looper.prepareMainLooper()和Looper.loop()
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span><span style=color:#f92672>(</span>String<span style=color:#f92672>[]</span> args<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>      
</span></span><span style=display:flex><span>        <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>        Looper<span style=color:#f92672>.</span><span style=color:#a6e22e>prepareMainLooper</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// 显然这里是不会执行的
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span><span style=color:#66d9ef>false</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            Looper<span style=color:#f92672>.</span><span style=color:#a6e22e>myLooper</span><span style=color:#f92672>().</span><span style=color:#a6e22e>setMessageLogging</span><span style=color:#f92672>(</span><span style=color:#66d9ef>new</span>
</span></span><span style=display:flex><span>                    LogPrinter<span style=color:#f92672>(</span>Log<span style=color:#f92672>.</span><span style=color:#a6e22e>DEBUG</span><span style=color:#f92672>,</span> <span style=color:#e6db74>&#34;ActivityThread&#34;</span><span style=color:#f92672>));</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// End of event ActivityThreadMain.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        Trace<span style=color:#f92672>.</span><span style=color:#a6e22e>traceEnd</span><span style=color:#f92672>(</span>Trace<span style=color:#f92672>.</span><span style=color:#a6e22e>TRACE_TAG_ACTIVITY_MANAGER</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        Looper<span style=color:#f92672>.</span><span style=color:#a6e22e>loop</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> RuntimeException<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;Main thread loop unexpectedly exited&#34;</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span></code></pre></div><p>再看看Looper.prepareMainLooper()的作用</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// Looper.java 看注释就知道是是为主线程初始化Looper，关键还是看prepare方法，再看myLooper
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * Initialize the current thread as a looper, marking it as an
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * application&#39;s main looper. The main looper for your application
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * is created by the Android environment, so you should never need
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * to call this function yourself.  See also: {@link #prepare()}
</span></span></span><span style=display:flex><span><span style=color:#75715e>     */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>prepareMainLooper</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        prepare<span style=color:#f92672>(</span><span style=color:#66d9ef>false</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>synchronized</span> <span style=color:#f92672>(</span>Looper<span style=color:#f92672>.</span><span style=color:#a6e22e>class</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>sMainLooper <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> IllegalStateException<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;The main Looper has already been prepared.&#34;</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>            sMainLooper <span style=color:#f92672>=</span> myLooper<span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// prepare方法通过sThreadLocal set了一个Looper实例，
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 一个Looper实例保存了MessageQueue和Thread.currentThread()
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>prepare</span><span style=color:#f92672>(</span><span style=color:#66d9ef>boolean</span> quitAllowed<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>sThreadLocal<span style=color:#f92672>.</span><span style=color:#a6e22e>get</span><span style=color:#f92672>()</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> RuntimeException<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;Only one Looper may be created per thread&#34;</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>        sThreadLocal<span style=color:#f92672>.</span><span style=color:#a6e22e>set</span><span style=color:#f92672>(</span><span style=color:#66d9ef>new</span> Looper<span style=color:#f92672>(</span>quitAllowed<span style=color:#f92672>));</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// myLooper方法从sThreadLocal get到Looper，那正好对应上面prepare set的Looper，
</span></span></span><span style=display:flex><span><span style=color:#75715e>// ThreadLocal的作用是可以保存线程内的变量，简而言之就是通过ThreadLocal的set和get方法
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 处理的变量仅属于某个线程，以Looper为例，在某个线程中有且仅有一个
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * Return the Looper object associated with the current thread.  Returns
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * null if the calling thread is not associated with a Looper.
</span></span></span><span style=display:flex><span><span style=color:#75715e>     */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#a6e22e>@Nullable</span> Looper <span style=color:#a6e22e>myLooper</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> sThreadLocal<span style=color:#f92672>.</span><span style=color:#a6e22e>get</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>   
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 最后调用了Looper.loop()
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * Run the message queue in this thread. Be sure to call
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * {@link #quit()} to end the loop.
</span></span></span><span style=display:flex><span><span style=color:#75715e>     */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>loop</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Looper.loop()会进入一个死循环，但是这个循环并不会导致卡死，
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// 涉及到Linux pipe/epoll机制，简单说就是在主线程的MessageQueue没有消息时，
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// 便阻塞在loop的queue.next()中的nativePollOnce()方法里，此时主线程会释放CPU资源进入休眠状态，
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// 直到下个消息到达或者有事务发生，通过往pipe管道写端写入数据来唤醒主线程工作。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// 这里采用的epoll机制，是一种IO多路复用机制，可以同时监控多个描述符，
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// 当某个描述符就绪(读或写就绪)，则立刻通知相应程序进行读或写操作，本质同步I/O，即读写是阻塞的。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>//  所以说，主线程大多数时候都是处于休眠状态，并不会消耗大量CPU资源。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// 先拿到当前线程的Looper，然后拿到Looper中的MessageQueue
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>final</span> Looper me <span style=color:#f92672>=</span> myLooper<span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>me <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> RuntimeException<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;No Looper; Looper.prepare() wasn&#39;t called on this thread.&#34;</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>final</span> MessageQueue queue <span style=color:#f92672>=</span> me<span style=color:#f92672>.</span><span style=color:#a6e22e>mQueue</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// 开启循环，Android中主线程上所有的点击事件、UI绘制都是通过Message发送到MessageQueue中等待执行
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// 所以这里必须是死循环，因为如果跳出了这个循环说明已经无法再继续处理任何Message，那么随之而来的肯定就是
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// 应用崩溃或者重启Looper，但是这里的循环并不会导致卡死，理由在上面已经简要说明了
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>for</span> <span style=color:#f92672>(;;)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 循环的作用就是通过queue.next()不断地从MessageQueue取出Message，next方法中也是一个死循环，
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// 正常情况下queue.next()应该返回一个有效的Message，或者休眠不返回任何值，如果返回null，
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// 说明出了问题
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            Message msg <span style=color:#f92672>=</span> queue<span style=color:#f92672>.</span><span style=color:#a6e22e>next</span><span style=color:#f92672>();</span> <span style=color:#75715e>// might block
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>msg <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 当取出的message为空时说明MessageQueue被终止了，因此跳出循环，执行其他操作，比如重启Looper或者崩溃？
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#75715e>// No message indicates that the message queue is quitting.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>return</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// 当我们取到有效的Message后，就需要知道这个Message应该由谁来处理，即Target，从Message源码中可知，
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// 这个Target实际上就是Handler，最终调用的就是Handler的dispatchMessage方法，从这里我们就知道了
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// 只要其他线程能够将Message发送到主线程的MessageQueue中，那么这个Message就可以被主线程的Handler处理
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>try</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                msg<span style=color:#f92672>.</span><span style=color:#a6e22e>target</span><span style=color:#f92672>.</span><span style=color:#a6e22e>dispatchMessage</span><span style=color:#f92672>(</span>msg<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>                dispatchEnd <span style=color:#f92672>=</span> needEndTime <span style=color:#f92672>?</span> SystemClock<span style=color:#f92672>.</span><span style=color:#a6e22e>uptimeMillis</span><span style=color:#f92672>()</span> <span style=color:#f92672>:</span> 0<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>}</span> <span style=color:#66d9ef>finally</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>traceTag <span style=color:#f92672>!=</span> 0<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                    Trace<span style=color:#f92672>.</span><span style=color:#a6e22e>traceEnd</span><span style=color:#f92672>(</span>traceTag<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>                <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// 最后需要对Message对象进行回收
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            msg<span style=color:#f92672>.</span><span style=color:#a6e22e>recycleUnchecked</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span></code></pre></div><p>ActivityThread的main方法中对主线程的Looper进行初始化，同样的主线程的MessageQueue也准备好对其中的Message进行分发，这都是通过死循环实现的，相当于MessageQueue是一个等待队列，有消息来了，他就取消息并调用Message对应的Handler的dispatchMessage方法，如果没有就休眠，然后我们看看Handler的初始化以及Message的发送是如何实现的</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// Handler.java Handler的构造方法分为两类，一类是参数带Looper的，另一类是不带Looper
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 不带Looper的构造函数最终会调用到最后一个构造函数，并进行Looper的初始化；
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 带Looper的构造函数会直接保存参数中的Looper实例
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>Handler</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span><span style=color:#f92672>(</span><span style=color:#66d9ef>null</span><span style=color:#f92672>,</span> <span style=color:#66d9ef>false</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>Handler</span><span style=color:#f92672>(</span>Callback callback<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span><span style=color:#f92672>(</span>callback<span style=color:#f92672>,</span> <span style=color:#66d9ef>false</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>Handler</span><span style=color:#f92672>(</span>Looper looper<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span><span style=color:#f92672>(</span>looper<span style=color:#f92672>,</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>,</span> <span style=color:#66d9ef>false</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>Handler</span><span style=color:#f92672>(</span>Looper looper<span style=color:#f92672>,</span> Callback callback<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span><span style=color:#f92672>(</span>looper<span style=color:#f92672>,</span> callback<span style=color:#f92672>,</span> <span style=color:#66d9ef>false</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>Handler</span><span style=color:#f92672>(</span><span style=color:#66d9ef>boolean</span> async<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span><span style=color:#f92672>(</span><span style=color:#66d9ef>null</span><span style=color:#f92672>,</span> async<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>Handler</span><span style=color:#f92672>(</span>Looper looper<span style=color:#f92672>,</span> Callback callback<span style=color:#f92672>,</span> <span style=color:#66d9ef>boolean</span> async<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        mLooper <span style=color:#f92672>=</span> looper<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>        mQueue <span style=color:#f92672>=</span> looper<span style=color:#f92672>.</span><span style=color:#a6e22e>mQueue</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>        mCallback <span style=color:#f92672>=</span> callback<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>        mAsynchronous <span style=color:#f92672>=</span> async<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>Handler</span><span style=color:#f92672>(</span>Callback callback<span style=color:#f92672>,</span> <span style=color:#66d9ef>boolean</span> async<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>FIND_POTENTIAL_LEAKS<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>final</span> Class<span style=color:#f92672>&lt;?</span> <span style=color:#66d9ef>extends</span> Handler<span style=color:#f92672>&gt;</span> klass <span style=color:#f92672>=</span> getClass<span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#f92672>((</span>klass<span style=color:#f92672>.</span><span style=color:#a6e22e>isAnonymousClass</span><span style=color:#f92672>()</span> <span style=color:#f92672>||</span> klass<span style=color:#f92672>.</span><span style=color:#a6e22e>isMemberClass</span><span style=color:#f92672>()</span> <span style=color:#f92672>||</span> klass<span style=color:#f92672>.</span><span style=color:#a6e22e>isLocalClass</span><span style=color:#f92672>())</span> <span style=color:#f92672>&amp;&amp;</span>
</span></span><span style=display:flex><span>                    <span style=color:#f92672>(</span>klass<span style=color:#f92672>.</span><span style=color:#a6e22e>getModifiers</span><span style=color:#f92672>()</span> <span style=color:#f92672>&amp;</span> Modifier<span style=color:#f92672>.</span><span style=color:#a6e22e>STATIC</span><span style=color:#f92672>)</span> <span style=color:#f92672>==</span> 0<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                Log<span style=color:#f92672>.</span><span style=color:#a6e22e>w</span><span style=color:#f92672>(</span>TAG<span style=color:#f92672>,</span> <span style=color:#e6db74>&#34;The following Handler class should be static or leaks might occur: &#34;</span> <span style=color:#f92672>+</span>
</span></span><span style=display:flex><span>                    klass<span style=color:#f92672>.</span><span style=color:#a6e22e>getCanonicalName</span><span style=color:#f92672>());</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Looper的myLooper方法会初始化当前线程的Looper
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        mLooper <span style=color:#f92672>=</span> Looper<span style=color:#f92672>.</span><span style=color:#a6e22e>myLooper</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>mLooper <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> RuntimeException<span style=color:#f92672>(</span>
</span></span><span style=display:flex><span>                <span style=color:#e6db74>&#34;Can&#39;t create handler inside thread &#34;</span> <span style=color:#f92672>+</span> Thread<span style=color:#f92672>.</span><span style=color:#a6e22e>currentThread</span><span style=color:#f92672>()</span>
</span></span><span style=display:flex><span>                        <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34; that has not called Looper.prepare()&#34;</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>        mQueue <span style=color:#f92672>=</span> mLooper<span style=color:#f92672>.</span><span style=color:#a6e22e>mQueue</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>        mCallback <span style=color:#f92672>=</span> callback<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>        mAsynchronous <span style=color:#f92672>=</span> async<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span></code></pre></div><p>然后调用<code>handler.sendMessage(message);</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// Handler.java sendMessage方法会直接调用sendMessageDelayed
</span></span></span><span style=display:flex><span><span style=color:#75715e>// sendMessageDelayed就是多个延时的效果
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>sendMessage</span><span style=color:#f92672>(</span>Message msg<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> sendMessageDelayed<span style=color:#f92672>(</span>msg<span style=color:#f92672>,</span> 0<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>sendMessageDelayed</span><span style=color:#f92672>(</span>Message msg<span style=color:#f92672>,</span> <span style=color:#66d9ef>long</span> delayMillis<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>delayMillis <span style=color:#f92672>&lt;</span> 0<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            delayMillis <span style=color:#f92672>=</span> 0<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 通过加上SystemClock.uptimeMillis()可以直接得到执行的具体时间
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>return</span> sendMessageAtTime<span style=color:#f92672>(</span>msg<span style=color:#f92672>,</span> SystemClock<span style=color:#f92672>.</span><span style=color:#a6e22e>uptimeMillis</span><span style=color:#f92672>()</span> <span style=color:#f92672>+</span> delayMillis<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>sendMessageAtTime</span><span style=color:#f92672>(</span>Message msg<span style=color:#f92672>,</span> <span style=color:#66d9ef>long</span> uptimeMillis<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        MessageQueue queue <span style=color:#f92672>=</span> mQueue<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>queue <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            RuntimeException e <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> RuntimeException<span style=color:#f92672>(</span>
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>this</span> <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34; sendMessageAtTime() called with no mQueue&#34;</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>            Log<span style=color:#f92672>.</span><span style=color:#a6e22e>w</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;Looper&#34;</span><span style=color:#f92672>,</span> e<span style=color:#f92672>.</span><span style=color:#a6e22e>getMessage</span><span style=color:#f92672>(),</span> e<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 最终还是使用Handler的MessageQueue
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>return</span> enqueueMessage<span style=color:#f92672>(</span>queue<span style=color:#f92672>,</span> msg<span style=color:#f92672>,</span> uptimeMillis<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>enqueueMessage</span><span style=color:#f92672>(</span>MessageQueue queue<span style=color:#f92672>,</span> Message msg<span style=color:#f92672>,</span> <span style=color:#66d9ef>long</span> uptimeMillis<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 注意这里将Message的target设置为当前handler
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        msg<span style=color:#f92672>.</span><span style=color:#a6e22e>target</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>mAsynchronous<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            msg<span style=color:#f92672>.</span><span style=color:#a6e22e>setAsynchronous</span><span style=color:#f92672>(</span><span style=color:#66d9ef>true</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 然后调用MessageQueue的enqueueMessage方法
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>return</span> queue<span style=color:#f92672>.</span><span style=color:#a6e22e>enqueueMessage</span><span style=color:#f92672>(</span>msg<span style=color:#f92672>,</span> uptimeMillis<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// MessageQueue.java enqueueMessage将Message加入链表中
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>enqueueMessage</span><span style=color:#f92672>(</span>Message msg<span style=color:#f92672>,</span> <span style=color:#66d9ef>long</span> when<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>msg<span style=color:#f92672>.</span><span style=color:#a6e22e>target</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> IllegalArgumentException<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;Message must have a target.&#34;</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>msg<span style=color:#f92672>.</span><span style=color:#a6e22e>isInUse</span><span style=color:#f92672>())</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> IllegalStateException<span style=color:#f92672>(</span>msg <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34; This message is already in use.&#34;</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>synchronized</span> <span style=color:#f92672>(</span><span style=color:#66d9ef>this</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 如果MessageQueue被终止了，那么Message还需要回收
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>mQuitting<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                IllegalStateException e <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> IllegalStateException<span style=color:#f92672>(</span>
</span></span><span style=display:flex><span>                        msg<span style=color:#f92672>.</span><span style=color:#a6e22e>target</span> <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34; sending message to a Handler on a dead thread&#34;</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>                Log<span style=color:#f92672>.</span><span style=color:#a6e22e>w</span><span style=color:#f92672>(</span>TAG<span style=color:#f92672>,</span> e<span style=color:#f92672>.</span><span style=color:#a6e22e>getMessage</span><span style=color:#f92672>(),</span> e<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>                msg<span style=color:#f92672>.</span><span style=color:#a6e22e>recycle</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            msg<span style=color:#f92672>.</span><span style=color:#a6e22e>markInUse</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>            msg<span style=color:#f92672>.</span><span style=color:#a6e22e>when</span> <span style=color:#f92672>=</span> when<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>            Message p <span style=color:#f92672>=</span> mMessages<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>boolean</span> needWake<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 根据msg.next基本可以发现Message是一个链表中的节点，也就是说MessageQueue中的mMessages
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// 是一种链表形式的结构，其中mMessages是表头，当执行next方法时就会将表头也就是mMessages表示的
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// Message返回，当我们传入的Message满足以下任意条件时，可以将此Message作为表头：
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// 1. 表头本身为空，很明显当没有任何Message传入的时候；
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// 2. 当我们传入的Message没有任何延迟，这也很显然，立即执行的Message当然要放第一个；
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// 3. 当我们传入的Message的执行时间在表头的执行时间之前，这也很显然，按照时间排序。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>p <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>||</span> when <span style=color:#f92672>==</span> 0 <span style=color:#f92672>||</span> when <span style=color:#f92672>&lt;</span> p<span style=color:#f92672>.</span><span style=color:#a6e22e>when</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// New head, wake up the event queue if blocked.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                msg<span style=color:#f92672>.</span><span style=color:#a6e22e>next</span> <span style=color:#f92672>=</span> p<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>                mMessages <span style=color:#f92672>=</span> msg<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>                needWake <span style=color:#f92672>=</span> mBlocked<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>}</span> <span style=color:#66d9ef>else</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 如果Message不是表头位置，那么肯定就是链表中的某个位置
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#75715e>// Inserted within the middle of the queue.  Usually we don&#39;t have to wake
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#75715e>// up the event queue unless there is a barrier at the head of the queue
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#75715e>// and the message is the earliest asynchronous message in the queue.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                needWake <span style=color:#f92672>=</span> mBlocked <span style=color:#f92672>&amp;&amp;</span> p<span style=color:#f92672>.</span><span style=color:#a6e22e>target</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>&amp;&amp;</span> msg<span style=color:#f92672>.</span><span style=color:#a6e22e>isAsynchronous</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>                Message prev<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>for</span> <span style=color:#f92672>(;;)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// 链表的遍历，还要判断时间when
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    prev <span style=color:#f92672>=</span> p<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>                    p <span style=color:#f92672>=</span> p<span style=color:#f92672>.</span><span style=color:#a6e22e>next</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>p <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>||</span> when <span style=color:#f92672>&lt;</span> p<span style=color:#f92672>.</span><span style=color:#a6e22e>when</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>break</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>                    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>needWake <span style=color:#f92672>&amp;&amp;</span> p<span style=color:#f92672>.</span><span style=color:#a6e22e>isAsynchronous</span><span style=color:#f92672>())</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                        needWake <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>                    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>                <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 这就很简单了，有序链表中加入某个节点，排序方式为when的值
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                msg<span style=color:#f92672>.</span><span style=color:#a6e22e>next</span> <span style=color:#f92672>=</span> p<span style=color:#f92672>;</span> <span style=color:#75715e>// invariant: p == prev.next
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                prev<span style=color:#f92672>.</span><span style=color:#a6e22e>next</span> <span style=color:#f92672>=</span> msg<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// We can assume mPtr != 0 because mQuitting is false.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>needWake<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                nativeWake<span style=color:#f92672>(</span>mPtr<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span></code></pre></div><p>到这里我们就知道了Message被Handler加到了Handler线程的MessageQueue中，而Handler线程中的Looper一直在等待Message进入MessageQueue，通过queue.next()取出Message，然后调用Handler的dispatchMessage方法</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>    <span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * Handle system messages here.
</span></span></span><span style=display:flex><span><span style=color:#75715e>     */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>dispatchMessage</span><span style=color:#f92672>(</span>Message msg<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// dispatchMessage处理Message的方式也很简单
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// 首先判断Message是否设置了Callback，如果有
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// 则执行message.callback.run()
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>msg<span style=color:#f92672>.</span><span style=color:#a6e22e>callback</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            handleCallback<span style=color:#f92672>(</span>msg<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span> <span style=color:#66d9ef>else</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 如果没有，则判断Handler是否初始化设置了Callback，
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// 这个和Handler的构造函数相关
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>mCallback <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>mCallback<span style=color:#f92672>.</span><span style=color:#a6e22e>handleMessage</span><span style=color:#f92672>(</span>msg<span style=color:#f92672>))</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>return</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>                <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 否则就执行handler重写的handleMessage方法，
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// 这个方法是在我们继承Handler时重写的，或者
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// 在使用Handler匿名内部类时重写的
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            handleMessage<span style=color:#f92672>(</span>msg<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span></code></pre></div><p>以上就是完整的通过Handler从子线程发送消息到主线程并执行的过程，也解决了我的一些问题：</p><blockquote><p>1.为什么要设计Handler来传输消息？</p></blockquote><p>因为多线程的情况下并不确定子线程何时能够执行完毕获取数据，所以需要设计Handler实现一种回调机制，即当子线程数据获取完成后将数据传到主线程中，通过主线程中的回调决定如何处理传来的数据。</p><blockquote><p>2.为什么要用MessageQueue和Looper这种工具？</p></blockquote><p>我想是因为既然子线程并不确定何时结束，其次如果存在多个子线程向主线程传递消息，那干脆将这些消息都放在一个队列MessageQueue中，因为多个子线程之间的执行顺序我们也无法确定，如果放在队列中，那么根据消息附加的时间来进行排序我们就可以按照顺序读取从各个子线程发送过来的消息了，与此同时，需要一个能够不停地读取队列中消息的工具Looper，Looper可以循环取数据但是不会阻塞卡死。</p><h3 id=14-handler进阶>1.4 Handler进阶<a hidden class=anchor aria-hidden=true href=#14-handler进阶>#</a></h3><p>Handler除了可以发送Message外，还可以post Runnable，Runnable是接口，提供run方法，Thread类实现了Runnable接口，所以Thread需要实现run方法，run方法中的内容就是执行在Thread线程中，如果Runnable是通过Handler post，那么根据Message的原理，应该明白此Runnable就是运行在Handler归属的线程中</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>onCreate</span><span style=color:#f92672>(</span>Bundle savedInstanceState<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>super</span><span style=color:#f92672>.</span><span style=color:#a6e22e>onCreate</span><span style=color:#f92672>(</span>savedInstanceState<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    setContentView<span style=color:#f92672>(</span>R<span style=color:#f92672>.</span><span style=color:#a6e22e>layout</span><span style=color:#f92672>.</span><span style=color:#a6e22e>activity_main</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    textView <span style=color:#f92672>=</span> findViewById<span style=color:#f92672>(</span>R<span style=color:#f92672>.</span><span style=color:#a6e22e>id</span><span style=color:#f92672>.</span><span style=color:#a6e22e>textView</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// handler不重写handleMessage方法
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    handler <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Handler<span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>new</span> Thread<span style=color:#f92672>(</span><span style=color:#66d9ef>new</span> Runnable<span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>run</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Retrofit通用代码
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            Retrofit retrofit <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Retrofit<span style=color:#f92672>.</span><span style=color:#a6e22e>Builder</span><span style=color:#f92672>()</span>
</span></span><span style=display:flex><span>                    <span style=color:#f92672>.</span><span style=color:#a6e22e>baseUrl</span><span style=color:#f92672>(</span>URL<span style=color:#f92672>)</span> <span style=color:#75715e>// 设置网络请求的公共Url地址
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#f92672>.</span><span style=color:#a6e22e>addConverterFactory</span><span style=color:#f92672>(</span>GsonConverterFactory<span style=color:#f92672>.</span><span style=color:#a6e22e>create</span><span style=color:#f92672>())</span> <span style=color:#75715e>// 设置数据解析器
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#f92672>.</span><span style=color:#a6e22e>build</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            Api api <span style=color:#f92672>=</span> retrofit<span style=color:#f92672>.</span><span style=color:#a6e22e>create</span><span style=color:#f92672>(</span>Api<span style=color:#f92672>.</span><span style=color:#a6e22e>class</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>            Call<span style=color:#f92672>&lt;</span>WeatherEntity<span style=color:#f92672>&gt;</span> call <span style=color:#f92672>=</span> api<span style=color:#f92672>.</span><span style=color:#a6e22e>getNowWeather</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;beijing&#34;</span><span style=color:#f92672>,</span> KEY<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>try</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 为了在当前子线程获取数据，这里直接使用execute
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>final</span> WeatherEntity result <span style=color:#f92672>=</span> call<span style=color:#f92672>.</span><span style=color:#a6e22e>execute</span><span style=color:#f92672>().</span><span style=color:#a6e22e>body</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 通过post直接修改textView的text
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                handler<span style=color:#f92672>.</span><span style=color:#a6e22e>post</span><span style=color:#f92672>(</span><span style=color:#66d9ef>new</span> Runnable<span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>run</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                        textView<span style=color:#f92672>.</span><span style=color:#a6e22e>setText</span><span style=color:#f92672>(</span>result<span style=color:#f92672>.</span><span style=color:#a6e22e>toString</span><span style=color:#f92672>());</span>
</span></span><span style=display:flex><span>                    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>                <span style=color:#f92672>});</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>}</span> <span style=color:#66d9ef>catch</span> <span style=color:#f92672>(</span>IOException e<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                e<span style=color:#f92672>.</span><span style=color:#a6e22e>printStackTrace</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}).</span><span style=color:#a6e22e>start</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p>因为textView只能在主线程进行设置，所以很显然handler post的Runnable是在主线程运行的，这样就不需要传递数据，而是直接处理数据了，下面看看Runnable是如何被处理的</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// Handler.java
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>post</span><span style=color:#f92672>(</span>Runnable r<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// sendMessageDelayed之前分析过，这里是将Runnable放入Message中了
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>       <span style=color:#66d9ef>return</span>  sendMessageDelayed<span style=color:#f92672>(</span>getPostMessage<span style=color:#f92672>(</span>r<span style=color:#f92672>),</span> 0<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 通过Message保存了这个Runnable，保存在callback，这个之前在dispatchMessage中见过
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> Message <span style=color:#a6e22e>getPostMessage</span><span style=color:#f92672>(</span>Runnable r<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        Message m <span style=color:#f92672>=</span> Message<span style=color:#f92672>.</span><span style=color:#a6e22e>obtain</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>        m<span style=color:#f92672>.</span><span style=color:#a6e22e>callback</span> <span style=color:#f92672>=</span> r<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> m<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>   
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>dispatchMessage</span><span style=color:#f92672>(</span>Message msg<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 之前sendMessage都是走的第二个判断，post走的就是第一个判断，
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// 我们的Runnable现在不为空
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>msg<span style=color:#f92672>.</span><span style=color:#a6e22e>callback</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            handleCallback<span style=color:#f92672>(</span>msg<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span> <span style=color:#66d9ef>else</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>mCallback <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>mCallback<span style=color:#f92672>.</span><span style=color:#a6e22e>handleMessage</span><span style=color:#f92672>(</span>msg<span style=color:#f92672>))</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>return</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>                <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>            handleMessage<span style=color:#f92672>(</span>msg<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 结果很明显了，就是执行了Runnable的run方法
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>handleCallback</span><span style=color:#f92672>(</span>Message message<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        message<span style=color:#f92672>.</span><span style=color:#a6e22e>callback</span><span style=color:#f92672>.</span><span style=color:#a6e22e>run</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span></code></pre></div><p>下面演示一下多个线程向主线程发送消息会产生怎样的结果，自定义线程MessageThread用于发送Message，普通的Thread用于post Runnable</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>onCreate</span><span style=color:#f92672>(</span>Bundle savedInstanceState<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>super</span><span style=color:#f92672>.</span><span style=color:#a6e22e>onCreate</span><span style=color:#f92672>(</span>savedInstanceState<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        setContentView<span style=color:#f92672>(</span>R<span style=color:#f92672>.</span><span style=color:#a6e22e>layout</span><span style=color:#f92672>.</span><span style=color:#a6e22e>activity_main</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        textView <span style=color:#f92672>=</span> findViewById<span style=color:#f92672>(</span>R<span style=color:#f92672>.</span><span style=color:#a6e22e>id</span><span style=color:#f92672>.</span><span style=color:#a6e22e>textView</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// handler根据传过来的Message的what值进行不同的操作
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        handler <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Handler<span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>handleMessage</span><span style=color:#f92672>(</span>Message msg<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>switch</span> <span style=color:#f92672>(</span>msg<span style=color:#f92672>.</span><span style=color:#a6e22e>what</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>case</span> 0<span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>                        Log<span style=color:#f92672>.</span><span style=color:#a6e22e>i</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;aaaa&#34;</span><span style=color:#f92672>,</span> <span style=color:#e6db74>&#34;Thread 0: &#34;</span> <span style=color:#f92672>+</span> msg<span style=color:#f92672>.</span><span style=color:#a6e22e>obj</span><span style=color:#f92672>.</span><span style=color:#a6e22e>toString</span><span style=color:#f92672>());</span>
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>break</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>case</span> 1<span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>                        Log<span style=color:#f92672>.</span><span style=color:#a6e22e>i</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;aaaa&#34;</span><span style=color:#f92672>,</span> <span style=color:#e6db74>&#34;Thread 1: &#34;</span> <span style=color:#f92672>+</span> msg<span style=color:#f92672>.</span><span style=color:#a6e22e>obj</span><span style=color:#f92672>.</span><span style=color:#a6e22e>toString</span><span style=color:#f92672>());</span>
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>break</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>case</span> 2<span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>                        Log<span style=color:#f92672>.</span><span style=color:#a6e22e>i</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;aaaa&#34;</span><span style=color:#f92672>,</span> <span style=color:#e6db74>&#34;Thread 2: &#34;</span> <span style=color:#f92672>+</span> msg<span style=color:#f92672>.</span><span style=color:#a6e22e>obj</span><span style=color:#f92672>.</span><span style=color:#a6e22e>toString</span><span style=color:#f92672>());</span>
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>break</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>                <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>};</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 开启三个线程发送Message，加上延时
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>new</span> MessageThread<span style=color:#f92672>(</span>0<span style=color:#f92672>,</span> <span style=color:#e6db74>&#34;thread 0 hahaha&#34;</span><span style=color:#f92672>,</span> 3000<span style=color:#f92672>).</span><span style=color:#a6e22e>start</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>new</span> MessageThread<span style=color:#f92672>(</span>1<span style=color:#f92672>,</span> <span style=color:#e6db74>&#34;thread 1 oooooo&#34;</span><span style=color:#f92672>,</span> 1000<span style=color:#f92672>).</span><span style=color:#a6e22e>start</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>new</span> MessageThread<span style=color:#f92672>(</span>2<span style=color:#f92672>,</span> <span style=color:#e6db74>&#34;thread 2 yyyyyy&#34;</span><span style=color:#f92672>,</span> 2000<span style=color:#f92672>).</span><span style=color:#a6e22e>start</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// post Runnable也加上延时，注意这里的postDelayed并不会阻塞主线程，
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// 原理同Looper.loop()，所以不会引起ANR，这个延时只会影响此Message在MessageQueue
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// 中的位置
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>new</span> Thread<span style=color:#f92672>(</span><span style=color:#66d9ef>new</span> Runnable<span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>run</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                handler<span style=color:#f92672>.</span><span style=color:#a6e22e>postDelayed</span><span style=color:#f92672>(</span><span style=color:#66d9ef>new</span> Runnable<span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>run</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                        Log<span style=color:#f92672>.</span><span style=color:#a6e22e>i</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;aaaa&#34;</span><span style=color:#f92672>,</span> <span style=color:#e6db74>&#34;MainThread&#34;</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>                    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>                <span style=color:#f92672>},</span> 10000<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}).</span><span style=color:#a6e22e>start</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MessageThread</span> <span style=color:#66d9ef>extends</span> Thread <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> what<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> String text<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>long</span> delay<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>MessageThread</span><span style=color:#f92672>(</span><span style=color:#66d9ef>int</span> what<span style=color:#f92672>,</span> String text<span style=color:#f92672>,</span> <span style=color:#66d9ef>long</span> delay<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>what</span> <span style=color:#f92672>=</span> what<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>text</span> <span style=color:#f92672>=</span> text<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>delay</span> <span style=color:#f92672>=</span> delay<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>run</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            Message message <span style=color:#f92672>=</span> Message<span style=color:#f92672>.</span><span style=color:#a6e22e>obtain</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>            message<span style=color:#f92672>.</span><span style=color:#a6e22e>what</span> <span style=color:#f92672>=</span> what<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>            message<span style=color:#f92672>.</span><span style=color:#a6e22e>obj</span> <span style=color:#f92672>=</span> text<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>            handler<span style=color:#f92672>.</span><span style=color:#a6e22e>sendMessageDelayed</span><span style=color:#f92672>(</span>message<span style=color:#f92672>,</span> delay<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span></code></pre></div><p>log结果为</p><pre tabindex=0><code>Thread 1: thread 1 oooooo
Thread 2: thread 2 yyyyyy
Thread 0: thread 0 hahaha
MainThread
</code></pre><h2 id=2-asynctask>2. AsyncTask<a hidden class=anchor aria-hidden=true href=#2-asynctask>#</a></h2><p>通过Handler实现的多线程通信在使用上还是有很多不方便的地方，比如需要显示的创建子线程，每次创建子线程都是对资源的消耗，当然也可以使用线程池来减少线程资源的创建与销毁，同时需要定义Handler的处理方式，对于每一个需要处理消息的线程都需要定义其Handler，这样就显得比较乱，因此可以使用AsyncTask来替代，先看一下如何使用。</p><h3 id=21-asynctask简单使用>2.1 AsyncTask简单使用<a hidden class=anchor aria-hidden=true href=#21-asynctask简单使用>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// 依然以请求和风天气数据为例，现在我们为加载数据时显示进度，为什么要显示进度呢
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 从设计理念来看，当我们给某些需要长时间等待的操作加上进度条时，用户对这个操作的
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 容忍度会增加，比如常见的进入游戏的界面，会显示进度条，这样的话就算耗时相对较长，
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 但是用户可以根据进度有一个心理预期，从而提升容忍度；如果你的耗时操作没有任何进度
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 提示，那么用户很容易觉得你的应用是不是卡死了，从而降低了体验
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MainActivity</span> <span style=color:#66d9ef>extends</span> AppCompatActivity <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> String KEY <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;XXXXXXXXXXXX&#34;</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> String URL <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;https://free-api.heweather.net/s6/weather/&#34;</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> TextView textView<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>onCreate</span><span style=color:#f92672>(</span>Bundle savedInstanceState<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>super</span><span style=color:#f92672>.</span><span style=color:#a6e22e>onCreate</span><span style=color:#f92672>(</span>savedInstanceState<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        setContentView<span style=color:#f92672>(</span>R<span style=color:#f92672>.</span><span style=color:#a6e22e>layout</span><span style=color:#f92672>.</span><span style=color:#a6e22e>activity_main</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        textView <span style=color:#f92672>=</span> findViewById<span style=color:#f92672>(</span>R<span style=color:#f92672>.</span><span style=color:#a6e22e>id</span><span style=color:#f92672>.</span><span style=color:#a6e22e>textView</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        MyTask task <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> MyTask<span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// execute的参数等价于doInBackground的参数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        task<span style=color:#f92672>.</span><span style=color:#a6e22e>execute</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;beijing&#34;</span><span style=color:#f92672>,</span> 50L<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// AsyncTask是抽象类，需要自定义Task并实现doInBackground方法，除了doInBackground之外
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 还有几个方法用于初始化、显示进度、输出结果等功能，三个参数Object, Integer, WeatherEntity为泛型参数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyTask</span> <span style=color:#66d9ef>extends</span> AsyncTask<span style=color:#f92672>&lt;</span>Object<span style=color:#f92672>,</span> Integer<span style=color:#f92672>,</span> WeatherEntity<span style=color:#f92672>&gt;</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// onPreExecute在主线程执行，用于做一些提前的初始化
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>onPreExecute</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            textView<span style=color:#f92672>.</span><span style=color:#a6e22e>setText</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;Start!!&#34;</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// doInBackground在子线程执行，不需要显示地创建Thread，这里的参数params
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// 是一个泛型参数，也就是说可以传入多个参数，相当于参数数组，参数的传入是
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// task.execute传入，返回值由AsyncTask第三个泛型参数决定，同时也是
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// onPostExecute的输入参数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>protected</span> WeatherEntity <span style=color:#a6e22e>doInBackground</span><span style=color:#f92672>(</span>Object<span style=color:#f92672>...</span> params<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 根据传入的顺序读取，location就是beijing，delay就是50L，
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// 为了模拟进度，这里传入一个延时，正式使用时需要根据数据实际传输的进度
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// 展示进度
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            String location <span style=color:#f92672>=</span> <span style=color:#f92672>(</span>String<span style=color:#f92672>)</span> params<span style=color:#f92672>[</span>0<span style=color:#f92672>];</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>long</span> delay <span style=color:#f92672>=</span> <span style=color:#f92672>(</span><span style=color:#66d9ef>long</span><span style=color:#f92672>)</span> params<span style=color:#f92672>[</span>1<span style=color:#f92672>];</span>
</span></span><span style=display:flex><span>            WeatherEntity result <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>try</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 先获取数据，我们知道这里取数据的速度其实是很快的
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                result <span style=color:#f92672>=</span> getData<span style=color:#f92672>(</span>location<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>}</span> <span style=color:#66d9ef>catch</span> <span style=color:#f92672>(</span>IOException e<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                e<span style=color:#f92672>.</span><span style=color:#a6e22e>printStackTrace</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 然后显示进度，这里仅模拟
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>try</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>int</span> count <span style=color:#f92672>=</span> 0<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>int</span> length <span style=color:#f92672>=</span> 1<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>while</span> <span style=color:#f92672>(</span>count <span style=color:#f92672>&lt;</span> 99<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    count <span style=color:#f92672>+=</span> length<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// 可调用publishProgress（）显示进度, 之后将执行onProgressUpdate（）
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    publishProgress<span style=color:#f92672>(</span>count<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// 模拟耗时任务
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    Thread<span style=color:#f92672>.</span><span style=color:#a6e22e>sleep</span><span style=color:#f92672>(</span>delay<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>                <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>}</span> <span style=color:#66d9ef>catch</span> <span style=color:#f92672>(</span>InterruptedException e<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                e<span style=color:#f92672>.</span><span style=color:#a6e22e>printStackTrace</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 最后返回取到的数据
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>return</span> result<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// onProgressUpdate在主线程执行，显示进度
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>onProgressUpdate</span><span style=color:#f92672>(</span>Integer<span style=color:#f92672>...</span> values<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            textView<span style=color:#f92672>.</span><span style=color:#a6e22e>setText</span><span style=color:#f92672>(</span>String<span style=color:#f92672>.</span><span style=color:#a6e22e>format</span><span style=color:#f92672>(</span>Locale<span style=color:#f92672>.</span><span style=color:#a6e22e>CHINA</span><span style=color:#f92672>,</span> <span style=color:#e6db74>&#34;加载进度：%d%%&#34;</span><span style=color:#f92672>,</span> values<span style=color:#f92672>[</span>0<span style=color:#f92672>]));</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// onPostExecute在主线程执行，用于处理doInBackground返回的数据
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>onPostExecute</span><span style=color:#f92672>(</span>WeatherEntity weatherEntity<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            textView<span style=color:#f92672>.</span><span style=color:#a6e22e>setText</span><span style=color:#f92672>(</span>weatherEntity<span style=color:#f92672>.</span><span style=color:#a6e22e>toString</span><span style=color:#f92672>());</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// AsyncTask可以通过调用isCancelled主动终止
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>onCancelled</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            textView<span style=color:#f92672>.</span><span style=color:#a6e22e>setText</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;Cancel!!!&#34;</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> WeatherEntity <span style=color:#a6e22e>getData</span><span style=color:#f92672>(</span>String location<span style=color:#f92672>)</span> <span style=color:#66d9ef>throws</span> IOException <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            Retrofit retrofit <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Retrofit<span style=color:#f92672>.</span><span style=color:#a6e22e>Builder</span><span style=color:#f92672>()</span>
</span></span><span style=display:flex><span>                    <span style=color:#f92672>.</span><span style=color:#a6e22e>baseUrl</span><span style=color:#f92672>(</span>URL<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>                    <span style=color:#f92672>.</span><span style=color:#a6e22e>addConverterFactory</span><span style=color:#f92672>(</span>GsonConverterFactory<span style=color:#f92672>.</span><span style=color:#a6e22e>create</span><span style=color:#f92672>())</span>
</span></span><span style=display:flex><span>                    <span style=color:#f92672>.</span><span style=color:#a6e22e>build</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>            Api api <span style=color:#f92672>=</span> retrofit<span style=color:#f92672>.</span><span style=color:#a6e22e>create</span><span style=color:#f92672>(</span>Api<span style=color:#f92672>.</span><span style=color:#a6e22e>class</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>            Call<span style=color:#f92672>&lt;</span>WeatherEntity<span style=color:#f92672>&gt;</span> call <span style=color:#f92672>=</span> api<span style=color:#f92672>.</span><span style=color:#a6e22e>getNowWeather</span><span style=color:#f92672>(</span>location<span style=color:#f92672>,</span> KEY<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> call<span style=color:#f92672>.</span><span style=color:#a6e22e>execute</span><span style=color:#f92672>().</span><span style=color:#a6e22e>body</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><h3 id=22-asynctask源码分析>2.2 AsyncTask源码分析<a hidden class=anchor aria-hidden=true href=#22-asynctask源码分析>#</a></h3><p>首先从task.execute开始</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// AsyncTask.java
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>@MainThread</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>final</span> AsyncTask<span style=color:#f92672>&lt;</span>Params<span style=color:#f92672>,</span> Progress<span style=color:#f92672>,</span> Result<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>execute</span><span style=color:#f92672>(</span>Params<span style=color:#f92672>...</span> params<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// executeOnExecutor传入两个参数sDefaultExecutor和params，
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// sDefaultExecutor看名字就知道是一个Executor，Executor提供execute方法，
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// 用于消耗Runnable，我们先看看sDefaultExecutor是什么
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>return</span> executeOnExecutor<span style=color:#f92672>(</span>sDefaultExecutor<span style=color:#f92672>,</span> params<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// sDefaultExecutor实际上是new SerialExecutor()，static修饰加上
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// synchronized修饰execute方法，保证多个Task启动execute时是按照顺序执行的
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>SerialExecutor</span> <span style=color:#66d9ef>implements</span> Executor <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// SerialExecutor提供一个队列mTasks用于保存Runnable
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// mActive表示当前需要执行的Runnable
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>final</span> ArrayDeque<span style=color:#f92672>&lt;</span>Runnable<span style=color:#f92672>&gt;</span> mTasks <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ArrayDeque<span style=color:#f92672>&lt;</span>Runnable<span style=color:#f92672>&gt;();</span>
</span></span><span style=display:flex><span>        Runnable mActive<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// execute方法把传入的Runnable加入到队列中，但是不是直接加入的，
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// 而是通过new Runnable改造了，让其在执行了run之后会执行scheduleNext
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>synchronized</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>execute</span><span style=color:#f92672>(</span><span style=color:#66d9ef>final</span> Runnable r<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            mTasks<span style=color:#f92672>.</span><span style=color:#a6e22e>offer</span><span style=color:#f92672>(</span><span style=color:#66d9ef>new</span> Runnable<span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>run</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>try</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                        r<span style=color:#f92672>.</span><span style=color:#a6e22e>run</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>                    <span style=color:#f92672>}</span> <span style=color:#66d9ef>finally</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                        scheduleNext<span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>                    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>                <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>});</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>mActive <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                scheduleNext<span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// scheduleNext从mTasks的对头取Runnable，通过THREAD_POOL_EXECUTOR
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// 执行Runnable，联系SerialExecutor的execute方法，就知道了一旦调用了
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// SerialExecutor的execute方法，就会不断从mTasks取任务，然后交给线程池
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// THREAD_POOL_EXECUTOR去执行，至于线程池是如何execute暂时不解释，
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// 只需要知道线程池会分配空闲的线程并执行传入的mFuture的run方法即可
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>synchronized</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>scheduleNext</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#f92672>((</span>mActive <span style=color:#f92672>=</span> mTasks<span style=color:#f92672>.</span><span style=color:#a6e22e>poll</span><span style=color:#f92672>())</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                THREAD_POOL_EXECUTOR<span style=color:#f92672>.</span><span style=color:#a6e22e>execute</span><span style=color:#f92672>(</span>mActive<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// THREAD_POOL_EXECUTOR就是传说中的线程池，THREAD_POOL_EXECUTOR.execute
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// 会自动使用线程池中空闲的线程完成mActive的任务
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * An {@link Executor} that can be used to execute tasks in parallel.
</span></span></span><span style=display:flex><span><span style=color:#75715e>     */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> Executor THREAD_POOL_EXECUTOR<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        ThreadPoolExecutor threadPoolExecutor <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ThreadPoolExecutor<span style=color:#f92672>(</span>
</span></span><span style=display:flex><span>                CORE_POOL_SIZE<span style=color:#f92672>,</span> MAXIMUM_POOL_SIZE<span style=color:#f92672>,</span> KEEP_ALIVE_SECONDS<span style=color:#f92672>,</span> TimeUnit<span style=color:#f92672>.</span><span style=color:#a6e22e>SECONDS</span><span style=color:#f92672>,</span>
</span></span><span style=display:flex><span>                sPoolWorkQueue<span style=color:#f92672>,</span> sThreadFactory<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        threadPoolExecutor<span style=color:#f92672>.</span><span style=color:#a6e22e>allowCoreThreadTimeOut</span><span style=color:#f92672>(</span><span style=color:#66d9ef>true</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        THREAD_POOL_EXECUTOR <span style=color:#f92672>=</span> threadPoolExecutor<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 明白了sDefaultExecutor本质上是线程池，接下来看executeOnExecutor怎么调用线程池
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>@MainThread</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>final</span> AsyncTask<span style=color:#f92672>&lt;</span>Params<span style=color:#f92672>,</span> Progress<span style=color:#f92672>,</span> Result<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>executeOnExecutor</span><span style=color:#f92672>(</span>Executor exec<span style=color:#f92672>,</span>
</span></span><span style=display:flex><span>            Params<span style=color:#f92672>...</span> params<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>mStatus <span style=color:#f92672>!=</span> Status<span style=color:#f92672>.</span><span style=color:#a6e22e>PENDING</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>switch</span> <span style=color:#f92672>(</span>mStatus<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>case</span> RUNNING<span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> IllegalStateException<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;Cannot execute task:&#34;</span>
</span></span><span style=display:flex><span>                            <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34; the task is already running.&#34;</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>case</span> FINISHED<span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> IllegalStateException<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;Cannot execute task:&#34;</span>
</span></span><span style=display:flex><span>                            <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34; the task has already been executed &#34;</span>
</span></span><span style=display:flex><span>                            <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;(a task can be executed only once)&#34;</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 首先设置了状态为RUNNING
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        mStatus <span style=color:#f92672>=</span> Status<span style=color:#f92672>.</span><span style=color:#a6e22e>RUNNING</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 这里是不是很熟悉，我们继承AsyncTask时重写的onPreExecute方法
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        onPreExecute<span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 然后将参数保存在mWorker.mParams
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        mWorker<span style=color:#f92672>.</span><span style=color:#a6e22e>mParams</span> <span style=color:#f92672>=</span> params<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 调用exec.execute，这里的exec就是上面的SerialExecutor
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        exec<span style=color:#f92672>.</span><span style=color:#a6e22e>execute</span><span style=color:#f92672>(</span>mFuture<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>this</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>    
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 此时我们需要明白mWorker和mFuture是什么，这里就要了解子类继承父类时，构造方法的执行了
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 在我们MyTask task = new MyTask();时，其实完成了父类的无参构造方法的执行，也就是AsyncTask
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 的无参构造方法
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * Creates a new asynchronous task. This constructor must be invoked on the UI thread.
</span></span></span><span style=display:flex><span><span style=color:#75715e>     */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>AsyncTask</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span><span style=color:#f92672>((</span>Looper<span style=color:#f92672>)</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 也就是说mWorker和mFuture在new MyTask()时已经完成了初始化
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>AsyncTask</span><span style=color:#f92672>(</span><span style=color:#a6e22e>@Nullable</span> Looper callbackLooper<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// callbackLooper为null，所以mHandler为getMainHandler方法的返回值，
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// 看名字就知道返回的是主线程的Handler，但是这个Handler有点东西
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        mHandler <span style=color:#f92672>=</span> callbackLooper <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>||</span> callbackLooper <span style=color:#f92672>==</span> Looper<span style=color:#f92672>.</span><span style=color:#a6e22e>getMainLooper</span><span style=color:#f92672>()</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>?</span> getMainHandler<span style=color:#f92672>()</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>:</span> <span style=color:#66d9ef>new</span> Handler<span style=color:#f92672>(</span>callbackLooper<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// mWorker提供了一个对象WorkerRunnable，WorkerRunnable实现了Callable接口的call方法
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// 当mWorker的call方法被执行时，我们就可以得到结果
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        mWorker <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> WorkerRunnable<span style=color:#f92672>&lt;</span>Params<span style=color:#f92672>,</span> Result<span style=color:#f92672>&gt;()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>public</span> Result <span style=color:#a6e22e>call</span><span style=color:#f92672>()</span> <span style=color:#66d9ef>throws</span> Exception <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                mTaskInvoked<span style=color:#f92672>.</span><span style=color:#a6e22e>set</span><span style=color:#f92672>(</span><span style=color:#66d9ef>true</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>                Result result <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>try</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                    Process<span style=color:#f92672>.</span><span style=color:#a6e22e>setThreadPriority</span><span style=color:#f92672>(</span>Process<span style=color:#f92672>.</span><span style=color:#a6e22e>THREAD_PRIORITY_BACKGROUND</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>                    <span style=color:#75715e>//noinspection unchecked
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#75715e>// 很熟悉的doInBackground方法，传入的参数为mWorker的mParams，即我们
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#75715e>// 在task.execute(&#34;beijing&#34;, 50L);传入的参数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    result <span style=color:#f92672>=</span> doInBackground<span style=color:#f92672>(</span>mParams<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>                    Binder<span style=color:#f92672>.</span><span style=color:#a6e22e>flushPendingCommands</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>                <span style=color:#f92672>}</span> <span style=color:#66d9ef>catch</span> <span style=color:#f92672>(</span>Throwable tr<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                    mCancelled<span style=color:#f92672>.</span><span style=color:#a6e22e>set</span><span style=color:#f92672>(</span><span style=color:#66d9ef>true</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>throw</span> tr<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>                <span style=color:#f92672>}</span> <span style=color:#66d9ef>finally</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                    postResult<span style=color:#f92672>(</span>result<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>                <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> result<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>};</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// mFuture以mWorker为参数实现了FutureTask，这里的FutureTask可以被SerialExecutor execute，
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// 会调用FutureTask的run方法，run方法中会执行mWorker的call方法，最终会调用FutureTask的done方法
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        mFuture <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> FutureTask<span style=color:#f92672>&lt;</span>Result<span style=color:#f92672>&gt;(</span>mWorker<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>done</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>try</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// get方法得到的是FutureTask执行run方法后得到的result
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    postResultIfNotInvoked<span style=color:#f92672>(</span>get<span style=color:#f92672>());</span>
</span></span><span style=display:flex><span>                <span style=color:#f92672>}</span> <span style=color:#66d9ef>catch</span> <span style=color:#f92672>(</span>InterruptedException e<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                    android<span style=color:#f92672>.</span><span style=color:#a6e22e>util</span><span style=color:#f92672>.</span><span style=color:#a6e22e>Log</span><span style=color:#f92672>.</span><span style=color:#a6e22e>w</span><span style=color:#f92672>(</span>LOG_TAG<span style=color:#f92672>,</span> e<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>                <span style=color:#f92672>}</span> <span style=color:#66d9ef>catch</span> <span style=color:#f92672>(</span>ExecutionException e<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> RuntimeException<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;An error occurred while executing doInBackground()&#34;</span><span style=color:#f92672>,</span>
</span></span><span style=display:flex><span>                            e<span style=color:#f92672>.</span><span style=color:#a6e22e>getCause</span><span style=color:#f92672>());</span>
</span></span><span style=display:flex><span>                <span style=color:#f92672>}</span> <span style=color:#66d9ef>catch</span> <span style=color:#f92672>(</span>CancellationException e<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                    postResultIfNotInvoked<span style=color:#f92672>(</span><span style=color:#66d9ef>null</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>                <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>};</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// postResultIfNotInvoked会进一步处理结果
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>postResultIfNotInvoked</span><span style=color:#f92672>(</span>Result result<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>boolean</span> wasTaskInvoked <span style=color:#f92672>=</span> mTaskInvoked<span style=color:#f92672>.</span><span style=color:#a6e22e>get</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>(!</span>wasTaskInvoked<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            postResult<span style=color:#f92672>(</span>result<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// postResult通过主线程的Handler发送了数据result，并标记MESSAGE_POST_RESULT
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// 表示数据已经获取完毕，应该交给主线程处理
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>private</span> Result <span style=color:#a6e22e>postResult</span><span style=color:#f92672>(</span>Result result<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>@SuppressWarnings</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;unchecked&#34;</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>        Message message <span style=color:#f92672>=</span> getHandler<span style=color:#f92672>().</span><span style=color:#a6e22e>obtainMessage</span><span style=color:#f92672>(</span>MESSAGE_POST_RESULT<span style=color:#f92672>,</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>new</span> AsyncTaskResult<span style=color:#f92672>&lt;</span>Result<span style=color:#f92672>&gt;(</span><span style=color:#66d9ef>this</span><span style=color:#f92672>,</span> result<span style=color:#f92672>));</span>
</span></span><span style=display:flex><span>        message<span style=color:#f92672>.</span><span style=color:#a6e22e>sendToTarget</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> result<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 还是记得上文介绍的Handler吗，它还有额外的功能
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>InternalHandler</span> <span style=color:#66d9ef>extends</span> Handler <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>InternalHandler</span><span style=color:#f92672>(</span>Looper looper<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>super</span><span style=color:#f92672>(</span>looper<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>@SuppressWarnings</span><span style=color:#f92672>({</span><span style=color:#e6db74>&#34;unchecked&#34;</span><span style=color:#f92672>,</span> <span style=color:#e6db74>&#34;RawUseOfParameterizedType&#34;</span><span style=color:#f92672>})</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>handleMessage</span><span style=color:#f92672>(</span>Message msg<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 在处理Message时，还可以判断并选择执行onProgressUpdate
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            AsyncTaskResult<span style=color:#f92672>&lt;?&gt;</span> result <span style=color:#f92672>=</span> <span style=color:#f92672>(</span>AsyncTaskResult<span style=color:#f92672>&lt;?&gt;)</span> msg<span style=color:#f92672>.</span><span style=color:#a6e22e>obj</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>switch</span> <span style=color:#f92672>(</span>msg<span style=color:#f92672>.</span><span style=color:#a6e22e>what</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 上面说的数据获取完毕会标记MESSAGE_POST_RESULT
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>case</span> MESSAGE_POST_RESULT<span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// There is only one result
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#75715e>// 调用mTask，这里就是AsyncTask的finish方法
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    result<span style=color:#f92672>.</span><span style=color:#a6e22e>mTask</span><span style=color:#f92672>.</span><span style=color:#a6e22e>finish</span><span style=color:#f92672>(</span>result<span style=color:#f92672>.</span><span style=color:#a6e22e>mData</span><span style=color:#f92672>[</span>0<span style=color:#f92672>]);</span>
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>break</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>case</span> MESSAGE_POST_PROGRESS<span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>                    result<span style=color:#f92672>.</span><span style=color:#a6e22e>mTask</span><span style=color:#f92672>.</span><span style=color:#a6e22e>onProgressUpdate</span><span style=color:#f92672>(</span>result<span style=color:#f92672>.</span><span style=color:#a6e22e>mData</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>break</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 熟悉的重写isCancelled和onPostExecute
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>finish</span><span style=color:#f92672>(</span>Result result<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>isCancelled<span style=color:#f92672>())</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 如果主动调用isCancelled则走onCancelled
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            onCancelled<span style=color:#f92672>(</span>result<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span> <span style=color:#66d9ef>else</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 或者最终回到我们重写的onPostExecute
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            onPostExecute<span style=color:#f92672>(</span>result<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>        mStatus <span style=color:#f92672>=</span> Status<span style=color:#f92672>.</span><span style=color:#a6e22e>FINISHED</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>    
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 以上就是正常的AsyncTask执行流程，但是别忘了我们有一个进度显示的功能
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>@WorkerThread</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>publishProgress</span><span style=color:#f92672>(</span>Progress<span style=color:#f92672>...</span> values<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>(!</span>isCancelled<span style=color:#f92672>())</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 通过Handler发送进度数据values
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// 这里就对应了上面的主线程的Handler的另一个功能，显示进度
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            getHandler<span style=color:#f92672>().</span><span style=color:#a6e22e>obtainMessage</span><span style=color:#f92672>(</span>MESSAGE_POST_PROGRESS<span style=color:#f92672>,</span>
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>new</span> AsyncTaskResult<span style=color:#f92672>&lt;</span>Progress<span style=color:#f92672>&gt;(</span><span style=color:#66d9ef>this</span><span style=color:#f92672>,</span> values<span style=color:#f92672>)).</span><span style=color:#a6e22e>sendToTarget</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span></code></pre></div><p>整理一下流程，很显然的是AsyncTask本质上还是基于Handler，但是在对线程的处理上采用了线程池，具体的执行过程：</p><ol><li>在<code>new MyTask()</code>时初始化了主线程的Handler和线程池，构造了FutureTask并提供了doInBackground的回调，并提供了通过sendToTarget的方式处理result和progress的方式；</li><li>当我们执行<code>task.execute("beijing", 50L);</code>的方法时，提供了onPreExecute的回调，并将参数传给第1步中的FutureTask，然后使用SerialExecutor execute第1步构造的的FutureTask，本质上还是线程池，只是附加了功能：连续处理队列中的所有任务；</li><li>最后将得到结果通过上面sendToTarget后Handler的回调handleMessage处理发送的数据</li></ol><p>仔细思考一下就会发现，AsyncTask提供了一个显示进度的方法，比较适用于上传下载文件的场景，因为下载进度与下载文件的大小是可知的，但是很多http框架比如Retrofit，可以很方便在接受Response的时候监听下载进度，导致AsyncTask无用武之处；同时对于登录注册功能来说，登录进度并不是很适合量化，所以也不适用；还有其他的场景我暂时也没有想到。这就导致了AsyncTask的作用被弱化了，除了集成doInBackground和onPostExecute方法就没有什么亮眼之处。</p><p>AsyncTask也提供了带Looper或者Handler参数的构造函数，此时会影响的只有postResult和publishProgress方法，即这两个方法会发送消息到Looper的线程中，但是子线程的Handler需要自定义handleMessage并自行判断msg.what，包括<code>MESSAGE_POST_RESULT</code>和<code>MESSAGE_POST_PROGRESS</code>，实现从子线程到子线程的消息传递。</p><h2 id=3-eventbus>3. EventBus<a hidden class=anchor aria-hidden=true href=#3-eventbus>#</a></h2><p>EventBus比上面介绍的两种方式更加强大，除了线程间通信之外，还可以在Activity间传递消息，同时兼具灵活的线程切换功能，先直接上一个简单的例子，依然是请求和风天气数据</p><blockquote><p>1.首先使用EventBus需要自定义MessageEvent，即通过EventBus传递的消息载体</p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MessageEvent</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> Object msg<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>MessageEvent</span><span style=color:#f92672>(</span>Object msg<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>msg</span> <span style=color:#f92672>=</span> msg<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> Object <span style=color:#a6e22e>getMsg</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> msg<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>setMsg</span><span style=color:#f92672>(</span>Object msg<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>msg</span> <span style=color:#f92672>=</span> msg<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> String <span style=color:#a6e22e>toString</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;MessageEvent{&#34;</span> <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;msg=&#34;</span> <span style=color:#f92672>+</span> msg <span style=color:#f92672>+</span> <span style=color:#e6db74>&#39;}&#39;</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><blockquote><p>2.在需要处理消息的地方（Activity）中定义Subscribe方法，这个方法可以自动接收其他地方传来的消息</p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// Subscribe注解修饰处理MessageEvent的方法，有几个参数threadMode、sticky、priority
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e>首先是threadMode：
</span></span></span><span style=display:flex><span><span style=color:#75715e>POSTING：默认，表示事件处理函数的线程跟发布事件的线程在同一个线程。
</span></span></span><span style=display:flex><span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>MAIN：表示事件处理函数的线程在主线程(UI)线程，因此在这里不能进行耗时操作。
</span></span></span><span style=display:flex><span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>BACKGROUND：表示事件处理函数的线程在后台线程，因此不能进行UI操作。
</span></span></span><span style=display:flex><span><span style=color:#75715e>如果发布事件的线程是主线程(UI线程)，那么事件处理函数将会开启一个后台线程，
</span></span></span><span style=display:flex><span><span style=color:#75715e>如果果发布事件的线程是在后台线程，那么事件处理函数就使用该线程。
</span></span></span><span style=display:flex><span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>ASYNC：表示无论事件发布的线程是哪一个，事件处理函数始终会新建一个子线程运行，同样不能进行UI操作。
</span></span></span><span style=display:flex><span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>然后是sticky，sticky用于表示是否接收粘性事件
</span></span></span><span style=display:flex><span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>最后是priority，priority决定不同的Subscribe方法接收事件的优先级，数值越大越早接收，
</span></span></span><span style=display:flex><span><span style=color:#75715e>先接受的Subscribe方法还可以禁止事件继续传递下去
</span></span></span><span style=display:flex><span><span style=color:#75715e>1. 只有当两个订阅方法使用相同的ThreadMode参数的时候，它们的优先级才会与priority指定的值一致；
</span></span></span><span style=display:flex><span><span style=color:#75715e>2. 只有当某个订阅方法的ThreadMode参数为POSTING的时候，它才能停止该事件的继续分发。
</span></span></span><span style=display:flex><span><span style=color:#75715e>**/</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// requestData方法用于处理发送的消息是String，其他则打印log
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>@Subscribe</span><span style=color:#f92672>(</span>threadMode <span style=color:#f92672>=</span> ThreadMode<span style=color:#f92672>.</span><span style=color:#a6e22e>BACKGROUND</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>requestData</span><span style=color:#f92672>(</span>MessageEvent message<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>message<span style=color:#f92672>.</span><span style=color:#a6e22e>getMsg</span><span style=color:#f92672>()</span> <span style=color:#66d9ef>instanceof</span> String<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        Retrofit retrofit <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Retrofit<span style=color:#f92672>.</span><span style=color:#a6e22e>Builder</span><span style=color:#f92672>()</span>
</span></span><span style=display:flex><span>                <span style=color:#f92672>.</span><span style=color:#a6e22e>baseUrl</span><span style=color:#f92672>(</span>URL<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>                <span style=color:#f92672>.</span><span style=color:#a6e22e>addConverterFactory</span><span style=color:#f92672>(</span>GsonConverterFactory<span style=color:#f92672>.</span><span style=color:#a6e22e>create</span><span style=color:#f92672>())</span>
</span></span><span style=display:flex><span>                <span style=color:#f92672>.</span><span style=color:#a6e22e>build</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>        Api api <span style=color:#f92672>=</span> retrofit<span style=color:#f92672>.</span><span style=color:#a6e22e>create</span><span style=color:#f92672>(</span>Api<span style=color:#f92672>.</span><span style=color:#a6e22e>class</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        Call<span style=color:#f92672>&lt;</span>WeatherEntity<span style=color:#f92672>&gt;</span> call <span style=color:#f92672>=</span> api<span style=color:#f92672>.</span><span style=color:#a6e22e>getNowWeather</span><span style=color:#f92672>(</span>message<span style=color:#f92672>.</span><span style=color:#a6e22e>getMsg</span><span style=color:#f92672>().</span><span style=color:#a6e22e>toString</span><span style=color:#f92672>(),</span> KEY<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 通过EventBus把请求得到的天气发送出去
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            EventBus<span style=color:#f92672>.</span><span style=color:#a6e22e>getDefault</span><span style=color:#f92672>().</span><span style=color:#a6e22e>post</span><span style=color:#f92672>(</span><span style=color:#66d9ef>new</span> MessageEvent<span style=color:#f92672>(</span>call<span style=color:#f92672>.</span><span style=color:#a6e22e>execute</span><span style=color:#f92672>().</span><span style=color:#a6e22e>body</span><span style=color:#f92672>()));</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span> <span style=color:#66d9ef>catch</span> <span style=color:#f92672>(</span>IOException e<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            e<span style=color:#f92672>.</span><span style=color:#a6e22e>printStackTrace</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span> <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>message<span style=color:#f92672>.</span><span style=color:#a6e22e>getMsg</span><span style=color:#f92672>()</span> <span style=color:#66d9ef>instanceof</span> WeatherEntity<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        Log<span style=color:#f92672>.</span><span style=color:#a6e22e>i</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;aaaa&#34;</span><span style=color:#f92672>,</span> <span style=color:#e6db74>&#34;ThreadMode.BACKGROUND: &#34;</span> <span style=color:#f92672>+</span> message<span style=color:#f92672>.</span><span style=color:#a6e22e>getMsg</span><span style=color:#f92672>().</span><span style=color:#a6e22e>toString</span><span style=color:#f92672>());</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// showMessage方法用于处理发送的消息是WeatherEntity，将其显示到TextView上，其他类型则打印log
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>@Subscribe</span><span style=color:#f92672>(</span>threadMode <span style=color:#f92672>=</span> ThreadMode<span style=color:#f92672>.</span><span style=color:#a6e22e>MAIN</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>showMessage</span><span style=color:#f92672>(</span>MessageEvent message<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>message<span style=color:#f92672>.</span><span style=color:#a6e22e>getMsg</span><span style=color:#f92672>()</span> <span style=color:#66d9ef>instanceof</span> WeatherEntity<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        textView<span style=color:#f92672>.</span><span style=color:#a6e22e>setText</span><span style=color:#f92672>(</span>message<span style=color:#f92672>.</span><span style=color:#a6e22e>getMsg</span><span style=color:#f92672>().</span><span style=color:#a6e22e>toString</span><span style=color:#f92672>());</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span> <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>message<span style=color:#f92672>.</span><span style=color:#a6e22e>getMsg</span><span style=color:#f92672>()</span> <span style=color:#66d9ef>instanceof</span> String<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        Log<span style=color:#f92672>.</span><span style=color:#a6e22e>i</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;aaaa&#34;</span><span style=color:#f92672>,</span> <span style=color:#e6db74>&#34;ThreadMode.MAIN: &#34;</span> <span style=color:#f92672>+</span> message<span style=color:#f92672>.</span><span style=color:#a6e22e>getMsg</span><span style=color:#f92672>().</span><span style=color:#a6e22e>toString</span><span style=color:#f92672>());</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><blockquote><p>3.在onStart和onStop中注册和取消注册</p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>onStart</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    EventBus<span style=color:#f92672>.</span><span style=color:#a6e22e>getDefault</span><span style=color:#f92672>().</span><span style=color:#a6e22e>register</span><span style=color:#f92672>(</span><span style=color:#66d9ef>this</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>super</span><span style=color:#f92672>.</span><span style=color:#a6e22e>onStart</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>onStop</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    EventBus<span style=color:#f92672>.</span><span style=color:#a6e22e>getDefault</span><span style=color:#f92672>().</span><span style=color:#a6e22e>unregister</span><span style=color:#f92672>(</span><span style=color:#66d9ef>this</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>super</span><span style=color:#f92672>.</span><span style=color:#a6e22e>onStop</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><blockquote><p>4.发送消息</p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>onCreate</span><span style=color:#f92672>(</span>Bundle savedInstanceState<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>super</span><span style=color:#f92672>.</span><span style=color:#a6e22e>onCreate</span><span style=color:#f92672>(</span>savedInstanceState<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    setContentView<span style=color:#f92672>(</span>R<span style=color:#f92672>.</span><span style=color:#a6e22e>layout</span><span style=color:#f92672>.</span><span style=color:#a6e22e>activity_main</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    textView <span style=color:#f92672>=</span> findViewById<span style=color:#f92672>(</span>R<span style=color:#f92672>.</span><span style=color:#a6e22e>id</span><span style=color:#f92672>.</span><span style=color:#a6e22e>textView</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    textView<span style=color:#f92672>.</span><span style=color:#a6e22e>setOnClickListener</span><span style=color:#f92672>(</span><span style=color:#66d9ef>new</span> View<span style=color:#f92672>.</span><span style=color:#a6e22e>OnClickListener</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>onClick</span><span style=color:#f92672>(</span>View v<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 发送的消息本体是String，即请求的location
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            EventBus<span style=color:#f92672>.</span><span style=color:#a6e22e>getDefault</span><span style=color:#f92672>().</span><span style=color:#a6e22e>post</span><span style=color:#f92672>(</span><span style=color:#66d9ef>new</span> MessageEvent<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;beijing&#34;</span><span style=color:#f92672>));</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>});</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p>当我们点击textView的时候就会发送消息<code>new MessageEvent("beijing")</code>出去，如果打断点观察消息发送的流程就会清楚：</p><ol><li>我们在主线程发送的消息会首先由<code>ThreadMode.MAIN</code>的方法处理，此时就会打印log：</li><li>然后消息会发送到requestData方法，而requestData方法是<code>ThreadMode.BACKGROUND</code>，所以它会在子线程中执行，我们在子线程中又发了<code>new MessageEvent(call.execute().body())</code>，因此消息会首先由<code>ThreadMode.BACKGROUND</code>的方法处理，即requestData方法自身，此时打印log；</li><li>最后消息又传到了showMessage方法中，而showMessage方法是<code>ThreadMode.MAIN</code>，所以可以执行在主线程，因此textView被设置了text，整个消息传递流程结束。</li></ol><p>根据上面的例子基本可以了解了EventBus发送消息的机制，类似于广播，不同的threadMode参数决定这个方法的执行线程，而消息发送时会首先发到当前线程的方法中，如果在这个方法中消息没有被取消，则会继续广播到其他线程的方法中，具体顺序可以测试一下，直到没有可以处理此消息的方法，整个消息传播的流程就结束了。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// 以下列方法处理从主线程发送的MessageEvent，我们观察一下log的顺序
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>@Subscribe</span><span style=color:#f92672>(</span>threadMode <span style=color:#f92672>=</span> ThreadMode<span style=color:#f92672>.</span><span style=color:#a6e22e>MAIN</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>broadcastMessage1</span><span style=color:#f92672>(</span>MessageEvent message<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    Log<span style=color:#f92672>.</span><span style=color:#a6e22e>i</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;aaaa&#34;</span><span style=color:#f92672>,</span> <span style=color:#e6db74>&#34;ThreadMode.MAIN: &#34;</span> <span style=color:#f92672>+</span> message<span style=color:#f92672>.</span><span style=color:#a6e22e>getMsg</span><span style=color:#f92672>().</span><span style=color:#a6e22e>toString</span><span style=color:#f92672>());</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@Subscribe</span><span style=color:#f92672>(</span>threadMode <span style=color:#f92672>=</span> ThreadMode<span style=color:#f92672>.</span><span style=color:#a6e22e>BACKGROUND</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>broadcastMessage2</span><span style=color:#f92672>(</span>MessageEvent message<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    Log<span style=color:#f92672>.</span><span style=color:#a6e22e>i</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;aaaa&#34;</span><span style=color:#f92672>,</span> <span style=color:#e6db74>&#34;ThreadMode.BACKGROUND: &#34;</span> <span style=color:#f92672>+</span> message<span style=color:#f92672>.</span><span style=color:#a6e22e>getMsg</span><span style=color:#f92672>().</span><span style=color:#a6e22e>toString</span><span style=color:#f92672>());</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@Subscribe</span><span style=color:#f92672>(</span>threadMode <span style=color:#f92672>=</span> ThreadMode<span style=color:#f92672>.</span><span style=color:#a6e22e>POSTING</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>broadcastMessage3</span><span style=color:#f92672>(</span>MessageEvent message<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    Log<span style=color:#f92672>.</span><span style=color:#a6e22e>i</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;aaaa&#34;</span><span style=color:#f92672>,</span> <span style=color:#e6db74>&#34;ThreadMode.POSTING: &#34;</span> <span style=color:#f92672>+</span> message<span style=color:#f92672>.</span><span style=color:#a6e22e>getMsg</span><span style=color:#f92672>().</span><span style=color:#a6e22e>toString</span><span style=color:#f92672>());</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@Subscribe</span><span style=color:#f92672>(</span>threadMode <span style=color:#f92672>=</span> ThreadMode<span style=color:#f92672>.</span><span style=color:#a6e22e>ASYNC</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>broadcastMessage4</span><span style=color:#f92672>(</span>MessageEvent message<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    Log<span style=color:#f92672>.</span><span style=color:#a6e22e>i</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;aaaa&#34;</span><span style=color:#f92672>,</span> <span style=color:#e6db74>&#34;ThreadMode.ASYNC: &#34;</span> <span style=color:#f92672>+</span> message<span style=color:#f92672>.</span><span style=color:#a6e22e>getMsg</span><span style=color:#f92672>().</span><span style=color:#a6e22e>toString</span><span style=color:#f92672>());</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p>依次是MAIN -> POSTING -> BACKGROUND -> ASYNC</p><pre tabindex=0><code class=language-log data-lang=log>2019-07-28 20:40:38.419 28604-28604/com.example.gsondemo I/aaaa: ThreadMode.MAIN: beijing
2019-07-28 20:40:38.420 28604-28604/com.example.gsondemo I/aaaa: ThreadMode.POSTING: beijing
2019-07-28 20:40:38.421 28604-28765/com.example.gsondemo I/aaaa: ThreadMode.BACKGROUND: beijing
2019-07-28 20:40:38.422 28604-28766/com.example.gsondemo I/aaaa: ThreadMode.ASYNC: beijing
</code></pre><p>在看一下从BACKGROUND子线程发送的MessageEvent，依次是BACKGROUND -> POSTING -> MAIN -> ASYNC</p><pre tabindex=0><code class=language-log data-lang=log>2019-07-28 20:53:27.151 30433-30481/com.example.gsondemo I/aaaa: ThreadMode.BACKGROUND: shanghai
2019-07-28 20:53:27.151 30433-30481/com.example.gsondemo I/aaaa: ThreadMode.POSTING: shanghai
2019-07-28 20:53:27.152 30433-30433/com.example.gsondemo I/aaaa: ThreadMode.MAIN: shanghai
2019-07-28 20:53:27.152 30433-30482/com.example.gsondemo I/aaaa: ThreadMode.ASYNC: shanghai
</code></pre><p>消息广播的规则应该是首先是发送到post所在的线程，然后是POSTING，然后是其他线程，最后是ASYNC，因此我们可以在POSTING方法中取消消息的广播，那么消息就会被中断。</p><ul><li>普通事件删除</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>EventBus<span style=color:#f92672>.</span><span style=color:#a6e22e>getDefault</span><span style=color:#f92672>().</span><span style=color:#a6e22e>cancelEventDelivery</span><span style=color:#f92672>(</span>event<span style=color:#f92672>);</span>
</span></span></code></pre></div><ul><li>粘性事件删除</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>//指定粘性事件删除  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>T stickyEvent <span style=color:#f92672>=</span> EventBus<span style=color:#f92672>.</span><span style=color:#a6e22e>getDefault</span><span style=color:#f92672>().</span><span style=color:#a6e22e>getStickyEvent</span><span style=color:#f92672>(</span>eventType<span style=color:#f92672>);</span>  
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>stickyEvent <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    EventBus<span style=color:#f92672>.</span><span style=color:#a6e22e>getDefault</span><span style=color:#f92672>().</span><span style=color:#a6e22e>removeStickyEvent</span><span style=color:#f92672>(</span>stickyEvent<span style=color:#f92672>);</span>  
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>//删除所有粘性事件 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>EventBus<span style=color:#f92672>.</span><span style=color:#a6e22e>getDefault</span><span style=color:#f92672>().</span><span style=color:#a6e22e>removeAllStickyEvents</span><span style=color:#f92672>();</span>
</span></span></code></pre></div><p>除了普通事件之外，EventBus还可以发送粘性事件，解释起来比较复杂，简而言之就是让消息“飞一会”，在我们主动注册时才处理消息，用代码来解释</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// 代码是类似的，只是这次不在onStart方法内注册，而是通过button点击注册
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>onCreate</span><span style=color:#f92672>(</span>Bundle savedInstanceState<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>super</span><span style=color:#f92672>.</span><span style=color:#a6e22e>onCreate</span><span style=color:#f92672>(</span>savedInstanceState<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    setContentView<span style=color:#f92672>(</span>R<span style=color:#f92672>.</span><span style=color:#a6e22e>layout</span><span style=color:#f92672>.</span><span style=color:#a6e22e>activity_main</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    textView <span style=color:#f92672>=</span> findViewById<span style=color:#f92672>(</span>R<span style=color:#f92672>.</span><span style=color:#a6e22e>id</span><span style=color:#f92672>.</span><span style=color:#a6e22e>textView</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    button <span style=color:#f92672>=</span> findViewById<span style=color:#f92672>(</span>R<span style=color:#f92672>.</span><span style=color:#a6e22e>id</span><span style=color:#f92672>.</span><span style=color:#a6e22e>button</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    textView<span style=color:#f92672>.</span><span style=color:#a6e22e>setOnClickListener</span><span style=color:#f92672>(</span><span style=color:#66d9ef>new</span> View<span style=color:#f92672>.</span><span style=color:#a6e22e>OnClickListener</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>onClick</span><span style=color:#f92672>(</span>View v<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// postSticky替代post
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            EventBus<span style=color:#f92672>.</span><span style=color:#a6e22e>getDefault</span><span style=color:#f92672>().</span><span style=color:#a6e22e>postSticky</span><span style=color:#f92672>(</span><span style=color:#66d9ef>new</span> MessageEvent<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;beijing&#34;</span><span style=color:#f92672>));</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>});</span>
</span></span><span style=display:flex><span>    button<span style=color:#f92672>.</span><span style=color:#a6e22e>setOnClickListener</span><span style=color:#f92672>(</span><span style=color:#66d9ef>new</span> View<span style=color:#f92672>.</span><span style=color:#a6e22e>OnClickListener</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>onClick</span><span style=color:#f92672>(</span>View v<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            EventBus<span style=color:#f92672>.</span><span style=color:#a6e22e>getDefault</span><span style=color:#f92672>().</span><span style=color:#a6e22e>register</span><span style=color:#f92672>(</span>MainActivity<span style=color:#f92672>.</span><span style=color:#a6e22e>this</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>});</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 增加sticky = true
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>@Subscribe</span><span style=color:#f92672>(</span>threadMode <span style=color:#f92672>=</span> ThreadMode<span style=color:#f92672>.</span><span style=color:#a6e22e>BACKGROUND</span><span style=color:#f92672>,</span> sticky <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>requestData</span><span style=color:#f92672>(</span>MessageEvent message<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>message<span style=color:#f92672>.</span><span style=color:#a6e22e>getMsg</span><span style=color:#f92672>()</span> <span style=color:#66d9ef>instanceof</span> String<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        Retrofit retrofit <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Retrofit<span style=color:#f92672>.</span><span style=color:#a6e22e>Builder</span><span style=color:#f92672>()</span>
</span></span><span style=display:flex><span>                <span style=color:#f92672>.</span><span style=color:#a6e22e>baseUrl</span><span style=color:#f92672>(</span>URL<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>                <span style=color:#f92672>.</span><span style=color:#a6e22e>addConverterFactory</span><span style=color:#f92672>(</span>GsonConverterFactory<span style=color:#f92672>.</span><span style=color:#a6e22e>create</span><span style=color:#f92672>())</span>
</span></span><span style=display:flex><span>                <span style=color:#f92672>.</span><span style=color:#a6e22e>build</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>        Api api <span style=color:#f92672>=</span> retrofit<span style=color:#f92672>.</span><span style=color:#a6e22e>create</span><span style=color:#f92672>(</span>Api<span style=color:#f92672>.</span><span style=color:#a6e22e>class</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        Call<span style=color:#f92672>&lt;</span>WeatherEntity<span style=color:#f92672>&gt;</span> call <span style=color:#f92672>=</span> api<span style=color:#f92672>.</span><span style=color:#a6e22e>getNowWeather</span><span style=color:#f92672>(</span>message<span style=color:#f92672>.</span><span style=color:#a6e22e>getMsg</span><span style=color:#f92672>().</span><span style=color:#a6e22e>toString</span><span style=color:#f92672>(),</span> KEY<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            EventBus<span style=color:#f92672>.</span><span style=color:#a6e22e>getDefault</span><span style=color:#f92672>().</span><span style=color:#a6e22e>post</span><span style=color:#f92672>(</span><span style=color:#66d9ef>new</span> MessageEvent<span style=color:#f92672>(</span>call<span style=color:#f92672>.</span><span style=color:#a6e22e>execute</span><span style=color:#f92672>().</span><span style=color:#a6e22e>body</span><span style=color:#f92672>()));</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span> <span style=color:#66d9ef>catch</span> <span style=color:#f92672>(</span>IOException e<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            e<span style=color:#f92672>.</span><span style=color:#a6e22e>printStackTrace</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span> <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>message<span style=color:#f92672>.</span><span style=color:#a6e22e>getMsg</span><span style=color:#f92672>()</span> <span style=color:#66d9ef>instanceof</span> WeatherEntity<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        Log<span style=color:#f92672>.</span><span style=color:#a6e22e>i</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;aaaa&#34;</span><span style=color:#f92672>,</span> <span style=color:#e6db74>&#34;ThreadMode.BACKGROUND: &#34;</span> <span style=color:#f92672>+</span> message<span style=color:#f92672>.</span><span style=color:#a6e22e>getMsg</span><span style=color:#f92672>().</span><span style=color:#a6e22e>toString</span><span style=color:#f92672>());</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 增加sticky = true
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>@Subscribe</span><span style=color:#f92672>(</span>threadMode <span style=color:#f92672>=</span> ThreadMode<span style=color:#f92672>.</span><span style=color:#a6e22e>MAIN</span><span style=color:#f92672>,</span> sticky <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>showMessage</span><span style=color:#f92672>(</span>MessageEvent message<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>message<span style=color:#f92672>.</span><span style=color:#a6e22e>getMsg</span><span style=color:#f92672>()</span> <span style=color:#66d9ef>instanceof</span> WeatherEntity<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        textView<span style=color:#f92672>.</span><span style=color:#a6e22e>setText</span><span style=color:#f92672>(</span>message<span style=color:#f92672>.</span><span style=color:#a6e22e>getMsg</span><span style=color:#f92672>().</span><span style=color:#a6e22e>toString</span><span style=color:#f92672>());</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span> <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>message<span style=color:#f92672>.</span><span style=color:#a6e22e>getMsg</span><span style=color:#f92672>()</span> <span style=color:#66d9ef>instanceof</span> String<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        Log<span style=color:#f92672>.</span><span style=color:#a6e22e>i</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;aaaa&#34;</span><span style=color:#f92672>,</span> <span style=color:#e6db74>&#34;ThreadMode.MAIN: &#34;</span> <span style=color:#f92672>+</span> message<span style=color:#f92672>.</span><span style=color:#a6e22e>getMsg</span><span style=color:#f92672>().</span><span style=color:#a6e22e>toString</span><span style=color:#f92672>());</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>onStart</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>super</span><span style=color:#f92672>.</span><span style=color:#a6e22e>onStart</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>onStop</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    EventBus<span style=color:#f92672>.</span><span style=color:#a6e22e>getDefault</span><span style=color:#f92672>().</span><span style=color:#a6e22e>unregister</span><span style=color:#f92672>(</span><span style=color:#66d9ef>this</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>super</span><span style=color:#f92672>.</span><span style=color:#a6e22e>onStop</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p>这样的结果就是当我们点击textView时，事件就会发出，但是Subscribe方法没有接收，当且仅当我们点击了button时，事件才开始被接收，即我们让消息在运行时“飞了一会”，消息并不会丢失，当我们主动去注册时才开始处理，这就是粘性事件。</p><p>priority就不详细解释了，对于有相同threadMode的方法，priority值越大越先接收到消息。</p><p>EventBus源码解析暂时留个坑。</p><h2 id=4-rxjava>4. RxJava<a hidden class=anchor aria-hidden=true href=#4-rxjava>#</a></h2><p><code>RxJava – Reactive Extensions for the JVM – a library for composing asynchronous and event-based programs using observable sequences for the Java VM.</code></p><p>RxJava也是一个可以用于处理线程间通信的工具，但是功能非常强大（不仅限于线程间通信），不仅可以用于Java Web项目也可以在Android项目中使用，RxJava的使用方式与上述各种工具或者框架不太一样，它是通过流式调用的形式使用的。目前有三个版本分别是Version 1.x、Version 2.x以及最新的Version 3.x，新版本加入新的特性比如背压、Java 8等等，这里仅演示RxJava2</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-gradle data-lang=gradle><span style=display:flex><span>implementation <span style=color:#e6db74>&#34;io.reactivex.rxjava2:rxjava:2.2.8&#34;</span> <span style=color:#75715e>// 必要rxjava2依赖
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>implementation <span style=color:#e6db74>&#34;io.reactivex.rxjava2:rxandroid:2.1.0&#34;</span> <span style=color:#75715e>// 必要rxandrroid依赖，切线程时需要用到AndroidSchedulers.mainThread()
</span></span></span></code></pre></div><h3 id=41-rxjava结合retrofit>4.1 RxJava结合Retrofit<a hidden class=anchor aria-hidden=true href=#41-rxjava结合retrofit>#</a></h3><p>还是以请求和风天气数据为例，这是Retrofit与RxJava的结合使用，RxJava使用的是观察者模式，这里就不详细解释</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>Retrofit retrofit <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Retrofit<span style=color:#f92672>.</span><span style=color:#a6e22e>Builder</span><span style=color:#f92672>()</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>.</span><span style=color:#a6e22e>baseUrl</span><span style=color:#f92672>(</span>URL<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>.</span><span style=color:#a6e22e>addConverterFactory</span><span style=color:#f92672>(</span>GsonConverterFactory<span style=color:#f92672>.</span><span style=color:#a6e22e>create</span><span style=color:#f92672>())</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>.</span><span style=color:#a6e22e>addCallAdapterFactory</span><span style=color:#f92672>(</span>RxJava2CallAdapterFactory<span style=color:#f92672>.</span><span style=color:#a6e22e>create</span><span style=color:#f92672>())</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>.</span><span style=color:#a6e22e>build</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Api api <span style=color:#f92672>=</span> retrofit<span style=color:#f92672>.</span><span style=color:#a6e22e>create</span><span style=color:#f92672>(</span>Api<span style=color:#f92672>.</span><span style=color:#a6e22e>class</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 这里的getNowWeather方法在Api.java中返回的是Observable
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>api<span style=color:#f92672>.</span><span style=color:#a6e22e>getNowWeather</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;beijing&#34;</span><span style=color:#f92672>,</span> KEY<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>.</span><span style=color:#a6e22e>subscribeOn</span><span style=color:#f92672>(</span>Schedulers<span style=color:#f92672>.</span><span style=color:#a6e22e>io</span><span style=color:#f92672>())</span> <span style=color:#75715e>// subscribeOn参数为io线程，表明getNowWeather请求数据执行在io线程
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#f92672>.</span><span style=color:#a6e22e>observeOn</span><span style=color:#f92672>(</span>AndroidSchedulers<span style=color:#f92672>.</span><span style=color:#a6e22e>mainThread</span><span style=color:#f92672>())</span> <span style=color:#75715e>// observeOn参数为主线程，表明请求结束传递的数据在主线程处理
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#f92672>.</span><span style=color:#a6e22e>subscribe</span><span style=color:#f92672>(</span><span style=color:#66d9ef>new</span> Consumer<span style=color:#f92672>&lt;</span>WeatherEntity<span style=color:#f92672>&gt;()</span> <span style=color:#f92672>{</span> <span style=color:#75715e>// subscribe定义上面observeOn进行的方法，RxJava2中以Consumer代理处理，一般来说有两个Consumer，一个用于处理请求成功的数据，另一个处理异常
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>accept</span><span style=color:#f92672>(</span>WeatherEntity weatherEntity<span style=color:#f92672>)</span> <span style=color:#66d9ef>throws</span> Exception <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                textView<span style=color:#f92672>.</span><span style=color:#a6e22e>setText</span><span style=color:#f92672>(</span>weatherEntity<span style=color:#f92672>.</span><span style=color:#a6e22e>toString</span><span style=color:#f92672>());</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>},</span> <span style=color:#66d9ef>new</span> Consumer<span style=color:#f92672>&lt;</span>Throwable<span style=color:#f92672>&gt;()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>accept</span><span style=color:#f92672>(</span>Throwable throwable<span style=color:#f92672>)</span> <span style=color:#66d9ef>throws</span> Exception <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                Log<span style=color:#f92672>.</span><span style=color:#a6e22e>i</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;aaaa&#34;</span><span style=color:#f92672>,</span> throwable<span style=color:#f92672>.</span><span style=color:#a6e22e>getMessage</span><span style=color:#f92672>());</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>});</span>
</span></span></code></pre></div><h3 id=42-rxjava源码分析>4.2 RxJava源码分析<a hidden class=anchor aria-hidden=true href=#42-rxjava源码分析>#</a></h3><p>虽然上面的代码只演示了RxJava的线程切换功能，但是实际上RxJava的功能非常强大，在处理大量数据的情况下能够更加简洁有效的代码完成，同时兼具数据变换的功能，这里三言两语很难表述清除，需要实战演练就能够明白，与此同时，基于RxJava我们也可以自定义更多的工具函数，以RxJava流式调用的方式来使用。</p><p><strong>Observable警告：RxJava提供的各种方法比如subscribeOn、observeOn以及doOnNext等都会创建新的Observable和Observer，Observable是数据的被观察者，它保存了我们需要的数据；Observer是数据的观察者，数据如何发送、在哪个线程处理、如何处理异常等都是通过Observer处理的，一般来说每一个自定义的Observable都有一个内部类Observer，只是这个Observer是给上一级的Observable调用</strong></p><p>首先我们需要知道<code>retrofit.create(Api.class)</code>创建了什么，这个在Retrofit框架分析中已经做过了，在这种情况下是通过RxJava2CallAdapterFactory的RxJava2CallAdapter调用adapt方法返回的Observable</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// RxJava2CallAdapter.java
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>@Override</span> <span style=color:#66d9ef>public</span> Object <span style=color:#a6e22e>adapt</span><span style=color:#f92672>(</span>Call<span style=color:#f92672>&lt;</span>R<span style=color:#f92672>&gt;</span> call<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 首先是创建CallExecuteObservable
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    Observable<span style=color:#f92672>&lt;</span>Response<span style=color:#f92672>&lt;</span>R<span style=color:#f92672>&gt;&gt;</span> responseObservable <span style=color:#f92672>=</span> isAsync
</span></span><span style=display:flex><span>        <span style=color:#f92672>?</span> <span style=color:#66d9ef>new</span> CallEnqueueObservable<span style=color:#f92672>&lt;&gt;(</span>call<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>:</span> <span style=color:#66d9ef>new</span> CallExecuteObservable<span style=color:#f92672>&lt;&gt;(</span>call<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Observable<span style=color:#f92672>&lt;?&gt;</span> observable<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>isResult<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>      observable <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ResultObservable<span style=color:#f92672>&lt;&gt;(</span>responseObservable<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span> <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>isBody<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>// 然后根据参数，返回的是BodyObservable
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      observable <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> BodyObservable<span style=color:#f92672>&lt;&gt;(</span>responseObservable<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span> <span style=color:#66d9ef>else</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>      observable <span style=color:#f92672>=</span> responseObservable<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>scheduler <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>      observable <span style=color:#f92672>=</span> observable<span style=color:#f92672>.</span><span style=color:#a6e22e>subscribeOn</span><span style=color:#f92672>(</span>scheduler<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>isFlowable<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span> observable<span style=color:#f92672>.</span><span style=color:#a6e22e>toFlowable</span><span style=color:#f92672>(</span>BackpressureStrategy<span style=color:#f92672>.</span><span style=color:#a6e22e>LATEST</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>isSingle<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span> observable<span style=color:#f92672>.</span><span style=color:#a6e22e>singleOrError</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>isMaybe<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span> observable<span style=color:#f92672>.</span><span style=color:#a6e22e>singleElement</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>isCompletable<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span> observable<span style=color:#f92672>.</span><span style=color:#a6e22e>ignoreElements</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> RxJavaPlugins<span style=color:#f92672>.</span><span style=color:#a6e22e>onAssembly</span><span style=color:#f92672>(</span>observable<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>}</span>
</span></span></code></pre></div><p>而BodyObservable继承自Observable，并且有一个内部类BodyObserver</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// BodyObservable.java
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>final</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>BodyObservable</span><span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>extends</span> Observable<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> Observable<span style=color:#f92672>&lt;</span>Response<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;&gt;</span> upstream<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  BodyObservable<span style=color:#f92672>(</span>Observable<span style=color:#f92672>&lt;</span>Response<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;&gt;</span> upstream<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>upstream</span> <span style=color:#f92672>=</span> upstream<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// subscribeActual方法会在Observable调用subscribe方法时被调用
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>@Override</span> <span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>subscribeActual</span><span style=color:#f92672>(</span>Observer<span style=color:#f92672>&lt;?</span> <span style=color:#66d9ef>super</span> T<span style=color:#f92672>&gt;</span> observer<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    upstream<span style=color:#f92672>.</span><span style=color:#a6e22e>subscribe</span><span style=color:#f92672>(</span><span style=color:#66d9ef>new</span> BodyObserver<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;(</span>observer<span style=color:#f92672>));</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>BodyObserver</span><span style=color:#f92672>&lt;</span>R<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>implements</span> Observer<span style=color:#f92672>&lt;</span>Response<span style=color:#f92672>&lt;</span>R<span style=color:#f92672>&gt;&gt;</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> Observer<span style=color:#f92672>&lt;?</span> <span style=color:#66d9ef>super</span> R<span style=color:#f92672>&gt;</span> observer<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>boolean</span> terminated<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    BodyObserver<span style=color:#f92672>(</span>Observer<span style=color:#f92672>&lt;?</span> <span style=color:#66d9ef>super</span> R<span style=color:#f92672>&gt;</span> observer<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>observer</span> <span style=color:#f92672>=</span> observer<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// BodyObserver实现了Observer的4个方法onSubscribe、onNext、onComplete、onError，
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 但是不是BodyObserver自己完成的，而是通过传入的observer代替完成大部分功能，而BodyObserver
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 只对传过来的Response进行简单判断就交给observer了
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>@Override</span> <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>onSubscribe</span><span style=color:#f92672>(</span>Disposable disposable<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>      observer<span style=color:#f92672>.</span><span style=color:#a6e22e>onSubscribe</span><span style=color:#f92672>(</span>disposable<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span> <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>onNext</span><span style=color:#f92672>(</span>Response<span style=color:#f92672>&lt;</span>R<span style=color:#f92672>&gt;</span> response<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>response<span style=color:#f92672>.</span><span style=color:#a6e22e>isSuccessful</span><span style=color:#f92672>())</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 比如判断response是否是成功从服务器返回的，然后交给observer的onNext方法，
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// 此时传给observer的就是response的body了，对应我们使用的GsonConverterFactory，
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// 那这个body就是WeatherEntity实例
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        observer<span style=color:#f92672>.</span><span style=color:#a6e22e>onNext</span><span style=color:#f92672>(</span>response<span style=color:#f92672>.</span><span style=color:#a6e22e>body</span><span style=color:#f92672>());</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>}</span> <span style=color:#66d9ef>else</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        terminated <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>        Throwable t <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> HttpException<span style=color:#f92672>(</span>response<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>          observer<span style=color:#f92672>.</span><span style=color:#a6e22e>onError</span><span style=color:#f92672>(</span>t<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span> <span style=color:#66d9ef>catch</span> <span style=color:#f92672>(</span>Throwable inner<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>          Exceptions<span style=color:#f92672>.</span><span style=color:#a6e22e>throwIfFatal</span><span style=color:#f92672>(</span>inner<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>          RxJavaPlugins<span style=color:#f92672>.</span><span style=color:#a6e22e>onError</span><span style=color:#f92672>(</span><span style=color:#66d9ef>new</span> CompositeException<span style=color:#f92672>(</span>t<span style=color:#f92672>,</span> inner<span style=color:#f92672>));</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span> <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>onComplete</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> <span style=color:#f92672>(!</span>terminated<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        observer<span style=color:#f92672>.</span><span style=color:#a6e22e>onComplete</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span> <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>onError</span><span style=color:#f92672>(</span>Throwable throwable<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> <span style=color:#f92672>(!</span>terminated<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        observer<span style=color:#f92672>.</span><span style=color:#a6e22e>onError</span><span style=color:#f92672>(</span>throwable<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>}</span> <span style=color:#66d9ef>else</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// This should never happen! onNext handles and forwards errors automatically.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        Throwable broken <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> AssertionError<span style=color:#f92672>(</span>
</span></span><span style=display:flex><span>            <span style=color:#e6db74>&#34;This should never happen! Report as a bug with the full stacktrace.&#34;</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>//noinspection UnnecessaryInitCause Two-arg AssertionError constructor is 1.7+ only.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        broken<span style=color:#f92672>.</span><span style=color:#a6e22e>initCause</span><span style=color:#f92672>(</span>throwable<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        RxJavaPlugins<span style=color:#f92672>.</span><span style=color:#a6e22e>onError</span><span style=color:#f92672>(</span>broken<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p>创建完Observable后紧接着是subscribeOn、observeOn以及subscribe方法，很显然这些方法都是Observable的方法</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// Observable.java
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>@CheckReturnValue</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@SchedulerSupport</span><span style=color:#f92672>(</span>SchedulerSupport<span style=color:#f92672>.</span><span style=color:#a6e22e>CUSTOM</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>final</span> Observable<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>subscribeOn</span><span style=color:#f92672>(</span>Scheduler scheduler<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        ObjectHelper<span style=color:#f92672>.</span><span style=color:#a6e22e>requireNonNull</span><span style=color:#f92672>(</span>scheduler<span style=color:#f92672>,</span> <span style=color:#e6db74>&#34;scheduler is null&#34;</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> RxJavaPlugins<span style=color:#f92672>.</span><span style=color:#a6e22e>onAssembly</span><span style=color:#f92672>(</span><span style=color:#66d9ef>new</span> ObservableSubscribeOn<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;(</span><span style=color:#66d9ef>this</span><span style=color:#f92672>,</span> scheduler<span style=color:#f92672>));</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>    
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// Observable.java
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>@NonNull</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> Observable<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>onAssembly</span><span style=color:#f92672>(</span><span style=color:#a6e22e>@NonNull</span> Observable<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> source<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 一般来说onObservableAssembly在没有调用reset方法的情况下为空，所以这里肯定为空
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        Function<span style=color:#f92672>&lt;?</span> <span style=color:#66d9ef>super</span> Observable<span style=color:#f92672>,</span> <span style=color:#f92672>?</span> <span style=color:#66d9ef>extends</span> Observable<span style=color:#f92672>&gt;</span> f <span style=color:#f92672>=</span> onObservableAssembly<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>f <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> apply<span style=color:#f92672>(</span>f<span style=color:#f92672>,</span> source<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 也就是说这个onAssembly方法直接返回了source，所以上面的subscribeOn方法返回的是ObservableSubscribeOn
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>return</span> source<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span></code></pre></div><p>subscribeOn方法之后我们得到了一个新的ObservableSubscribeOn，它保存了BodyObservable以及加入的参数Schedulers.io()，接下来继续调用observeOn</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// Observable.java
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>@CheckReturnValue</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@SchedulerSupport</span><span style=color:#f92672>(</span>SchedulerSupport<span style=color:#f92672>.</span><span style=color:#a6e22e>CUSTOM</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>final</span> Observable<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>observeOn</span><span style=color:#f92672>(</span>Scheduler scheduler<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> observeOn<span style=color:#f92672>(</span>scheduler<span style=color:#f92672>,</span> <span style=color:#66d9ef>false</span><span style=color:#f92672>,</span> bufferSize<span style=color:#f92672>());</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@CheckReturnValue</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@SchedulerSupport</span><span style=color:#f92672>(</span>SchedulerSupport<span style=color:#f92672>.</span><span style=color:#a6e22e>CUSTOM</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>final</span> Observable<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>observeOn</span><span style=color:#f92672>(</span>Scheduler scheduler<span style=color:#f92672>,</span> <span style=color:#66d9ef>boolean</span> delayError<span style=color:#f92672>,</span> <span style=color:#66d9ef>int</span> bufferSize<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        ObjectHelper<span style=color:#f92672>.</span><span style=color:#a6e22e>requireNonNull</span><span style=color:#f92672>(</span>scheduler<span style=color:#f92672>,</span> <span style=color:#e6db74>&#34;scheduler is null&#34;</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        ObjectHelper<span style=color:#f92672>.</span><span style=color:#a6e22e>verifyPositive</span><span style=color:#f92672>(</span>bufferSize<span style=color:#f92672>,</span> <span style=color:#e6db74>&#34;bufferSize&#34;</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// observeOn显然又返回了一个ObservableObserveOn
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>return</span> RxJavaPlugins<span style=color:#f92672>.</span><span style=color:#a6e22e>onAssembly</span><span style=color:#f92672>(</span><span style=color:#66d9ef>new</span> ObservableObserveOn<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;(</span><span style=color:#66d9ef>this</span><span style=color:#f92672>,</span> scheduler<span style=color:#f92672>,</span> delayError<span style=color:#f92672>,</span> bufferSize<span style=color:#f92672>));</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span></code></pre></div><p>observeOn方法之后我们得到了新的ObservableObserveOn，它保存了ObservableSubscribeOn以及参数AndroidSchedulers.mainThread()，最后调用subscribe方法</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// Observable.java
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>@CheckReturnValue</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@SchedulerSupport</span><span style=color:#f92672>(</span>SchedulerSupport<span style=color:#f92672>.</span><span style=color:#a6e22e>NONE</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>final</span> Disposable <span style=color:#a6e22e>subscribe</span><span style=color:#f92672>(</span>Consumer<span style=color:#f92672>&lt;?</span> <span style=color:#66d9ef>super</span> T<span style=color:#f92672>&gt;</span> onNext<span style=color:#f92672>,</span> Consumer<span style=color:#f92672>&lt;?</span> <span style=color:#66d9ef>super</span> Throwable<span style=color:#f92672>&gt;</span> onError<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// subscribe方法可以接受多种参数，比如我这里对应上面的两个Consumer参数，其中第一个Consumer名字是onNext，
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// 第二个Consumer名字是onError，看到这里基本上明白了这两个Consumer的功能，就是执行处理onNext传入的数据以及处理
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// onError传入的异常
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>return</span> subscribe<span style=color:#f92672>(</span>onNext<span style=color:#f92672>,</span> onError<span style=color:#f92672>,</span> Functions<span style=color:#f92672>.</span><span style=color:#a6e22e>EMPTY_ACTION</span><span style=color:#f92672>,</span> Functions<span style=color:#f92672>.</span><span style=color:#a6e22e>emptyConsumer</span><span style=color:#f92672>());</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@CheckReturnValue</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@SchedulerSupport</span><span style=color:#f92672>(</span>SchedulerSupport<span style=color:#f92672>.</span><span style=color:#a6e22e>NONE</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>final</span> Disposable <span style=color:#a6e22e>subscribe</span><span style=color:#f92672>(</span>Consumer<span style=color:#f92672>&lt;?</span> <span style=color:#66d9ef>super</span> T<span style=color:#f92672>&gt;</span> onNext<span style=color:#f92672>,</span> Consumer<span style=color:#f92672>&lt;?</span> <span style=color:#66d9ef>super</span> Throwable<span style=color:#f92672>&gt;</span> onError<span style=color:#f92672>,</span>
</span></span><span style=display:flex><span>            Action onComplete<span style=color:#f92672>,</span> Consumer<span style=color:#f92672>&lt;?</span> <span style=color:#66d9ef>super</span> Disposable<span style=color:#f92672>&gt;</span> onSubscribe<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        ObjectHelper<span style=color:#f92672>.</span><span style=color:#a6e22e>requireNonNull</span><span style=color:#f92672>(</span>onNext<span style=color:#f92672>,</span> <span style=color:#e6db74>&#34;onNext is null&#34;</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        ObjectHelper<span style=color:#f92672>.</span><span style=color:#a6e22e>requireNonNull</span><span style=color:#f92672>(</span>onError<span style=color:#f92672>,</span> <span style=color:#e6db74>&#34;onError is null&#34;</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        ObjectHelper<span style=color:#f92672>.</span><span style=color:#a6e22e>requireNonNull</span><span style=color:#f92672>(</span>onComplete<span style=color:#f92672>,</span> <span style=color:#e6db74>&#34;onComplete is null&#34;</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        ObjectHelper<span style=color:#f92672>.</span><span style=color:#a6e22e>requireNonNull</span><span style=color:#f92672>(</span>onSubscribe<span style=color:#f92672>,</span> <span style=color:#e6db74>&#34;onSubscribe is null&#34;</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 然后对onNext、onError、onComplete、onSubscribe四个Consumer进行封装，
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// 整合成一个LambdaObserver，也就是说，本质上我们subscribe的参数最终还是Observer
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        LambdaObserver<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> ls <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> LambdaObserver<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;(</span>onNext<span style=color:#f92672>,</span> onError<span style=color:#f92672>,</span> onComplete<span style=color:#f92672>,</span> onSubscribe<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        subscribe<span style=color:#f92672>(</span>ls<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> ls<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@SchedulerSupport</span><span style=color:#f92672>(</span>SchedulerSupport<span style=color:#f92672>.</span><span style=color:#a6e22e>NONE</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>subscribe</span><span style=color:#f92672>(</span>Observer<span style=color:#f92672>&lt;?</span> <span style=color:#66d9ef>super</span> T<span style=color:#f92672>&gt;</span> observer<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        ObjectHelper<span style=color:#f92672>.</span><span style=color:#a6e22e>requireNonNull</span><span style=color:#f92672>(</span>observer<span style=color:#f92672>,</span> <span style=color:#e6db74>&#34;observer is null&#34;</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// RxJavaPlugins.onSubscribe类似上面的onAssembly方法，这里没有做任何操作
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// 等价于observer = observer
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            observer <span style=color:#f92672>=</span> RxJavaPlugins<span style=color:#f92672>.</span><span style=color:#a6e22e>onSubscribe</span><span style=color:#f92672>(</span><span style=color:#66d9ef>this</span><span style=color:#f92672>,</span> observer<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            ObjectHelper<span style=color:#f92672>.</span><span style=color:#a6e22e>requireNonNull</span><span style=color:#f92672>(</span>observer<span style=color:#f92672>,</span> <span style=color:#e6db74>&#34;The RxJavaPlugins.onSubscribe hook returned a null Observer. Please change the handler provided to RxJavaPlugins.setOnObservableSubscribe for invalid null returns. Further reading: https://github.com/ReactiveX/RxJava/wiki/Plugins&#34;</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 然后调用subscribeActual，要知道ObservableObserveOn中重写了subscribeActual方法，所以我们再回到
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// ObservableObserveOn中，需要记住的是这个observer保存了我们定义的两个Consumer
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            subscribeActual<span style=color:#f92672>(</span>observer<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span> <span style=color:#66d9ef>catch</span> <span style=color:#f92672>(</span>NullPointerException e<span style=color:#f92672>)</span> <span style=color:#f92672>{</span> <span style=color:#75715e>// NOPMD
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>throw</span> e<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span> <span style=color:#66d9ef>catch</span> <span style=color:#f92672>(</span>Throwable e<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            Exceptions<span style=color:#f92672>.</span><span style=color:#a6e22e>throwIfFatal</span><span style=color:#f92672>(</span>e<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// can&#39;t call onError because no way to know if a Disposable has been set or not
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// can&#39;t call onSubscribe because the call might have set a Subscription already
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            RxJavaPlugins<span style=color:#f92672>.</span><span style=color:#a6e22e>onError</span><span style=color:#f92672>(</span>e<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            NullPointerException npe <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> NullPointerException<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;Actually not, but can&#39;t throw other exceptions due to RS&#34;</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>            npe<span style=color:#f92672>.</span><span style=color:#a6e22e>initCause</span><span style=color:#f92672>(</span>e<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>throw</span> npe<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span></code></pre></div><p>前面的构造Observable的顺序是：CallExecuteObservable -> BodyObservable -> ObservableSubscribeOn -> ObservableObserveOn，每一级Observable都是以上一级Observable作为参数够早的，CallExecuteObservable和BodyObservable是没有设置Scheduler参数的，ObservableSubscribeOn和ObservableObserveOn有Scheduler参数，Scheduler参数决定了Observer执行的线程；当我们调用subscribe方法会自底向上依次调用Observable的subscribeActual方法，在调用subscribeActual方法是会调用上一级的subscribe方法，传入的参数就是Observer，Observer的构造顺序是：自定义Consumer -> LambdaObserver -> ObserveOnObserver -> SubscribeOnObserver -> BodyObserver，最顶层的CallExecuteObservable是没有Observer的，每一级的Observer都会以下一级的Observer作为参数</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// ObservableObserveOn.java
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>subscribeActual</span><span style=color:#f92672>(</span>Observer<span style=color:#f92672>&lt;?</span> <span style=color:#66d9ef>super</span> T<span style=color:#f92672>&gt;</span> observer<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// source就是ObservableObserveOn构造时传入的第一个参数，对应ObservableSubscribeOn，
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// 由于scheduler对应AndroidSchedulers.mainThread()，本质上是HandlerScheduler
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>scheduler <span style=color:#66d9ef>instanceof</span> TrampolineScheduler<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            source<span style=color:#f92672>.</span><span style=color:#a6e22e>subscribe</span><span style=color:#f92672>(</span>observer<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span> <span style=color:#66d9ef>else</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 调用的是HandlerScheduler的createWorker方法,返回的是HandlerWorker，
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// HandlerWorker保存了两个参数，一个是Handler，另一个bool async，
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// 因为AndroidSchedulers.mainThread()，所以此处的Handler是new Handler(Looper.getMainLooper())，
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// 即主线程中的Handler，async为false
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            Scheduler<span style=color:#f92672>.</span><span style=color:#a6e22e>Worker</span> w <span style=color:#f92672>=</span> scheduler<span style=color:#f92672>.</span><span style=color:#a6e22e>createWorker</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 构造新的ObserveOnObserver，传入的参数有LambdaObserver和HandlerWorker
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// 然后调用ObservableSubscribeOn的subscribe方法，这是一个递归调用，subscribe就是上面的，
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// 又因为subscribeActual，所以还是调用ObservableSubscribeOn的subscribeActual方法
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            source<span style=color:#f92672>.</span><span style=color:#a6e22e>subscribe</span><span style=color:#f92672>(</span><span style=color:#66d9ef>new</span> ObserveOnObserver<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;(</span>observer<span style=color:#f92672>,</span> w<span style=color:#f92672>,</span> delayError<span style=color:#f92672>,</span> bufferSize<span style=color:#f92672>));</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span></code></pre></div><p>当我们走到了ObservableSubscribeOn的subscribeActual方法时，需要开始使用observer（上一级Observable的内部类Observer）进行预处理或者发送数据，因为RxJava的onSubscribe是最先被调用的，所以我们需要先调用onSubscribe方法，会依次向上调用Observer的onSubscribe方法，由于Observer保存了如何发送数据的方法onNext以及处理异常的方法onError以及表示已完成的onComplete，所以如果传到最上级的Observable，那么就可以在CallExecuteObservable的subscribeActual方法中调用传入的Observer的各种方法，从而对数据进行发送、处理等</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// ObservableSubscribeOn.java
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>subscribeActual</span><span style=color:#f92672>(</span><span style=color:#66d9ef>final</span> Observer<span style=color:#f92672>&lt;?</span> <span style=color:#66d9ef>super</span> T<span style=color:#f92672>&gt;</span> observer<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// observer是上面构造的ObserveOnObserver，将其转换为SubscribeOnObserver
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// 将上一级传进来的订阅者包装为线程安全的原子变量
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>final</span> SubscribeOnObserver<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> parent <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> SubscribeOnObserver<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;(</span>observer<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 然后调用ObserveOnObserver的onSubscribe，调用onSubscribe即开始预处理，onSubscribe会调用
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// 我们定义的Consumer（本示例未使用onSubscribe的Consumer，所以没有做任何操作）
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        observer<span style=color:#f92672>.</span><span style=color:#a6e22e>onSubscribe</span><span style=color:#f92672>(</span>parent<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// ObservableSubscribeOn的scheduler对应Schedulers.io()，即IoScheduler
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// SubscribeTask会被放在BlockingQueue队列中，这里就是开始执行我们实际请求的关键转折了，
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// 之前都是铺垫，然后在指定的线程中执行source(上一级)的subscribe，即IO线程的工作
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// source.subscribe(parent)，这里的source实际就是BodyObservable
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        parent<span style=color:#f92672>.</span><span style=color:#a6e22e>setDisposable</span><span style=color:#f92672>(</span>scheduler<span style=color:#f92672>.</span><span style=color:#a6e22e>scheduleDirect</span><span style=color:#f92672>(</span><span style=color:#66d9ef>new</span> SubscribeTask<span style=color:#f92672>(</span>parent<span style=color:#f92672>)));</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>SubscribeTask</span> <span style=color:#66d9ef>implements</span> Runnable <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> SubscribeOnObserver<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> parent<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        SubscribeTask<span style=color:#f92672>(</span>SubscribeOnObserver<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> parent<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>parent</span> <span style=color:#f92672>=</span> parent<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>run</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 这里的source是BodyObservable
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            source<span style=color:#f92672>.</span><span style=color:#a6e22e>subscribe</span><span style=color:#f92672>(</span>parent<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>    
</span></span></code></pre></div><p>scheduler的作用就是通过内部Worker将task交给线程池进行处理，因为ObservableSubscribeOn是通过调用subscribeOn方法生成的，因此很大程度上会运行在其他线程，也就是说SubscribeTask的run方法是执行在Worker的线程池中，即从现在开始的subscribe都是在Worker线程中而不是主线程了</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// Scheduler.java
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>@NonNull</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> Disposable <span style=color:#a6e22e>scheduleDirect</span><span style=color:#f92672>(</span><span style=color:#a6e22e>@NonNull</span> Runnable run<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> scheduleDirect<span style=color:#f92672>(</span>run<span style=color:#f92672>,</span> 0L<span style=color:#f92672>,</span> TimeUnit<span style=color:#f92672>.</span><span style=color:#a6e22e>NANOSECONDS</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@NonNull</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> Disposable <span style=color:#a6e22e>scheduleDirect</span><span style=color:#f92672>(</span><span style=color:#a6e22e>@NonNull</span> Runnable run<span style=color:#f92672>,</span> <span style=color:#66d9ef>long</span> delay<span style=color:#f92672>,</span> <span style=color:#a6e22e>@NonNull</span> TimeUnit unit<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 这个createWorker就是IoScheduler的createWorker，返回的是EventLoopWorker，此EventLoopWorker
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// 运行的线程通过线程池CachedWorkerPool提供
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>final</span> Worker w <span style=color:#f92672>=</span> createWorker<span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>final</span> Runnable decoratedRun <span style=color:#f92672>=</span> RxJavaPlugins<span style=color:#f92672>.</span><span style=color:#a6e22e>onSchedule</span><span style=color:#f92672>(</span>run<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        DisposeTask task <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> DisposeTask<span style=color:#f92672>(</span>decoratedRun<span style=color:#f92672>,</span> w<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// w.schedule会在ScheduledThreadPoolExecutor中安排task被执行，task会被放在队列中
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        w<span style=color:#f92672>.</span><span style=color:#a6e22e>schedule</span><span style=color:#f92672>(</span>task<span style=color:#f92672>,</span> delay<span style=color:#f92672>,</span> unit<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> task<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span></code></pre></div><p>在看BodyObservable的subscribe方法前先看一下onSubscribe做了些什么</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// ObservableObserveOn.java 内部类ObserveOnObserver的onSubscribe方法
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>onSubscribe</span><span style=color:#f92672>(</span>Disposable d<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>DisposableHelper<span style=color:#f92672>.</span><span style=color:#a6e22e>validate</span><span style=color:#f92672>(</span><span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>upstream</span><span style=color:#f92672>,</span> d<span style=color:#f92672>))</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>upstream</span> <span style=color:#f92672>=</span> d<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 这里的d是SubscribeOnObserver，所以跳过
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>d <span style=color:#66d9ef>instanceof</span> QueueDisposable<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                    <span style=color:#a6e22e>@SuppressWarnings</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;unchecked&#34;</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>                    QueueDisposable<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> qd <span style=color:#f92672>=</span> <span style=color:#f92672>(</span>QueueDisposable<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;)</span> d<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>int</span> m <span style=color:#f92672>=</span> qd<span style=color:#f92672>.</span><span style=color:#a6e22e>requestFusion</span><span style=color:#f92672>(</span>QueueDisposable<span style=color:#f92672>.</span><span style=color:#a6e22e>ANY</span> <span style=color:#f92672>|</span> QueueDisposable<span style=color:#f92672>.</span><span style=color:#a6e22e>BOUNDARY</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>m <span style=color:#f92672>==</span> QueueDisposable<span style=color:#f92672>.</span><span style=color:#a6e22e>SYNC</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                        sourceMode <span style=color:#f92672>=</span> m<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>                        queue <span style=color:#f92672>=</span> qd<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>                        done <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>                        downstream<span style=color:#f92672>.</span><span style=color:#a6e22e>onSubscribe</span><span style=color:#f92672>(</span><span style=color:#66d9ef>this</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>                        schedule<span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>return</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>                    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>m <span style=color:#f92672>==</span> QueueDisposable<span style=color:#f92672>.</span><span style=color:#a6e22e>ASYNC</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                        sourceMode <span style=color:#f92672>=</span> m<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>                        queue <span style=color:#f92672>=</span> qd<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>                        downstream<span style=color:#f92672>.</span><span style=color:#a6e22e>onSubscribe</span><span style=color:#f92672>(</span><span style=color:#66d9ef>this</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>return</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>                    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>                <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 这个队列用于保存数据，之后会用，bufferSize大小默认是128
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                queue <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> SpscLinkedArrayQueue<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;(</span>bufferSize<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 而downstream是ObserveOnObserver构造函数的第一个参数，即我们调用subscribe方法时
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#75715e>// 传入的LambdaObserver（但是通过Consumer实现的）
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                downstream<span style=color:#f92672>.</span><span style=color:#a6e22e>onSubscribe</span><span style=color:#f92672>(</span><span style=color:#66d9ef>this</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// LambdaObserver.java
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>onSubscribe</span><span style=color:#f92672>(</span>Disposable d<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>DisposableHelper<span style=color:#f92672>.</span><span style=color:#a6e22e>setOnce</span><span style=color:#f92672>(</span><span style=color:#66d9ef>this</span><span style=color:#f92672>,</span> d<span style=color:#f92672>))</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>try</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// onSubscribe也只是调用onSubscribe.accept，还记得上面我们的LambdaObserver构造时仅使用了
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#75715e>// onNext和onError，所以onSubscribe其实是空的，这里没有任何作用
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                onSubscribe<span style=color:#f92672>.</span><span style=color:#a6e22e>accept</span><span style=color:#f92672>(</span><span style=color:#66d9ef>this</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>}</span> <span style=color:#66d9ef>catch</span> <span style=color:#f92672>(</span>Throwable ex<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                Exceptions<span style=color:#f92672>.</span><span style=color:#a6e22e>throwIfFatal</span><span style=color:#f92672>(</span>ex<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>                d<span style=color:#f92672>.</span><span style=color:#a6e22e>dispose</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>                onError<span style=color:#f92672>(</span>ex<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span></code></pre></div><p>回到subscribe的调用链，在子线程（线程池）</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// BodyObservable.java
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>@Override</span> <span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>subscribeActual</span><span style=color:#f92672>(</span>Observer<span style=color:#f92672>&lt;?</span> <span style=color:#66d9ef>super</span> T<span style=color:#f92672>&gt;</span> observer<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 这里的upstream是CallExecuteObservable
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    upstream<span style=color:#f92672>.</span><span style=color:#a6e22e>subscribe</span><span style=color:#f92672>(</span><span style=color:#66d9ef>new</span> BodyObserver<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;(</span>observer<span style=color:#f92672>));</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>}</span>
</span></span></code></pre></div><p>通过subscribe最终调用到了最顶层的Observable的subscribeActual方法，且传入的下一级的内部类Observer，用于提供onXXX方法传递数据，执行在子线程（线程池）</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// CallExecuteObservable.java
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>@Override</span> <span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>subscribeActual</span><span style=color:#f92672>(</span>Observer<span style=color:#f92672>&lt;?</span> <span style=color:#66d9ef>super</span> Response<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;&gt;</span> observer<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Since Call is a one-shot type, clone it for each new observer.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    Call<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> call <span style=color:#f92672>=</span> originalCall<span style=color:#f92672>.</span><span style=color:#a6e22e>clone</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>    CallDisposable disposable <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> CallDisposable<span style=color:#f92672>(</span>call<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// CallExecuteObservable是我们实际开始调用Retrofit请求数据的开始
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// 首先需要调用observer的onSubscribe，这里是BodyObserver，
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// 还记得上面的LambdaObserver的onSubscribe，
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// 这里其实什么事情都没有做
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    observer<span style=color:#f92672>.</span><span style=color:#a6e22e>onSubscribe</span><span style=color:#f92672>(</span>disposable<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>disposable<span style=color:#f92672>.</span><span style=color:#a6e22e>isDisposed</span><span style=color:#f92672>())</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>boolean</span> terminated <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>// 然后调用call.execute()，如果记得Retrofit，那么就知道这里发出了请求，也就是说这个方法执行在IO线程
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      Response<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> response <span style=color:#f92672>=</span> call<span style=color:#f92672>.</span><span style=color:#a6e22e>execute</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> <span style=color:#f92672>(!</span>disposable<span style=color:#f92672>.</span><span style=color:#a6e22e>isDisposed</span><span style=color:#f92672>())</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 然后通过onNext方法将结果发射出去，这个observer就是BodyObserver
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        observer<span style=color:#f92672>.</span><span style=color:#a6e22e>onNext</span><span style=color:#f92672>(</span>response<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> <span style=color:#f92672>(!</span>disposable<span style=color:#f92672>.</span><span style=color:#a6e22e>isDisposed</span><span style=color:#f92672>())</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        terminated <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>        observer<span style=color:#f92672>.</span><span style=color:#a6e22e>onComplete</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span> <span style=color:#66d9ef>catch</span> <span style=color:#f92672>(</span>Throwable t<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>      Exceptions<span style=color:#f92672>.</span><span style=color:#a6e22e>throwIfFatal</span><span style=color:#f92672>(</span>t<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>terminated<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        RxJavaPlugins<span style=color:#f92672>.</span><span style=color:#a6e22e>onError</span><span style=color:#f92672>(</span>t<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>}</span> <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> <span style=color:#f92672>(!</span>disposable<span style=color:#f92672>.</span><span style=color:#a6e22e>isDisposed</span><span style=color:#f92672>())</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>          observer<span style=color:#f92672>.</span><span style=color:#a6e22e>onError</span><span style=color:#f92672>(</span>t<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span> <span style=color:#66d9ef>catch</span> <span style=color:#f92672>(</span>Throwable inner<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>          Exceptions<span style=color:#f92672>.</span><span style=color:#a6e22e>throwIfFatal</span><span style=color:#f92672>(</span>inner<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>          RxJavaPlugins<span style=color:#f92672>.</span><span style=color:#a6e22e>onError</span><span style=color:#f92672>(</span><span style=color:#66d9ef>new</span> CompositeException<span style=color:#f92672>(</span>t<span style=color:#f92672>,</span> inner<span style=color:#f92672>));</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>}</span>
</span></span></code></pre></div><p>onNext方法的向下一级传递</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// BodyObservable.java 内部类BodyObserver的onNext方法
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>@Override</span> <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>onNext</span><span style=color:#f92672>(</span>Response<span style=color:#f92672>&lt;</span>R<span style=color:#f92672>&gt;</span> response<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>response<span style=color:#f92672>.</span><span style=color:#a6e22e>isSuccessful</span><span style=color:#f92672>())</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// BodyObserver判断了一下请求结果response，然后将body发射出去
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// 这里的observer就是SubscribeOnObserver
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        observer<span style=color:#f92672>.</span><span style=color:#a6e22e>onNext</span><span style=color:#f92672>(</span>response<span style=color:#f92672>.</span><span style=color:#a6e22e>body</span><span style=color:#f92672>());</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>}</span> <span style=color:#66d9ef>else</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        terminated <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>        Throwable t <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> HttpException<span style=color:#f92672>(</span>response<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>          observer<span style=color:#f92672>.</span><span style=color:#a6e22e>onError</span><span style=color:#f92672>(</span>t<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span> <span style=color:#66d9ef>catch</span> <span style=color:#f92672>(</span>Throwable inner<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>          Exceptions<span style=color:#f92672>.</span><span style=color:#a6e22e>throwIfFatal</span><span style=color:#f92672>(</span>inner<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>          RxJavaPlugins<span style=color:#f92672>.</span><span style=color:#a6e22e>onError</span><span style=color:#f92672>(</span><span style=color:#66d9ef>new</span> CompositeException<span style=color:#f92672>(</span>t<span style=color:#f92672>,</span> inner<span style=color:#f92672>));</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// ObservableSubscribeOn.java 内部类SubscribeOnObserver
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>onNext</span><span style=color:#f92672>(</span>T t<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 这里的downstream是ObserveOnObserver
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            downstream<span style=color:#f92672>.</span><span style=color:#a6e22e>onNext</span><span style=color:#f92672>(</span>t<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span></code></pre></div><p>这里因为ObservableObserveOn是通过observeOn创建的，而这里发生了线程切换，我们的例子中是主线程，所以需要通过Handler将后续的任务切换到主线程中</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// ObservableObserveOn.java 内部类ObserveOnObserver
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>onNext</span><span style=color:#f92672>(</span>T t<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>done<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>sourceMode <span style=color:#f92672>!=</span> QueueDisposable<span style=color:#f92672>.</span><span style=color:#a6e22e>ASYNC</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 这里的queue是SpscLinkedArrayQueue，我们把传出来的数据保存在队列中了
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                queue<span style=color:#f92672>.</span><span style=color:#a6e22e>offer</span><span style=color:#f92672>(</span>t<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 最终调用schedule
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            schedule<span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>schedule</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>getAndIncrement<span style=color:#f92672>()</span> <span style=color:#f92672>==</span> 0<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// worker是初始化时调用observeOn传入的主线程的HandlerScheduler的内部类HandlerWorker，
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#75715e>// 这里的schedule方法传入this，即ObserveOnObserver，与此同时ObserveOnObserver
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#75715e>// 实现了Runnable的接口，可以作为Runnable，它的run方法会在下面被执行
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                worker<span style=color:#f92672>.</span><span style=color:#a6e22e>schedule</span><span style=color:#f92672>(</span><span style=color:#66d9ef>this</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>        
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// HandlerScheduler.java 内部类HandlerWorker
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>@SuppressLint</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;NewApi&#34;</span><span style=color:#f92672>)</span> <span style=color:#75715e>// Async will only be true when the API is available to call.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>public</span> Disposable <span style=color:#a6e22e>schedule</span><span style=color:#f92672>(</span>Runnable run<span style=color:#f92672>,</span> <span style=color:#66d9ef>long</span> delay<span style=color:#f92672>,</span> TimeUnit unit<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>run <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>)</span> <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> NullPointerException<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;run == null&#34;</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>unit <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>)</span> <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> NullPointerException<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;unit == null&#34;</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>disposed<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> Disposables<span style=color:#f92672>.</span><span style=color:#a6e22e>disposed</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            run <span style=color:#f92672>=</span> RxJavaPlugins<span style=color:#f92672>.</span><span style=color:#a6e22e>onSchedule</span><span style=color:#f92672>(</span>run<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// HandlerWorker的schedule方法，我们传入的run即上面的ObserveOnObserver
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// ScheduledRunnable也是Runnable，但是它的run方法仅仅是调用了传入的run的run方法
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// 也就是说如果我们执行了scheduled的run方法等价于执行了run的方法，也就是
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// ObserveOnObserver的run方法
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            ScheduledRunnable scheduled <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ScheduledRunnable<span style=color:#f92672>(</span>handler<span style=color:#f92672>,</span> run<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// scheduled的run方法执行是通过handler处理的，通过sendMessageDelayed实现的
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            Message message <span style=color:#f92672>=</span> Message<span style=color:#f92672>.</span><span style=color:#a6e22e>obtain</span><span style=color:#f92672>(</span>handler<span style=color:#f92672>,</span> scheduled<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>            message<span style=color:#f92672>.</span><span style=color:#a6e22e>obj</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span><span style=color:#f92672>;</span> <span style=color:#75715e>// Used as token for batch disposal of this worker&#39;s runnables.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>async<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                message<span style=color:#f92672>.</span><span style=color:#a6e22e>setAsynchronous</span><span style=color:#f92672>(</span><span style=color:#66d9ef>true</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 也就是在这里我们将在主线程执行ObserveOnObserver的run方法
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            handler<span style=color:#f92672>.</span><span style=color:#a6e22e>sendMessageDelayed</span><span style=color:#f92672>(</span>message<span style=color:#f92672>,</span> unit<span style=color:#f92672>.</span><span style=color:#a6e22e>toMillis</span><span style=color:#f92672>(</span>delay<span style=color:#f92672>));</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Re-check disposed state for removing in case we were racing a call to dispose().
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>disposed<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                handler<span style=color:#f92672>.</span><span style=color:#a6e22e>removeCallbacks</span><span style=color:#f92672>(</span>scheduled<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> Disposables<span style=color:#f92672>.</span><span style=color:#a6e22e>disposed</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> scheduled<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// ObservableObserveOn.java 内部类ObserveOnObserver
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>run</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>outputFused<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                drainFused<span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>}</span> <span style=color:#66d9ef>else</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 这里执行的是drainNormal
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                drainNormal<span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>drainNormal</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> missed <span style=color:#f92672>=</span> 1<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 还记得上面的SpscLinkedArrayQueue，之前我们在onNext方法中把传过来的数据保存在队列中
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// 接下来需要从队列中取出数据
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>final</span> SimpleQueue<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> q <span style=color:#f92672>=</span> queue<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// downstream即LambdaObserver
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>final</span> Observer<span style=color:#f92672>&lt;?</span> <span style=color:#66d9ef>super</span> T<span style=color:#f92672>&gt;</span> a <span style=color:#f92672>=</span> downstream<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 这里用循环是因为RxJava支持连续发送多个数据，那么最终数据都保存在队列中
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// 所以取数据的时候就可以通过循环来一次性获取队列中的所有数据，而SpscLinkedArrayQueue
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// 的最大容量，根据之前的代码我们知道是128
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>for</span> <span style=color:#f92672>(;;)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>checkTerminated<span style=color:#f92672>(</span>done<span style=color:#f92672>,</span> q<span style=color:#f92672>.</span><span style=color:#a6e22e>isEmpty</span><span style=color:#f92672>(),</span> a<span style=color:#f92672>))</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>return</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>                <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>for</span> <span style=color:#f92672>(;;)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>boolean</span> d <span style=color:#f92672>=</span> done<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>                    T v<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>try</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                        <span style=color:#75715e>// q.poll从队列中取出数据
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                        v <span style=color:#f92672>=</span> q<span style=color:#f92672>.</span><span style=color:#a6e22e>poll</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>                    <span style=color:#f92672>}</span> <span style=color:#66d9ef>catch</span> <span style=color:#f92672>(</span>Throwable ex<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                        Exceptions<span style=color:#f92672>.</span><span style=color:#a6e22e>throwIfFatal</span><span style=color:#f92672>(</span>ex<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>                        disposed <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>                        upstream<span style=color:#f92672>.</span><span style=color:#a6e22e>dispose</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>                        q<span style=color:#f92672>.</span><span style=color:#a6e22e>clear</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>                        a<span style=color:#f92672>.</span><span style=color:#a6e22e>onError</span><span style=color:#f92672>(</span>ex<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>                        worker<span style=color:#f92672>.</span><span style=color:#a6e22e>dispose</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>return</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>                    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>boolean</span> empty <span style=color:#f92672>=</span> v <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>checkTerminated<span style=color:#f92672>(</span>d<span style=color:#f92672>,</span> empty<span style=color:#f92672>,</span> a<span style=color:#f92672>))</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>return</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>                    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>empty<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>break</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>                    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// a即为LambdaObserver，v为我们从队列中取出来的数据，也是
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#75715e>// 我们通过handler传入的数据，通过onNext发出，而这个onNext
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#75715e>// 就是我们定义的第一个Consumer，通过这个Consumer的accept方法
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#75715e>// 在主线程实现TextView的设置
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    a<span style=color:#f92672>.</span><span style=color:#a6e22e>onNext</span><span style=color:#f92672>(</span>v<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>                <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                missed <span style=color:#f92672>=</span> addAndGet<span style=color:#f92672>(-</span>missed<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>missed <span style=color:#f92672>==</span> 0<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>break</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>                <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// LambdaObserver.java
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>onNext</span><span style=color:#f92672>(</span>T t<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>(!</span>isDisposed<span style=color:#f92672>())</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>try</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 我们定义的Consumer的accept方法
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                onNext<span style=color:#f92672>.</span><span style=color:#a6e22e>accept</span><span style=color:#f92672>(</span>t<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>}</span> <span style=color:#66d9ef>catch</span> <span style=color:#f92672>(</span>Throwable e<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                Exceptions<span style=color:#f92672>.</span><span style=color:#a6e22e>throwIfFatal</span><span style=color:#f92672>(</span>e<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>                get<span style=color:#f92672>().</span><span style=color:#a6e22e>dispose</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>                onError<span style=color:#f92672>(</span>e<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span></code></pre></div><p>综上，RxJava的简单源码分析流程就完成了，整个RxJava调用流程可以分为两个阶段：构造阶段和subscribe阶段，在调用subscribe方法前的步骤我称之为构造阶段，这个过程中主要工作是创建被观察者Observable，每一次使用RxJava的方法时都会创建新的Observable，每个新的Observable都会以上一级的Observable作为参数，其中部分Observable还需要Scheduler参数，用于切换线程，构造阶段仅仅是将Observable连接起来；在调用subscribe方法时开始了subscribe阶段，这个阶段的任务是将我们自定义的Consumer（或者可以当作观察者Observer）通过Observable的subscribe方法连接起来（subscribe的过程中可能会调用onSubscribe方法进行预处理，初始化一些队列什么的，onSubscribe方法与onNext、onError、onComplete方法有点区别），当我们的subscribe方法走到最顶层时会开始启动Observer的onXXX方法传递数据或者传出异常等等，因为之前已经将Observer连接起来，所以此时onXXX方法的调用也是链式的，层层向下传递，直到调用我们自定义的Consumer（在此过程中会通过在构造阶段传入的Scheduler实现线程切换）。</p><p>如果完整的看过一遍分析流程就会发现其实Observable和Observer的调用链是很简单的，但是随之也有几个疑问：</p><blockquote><p>1.为什么要用Observable和Observer的形式？</p></blockquote><p>首先需要明白的是，RxJava的目的是提供一个便于进行数据处理的框架，通过流式调用实现线程切换、数据类型转换等，也就是说数据从A -> B -> C可以是不同类型的数据或者是在不同线程处理，最适合的模式就是观察者模式，比如我们常见的OnClickListener，它传递的是点击事件，再比如我们自定义的传递数据的接口回调，都是观察者模式。简而言之就是，A通过B提供的接口将数据传到B中进行处理，B通过C提供的接口将数传到C中进行处理，由此可以进行数据的传递，当然这只是数据传递的流程，具体的调用流程就是上面的总结。使用Observable和Observer的形式，一是便于我们自定义数据转换的Observable和Observer，二是可以实现流式调用，三是这里面实现了这种接口回调的功能。</p><blockquote><p>2.subscribeOn和observeOn是如何切换线程的？</p></blockquote><p>subscribeOn会指定我们在调用subscribeOn之前的Observable中数据处理的线程，observeOn会指定我们在调用observeOn之后的Observable中数据处理的线程。这是因为两者切换线程的位置不同，subscribeOn会在subscribeActual的方法中切换线程，导致后续所有的调用都是在subscribeOn指定的线程中，而subscribeActual方法是自底向上调用的，因此会影响subscribeOn之前的所有方法；而observeOn是在ObserveOnObserver的onNext方法中进行线程切换的，因此会影响observeOn后面数据传递的方法。</p><h2 id=参考>参考：<a hidden class=anchor aria-hidden=true href=#参考>#</a></h2><ol><li><a href=https://github.com/ReactiveX/RxJava/tree/2.x>RxJava2</a></li><li><a href=http://greenrobot.org/eventbus/>EventBus</a></li><li><a href=https://www.jianshu.com/p/1a5a3db45cfa>Android Handler 消息机制详述</a></li><li><a href=https://www.jianshu.com/p/ee1342fcf5e7>Android 多线程：手把手教你使用AsyncTask</a></li><li><a href=https://juejin.im/post/5a6c36fff265da3e2f012f82>EventBus使用详解</a></li><li><a href=https://juejin.im/post/5a224cc76fb9a04527256683>Rxjava这一篇就够了，墙裂推荐</a></li><li><a href=http://www.10tiao.com/html/227/201802/2650242399/1.html>精彩的RxJava源码剖析</a></li><li><a href=http://gank.io/post/560e15be2dca930e00da1083>给 Android 开发者的 RxJava 详解</a></li></ol></div><footer class=post-footer><ul class=post-tags><li><a href=https://zhoutao822.github.io/tags/handler/>Handler</a></li><li><a href=https://zhoutao822.github.io/tags/asynctask/>AsyncTask</a></li><li><a href=https://zhoutao822.github.io/tags/eventbus/>EventBus</a></li><li><a href=https://zhoutao822.github.io/tags/rxjava/>RxJava</a></li></ul><nav class=paginav><a class=prev href=https://zhoutao822.github.io/posts/saf/><span class=title>« Prev Page</span><br><span>Android-Q适配-存储方式</span></a>
<a class=next href=https://zhoutao822.github.io/posts/snackbar/><span class=title>Next Page »</span><br><span>Material组件-Snackbar</span></a></nav></footer><script src=https://utteranc.es/client.js repo=zhoutao822/zhoutao822.github.io issue-term=title theme=github-dark crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2022 <a href=https://zhoutao822.github.io/>Tao's Notes</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="copy";function s(){t.innerText="copied!",setTimeout(()=>{t.innerText="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>